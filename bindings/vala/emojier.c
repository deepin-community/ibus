/* emojier.c generated by valac 0.52.4, the Vala compiler
 * generated from emojier.vala, do not modify */

/* vim:set et sts=4 sw=4:
 *
 * ibus - The Input Bus
 *
 * Copyright (c) 2017-2019 Takao Fujiwara <takao.fujiwara1@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 * USA
 */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <ibus.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <glib/gi18n-lib.h>
#include <gio/gio.h>
#include <config.h>
#include <locale.h>
#include <cairo-gobject.h>
#include <pango/pango.h>

#define TYPE_IBUS_EMOJIER (ibus_emojier_get_type ())
#define IBUS_EMOJIER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IBUS_EMOJIER, IBusEmojier))
#define IBUS_EMOJIER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_IBUS_EMOJIER, IBusEmojierClass))
#define IS_IBUS_EMOJIER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IBUS_EMOJIER))
#define IS_IBUS_EMOJIER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_IBUS_EMOJIER))
#define IBUS_EMOJIER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_IBUS_EMOJIER, IBusEmojierClass))

typedef struct _IBusEmojier IBusEmojier;
typedef struct _IBusEmojierClass IBusEmojierClass;
typedef struct _IBusEmojierPrivate IBusEmojierPrivate;

#define TYPE_THEMED_RGBA (themed_rgba_get_type ())
#define THEMED_RGBA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_THEMED_RGBA, ThemedRGBA))
#define THEMED_RGBA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_THEMED_RGBA, ThemedRGBAClass))
#define IS_THEMED_RGBA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_THEMED_RGBA))
#define IS_THEMED_RGBA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_THEMED_RGBA))
#define THEMED_RGBA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_THEMED_RGBA, ThemedRGBAClass))

typedef struct _ThemedRGBA ThemedRGBA;
typedef struct _ThemedRGBAClass ThemedRGBAClass;

#define IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW (ibus_emojier_escrolled_window_get_type ())
#define IBUS_EMOJIER_ESCROLLED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW, IBusEmojierEScrolledWindow))
#define IBUS_EMOJIER_ESCROLLED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW, IBusEmojierEScrolledWindowClass))
#define IBUS_EMOJIER_IS_ESCROLLED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW))
#define IBUS_EMOJIER_IS_ESCROLLED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW))
#define IBUS_EMOJIER_ESCROLLED_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW, IBusEmojierEScrolledWindowClass))

typedef struct _IBusEmojierEScrolledWindow IBusEmojierEScrolledWindow;
typedef struct _IBusEmojierEScrolledWindowClass IBusEmojierEScrolledWindowClass;

#define IBUS_EMOJIER_TYPE_ELIST_BOX (ibus_emojier_elist_box_get_type ())
#define IBUS_EMOJIER_ELIST_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_ELIST_BOX, IBusEmojierEListBox))
#define IBUS_EMOJIER_ELIST_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_ELIST_BOX, IBusEmojierEListBoxClass))
#define IBUS_EMOJIER_IS_ELIST_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_ELIST_BOX))
#define IBUS_EMOJIER_IS_ELIST_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_ELIST_BOX))
#define IBUS_EMOJIER_ELIST_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_ELIST_BOX, IBusEmojierEListBoxClass))

typedef struct _IBusEmojierEListBox IBusEmojierEListBox;
typedef struct _IBusEmojierEListBoxClass IBusEmojierEListBoxClass;
enum  {
	IBUS_EMOJIER_0_PROPERTY,
	IBUS_EMOJIER_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_properties[IBUS_EMOJIER_NUM_PROPERTIES];
typedef enum  {
	IBUS_EMOJIER_TRAVEL_DIRECTION_NONE,
	IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD
} IBusEmojierTravelDirection;

#define IBUS_EMOJIER_TYPE_TRAVEL_DIRECTION (ibus_emojier_travel_direction_get_type ())

#define IBUS_EMOJIER_TYPE_LOAD_PROGRESS_OBJECT (ibus_emojier_load_progress_object_get_type ())
#define IBUS_EMOJIER_LOAD_PROGRESS_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_LOAD_PROGRESS_OBJECT, IBusEmojierLoadProgressObject))
#define IBUS_EMOJIER_LOAD_PROGRESS_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_LOAD_PROGRESS_OBJECT, IBusEmojierLoadProgressObjectClass))
#define IBUS_EMOJIER_IS_LOAD_PROGRESS_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_LOAD_PROGRESS_OBJECT))
#define IBUS_EMOJIER_IS_LOAD_PROGRESS_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_LOAD_PROGRESS_OBJECT))
#define IBUS_EMOJIER_LOAD_PROGRESS_OBJECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_LOAD_PROGRESS_OBJECT, IBusEmojierLoadProgressObjectClass))

typedef struct _IBusEmojierLoadProgressObject IBusEmojierLoadProgressObject;
typedef struct _IBusEmojierLoadProgressObjectClass IBusEmojierLoadProgressObjectClass;
#define _themed_rgba_unref0(var) ((var == NULL) ? NULL : (var = (themed_rgba_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define IBUS_EMOJIER_TYPE_EBOX_ROW (ibus_emojier_ebox_row_get_type ())
#define IBUS_EMOJIER_EBOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRow))
#define IBUS_EMOJIER_EBOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRowClass))
#define IBUS_EMOJIER_IS_EBOX_ROW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EBOX_ROW))
#define IBUS_EMOJIER_IS_EBOX_ROW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EBOX_ROW))
#define IBUS_EMOJIER_EBOX_ROW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRowClass))

typedef struct _IBusEmojierEBoxRow IBusEmojierEBoxRow;
typedef struct _IBusEmojierEBoxRowClass IBusEmojierEBoxRowClass;

#define IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX (ibus_emojier_epadded_label_box_get_type ())
#define IBUS_EMOJIER_EPADDED_LABEL_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX, IBusEmojierEPaddedLabelBox))
#define IBUS_EMOJIER_EPADDED_LABEL_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX, IBusEmojierEPaddedLabelBoxClass))
#define IBUS_EMOJIER_IS_EPADDED_LABEL_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX))
#define IBUS_EMOJIER_IS_EPADDED_LABEL_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX))
#define IBUS_EMOJIER_EPADDED_LABEL_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX, IBusEmojierEPaddedLabelBoxClass))

typedef struct _IBusEmojierEPaddedLabelBox IBusEmojierEPaddedLabelBox;
typedef struct _IBusEmojierEPaddedLabelBoxClass IBusEmojierEPaddedLabelBoxClass;
typedef struct _Block4Data Block4Data;
#define _pango_attr_list_unref0(var) ((var == NULL) ? NULL : (var = (pango_attr_list_unref (var), NULL)))

#define IBUS_EMOJIER_TYPE_EGRID (ibus_emojier_egrid_get_type ())
#define IBUS_EMOJIER_EGRID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EGRID, IBusEmojierEGrid))
#define IBUS_EMOJIER_EGRID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EGRID, IBusEmojierEGridClass))
#define IBUS_EMOJIER_IS_EGRID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EGRID))
#define IBUS_EMOJIER_IS_EGRID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EGRID))
#define IBUS_EMOJIER_EGRID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EGRID, IBusEmojierEGridClass))

typedef struct _IBusEmojierEGrid IBusEmojierEGrid;
typedef struct _IBusEmojierEGridClass IBusEmojierEGridClass;
typedef struct _Block5Data Block5Data;

#define IBUS_EMOJIER_TYPE_EWHITE_LABEL (ibus_emojier_ewhite_label_get_type ())
#define IBUS_EMOJIER_EWHITE_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EWHITE_LABEL, IBusEmojierEWhiteLabel))
#define IBUS_EMOJIER_EWHITE_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EWHITE_LABEL, IBusEmojierEWhiteLabelClass))
#define IBUS_EMOJIER_IS_EWHITE_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EWHITE_LABEL))
#define IBUS_EMOJIER_IS_EWHITE_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EWHITE_LABEL))
#define IBUS_EMOJIER_EWHITE_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EWHITE_LABEL, IBusEmojierEWhiteLabelClass))

typedef struct _IBusEmojierEWhiteLabel IBusEmojierEWhiteLabel;
typedef struct _IBusEmojierEWhiteLabelClass IBusEmojierEWhiteLabelClass;

#define IBUS_EMOJIER_TYPE_ESELECTED_LABEL (ibus_emojier_eselected_label_get_type ())
#define IBUS_EMOJIER_ESELECTED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_ESELECTED_LABEL, IBusEmojierESelectedLabel))
#define IBUS_EMOJIER_ESELECTED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_ESELECTED_LABEL, IBusEmojierESelectedLabelClass))
#define IBUS_EMOJIER_IS_ESELECTED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_ESELECTED_LABEL))
#define IBUS_EMOJIER_IS_ESELECTED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_ESELECTED_LABEL))
#define IBUS_EMOJIER_ESELECTED_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_ESELECTED_LABEL, IBusEmojierESelectedLabelClass))

typedef struct _IBusEmojierESelectedLabel IBusEmojierESelectedLabel;
typedef struct _IBusEmojierESelectedLabelClass IBusEmojierESelectedLabelClass;

#define IBUS_EMOJIER_TYPE_EGOLD_LABEL (ibus_emojier_egold_label_get_type ())
#define IBUS_EMOJIER_EGOLD_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EGOLD_LABEL, IBusEmojierEGoldLabel))
#define IBUS_EMOJIER_EGOLD_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EGOLD_LABEL, IBusEmojierEGoldLabelClass))
#define IBUS_EMOJIER_IS_EGOLD_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EGOLD_LABEL))
#define IBUS_EMOJIER_IS_EGOLD_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EGOLD_LABEL))
#define IBUS_EMOJIER_EGOLD_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EGOLD_LABEL, IBusEmojierEGoldLabelClass))

typedef struct _IBusEmojierEGoldLabel IBusEmojierEGoldLabel;
typedef struct _IBusEmojierEGoldLabelClass IBusEmojierEGoldLabelClass;
#define __vala_GdkEventMotion_free0(var) ((var == NULL) ? NULL : (var = (_vala_GdkEventMotion_free (var), NULL)))
#define __vala_PangoFontDescription_free0(var) ((var == NULL) ? NULL : (var = (_vala_PangoFontDescription_free (var), NULL)))
typedef struct _IBusEmojierEListBoxPrivate IBusEmojierEListBoxPrivate;
enum  {
	IBUS_EMOJIER_ELIST_BOX_0_PROPERTY,
	IBUS_EMOJIER_ELIST_BOX_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_elist_box_properties[IBUS_EMOJIER_ELIST_BOX_NUM_PROPERTIES];
typedef struct _IBusEmojierEBoxRowPrivate IBusEmojierEBoxRowPrivate;
enum  {
	IBUS_EMOJIER_EBOX_ROW_0_PROPERTY,
	IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY,
	IBUS_EMOJIER_EBOX_ROW_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_ebox_row_properties[IBUS_EMOJIER_EBOX_ROW_NUM_PROPERTIES];
typedef struct _IBusEmojierEScrolledWindowPrivate IBusEmojierEScrolledWindowPrivate;
enum  {
	IBUS_EMOJIER_ESCROLLED_WINDOW_0_PROPERTY,
	IBUS_EMOJIER_ESCROLLED_WINDOW_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_escrolled_window_properties[IBUS_EMOJIER_ESCROLLED_WINDOW_NUM_PROPERTIES];
typedef struct _IBusEmojierEGridPrivate IBusEmojierEGridPrivate;
enum  {
	IBUS_EMOJIER_EGRID_0_PROPERTY,
	IBUS_EMOJIER_EGRID_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_egrid_properties[IBUS_EMOJIER_EGRID_NUM_PROPERTIES];
typedef struct _IBusEmojierEWhiteLabelPrivate IBusEmojierEWhiteLabelPrivate;
enum  {
	IBUS_EMOJIER_EWHITE_LABEL_0_PROPERTY,
	IBUS_EMOJIER_EWHITE_LABEL_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_ewhite_label_properties[IBUS_EMOJIER_EWHITE_LABEL_NUM_PROPERTIES];
typedef struct _IBusEmojierESelectedLabelPrivate IBusEmojierESelectedLabelPrivate;
enum  {
	IBUS_EMOJIER_ESELECTED_LABEL_0_PROPERTY,
	IBUS_EMOJIER_ESELECTED_LABEL_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_eselected_label_properties[IBUS_EMOJIER_ESELECTED_LABEL_NUM_PROPERTIES];
typedef struct _IBusEmojierEGoldLabelPrivate IBusEmojierEGoldLabelPrivate;
enum  {
	IBUS_EMOJIER_EGOLD_LABEL_0_PROPERTY,
	IBUS_EMOJIER_EGOLD_LABEL_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_egold_label_properties[IBUS_EMOJIER_EGOLD_LABEL_NUM_PROPERTIES];

#define IBUS_EMOJIER_TYPE_EPADDED_LABEL (ibus_emojier_epadded_label_get_type ())
#define IBUS_EMOJIER_EPADDED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL, IBusEmojierEPaddedLabel))
#define IBUS_EMOJIER_EPADDED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), IBUS_EMOJIER_TYPE_EPADDED_LABEL, IBusEmojierEPaddedLabelClass))
#define IBUS_EMOJIER_IS_EPADDED_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL))
#define IBUS_EMOJIER_IS_EPADDED_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), IBUS_EMOJIER_TYPE_EPADDED_LABEL))
#define IBUS_EMOJIER_EPADDED_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), IBUS_EMOJIER_TYPE_EPADDED_LABEL, IBusEmojierEPaddedLabelClass))

typedef struct _IBusEmojierEPaddedLabel IBusEmojierEPaddedLabel;
typedef struct _IBusEmojierEPaddedLabelClass IBusEmojierEPaddedLabelClass;
typedef struct _IBusEmojierEPaddedLabelPrivate IBusEmojierEPaddedLabelPrivate;
enum  {
	IBUS_EMOJIER_EPADDED_LABEL_0_PROPERTY,
	IBUS_EMOJIER_EPADDED_LABEL_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_epadded_label_properties[IBUS_EMOJIER_EPADDED_LABEL_NUM_PROPERTIES];
typedef struct _IBusEmojierEPaddedLabelBoxPrivate IBusEmojierEPaddedLabelBoxPrivate;
enum  {
	IBUS_EMOJIER_EPADDED_LABEL_BOX_0_PROPERTY,
	IBUS_EMOJIER_EPADDED_LABEL_BOX_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_epadded_label_box_properties[IBUS_EMOJIER_EPADDED_LABEL_BOX_NUM_PROPERTIES];

#define TYPE_ICON_WIDGET (icon_widget_get_type ())
#define ICON_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ICON_WIDGET, IconWidget))
#define ICON_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ICON_WIDGET, IconWidgetClass))
#define IS_ICON_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ICON_WIDGET))
#define IS_ICON_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ICON_WIDGET))
#define ICON_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ICON_WIDGET, IconWidgetClass))

typedef struct _IconWidget IconWidget;
typedef struct _IconWidgetClass IconWidgetClass;
typedef struct _IBusEmojierLoadProgressObjectPrivate IBusEmojierLoadProgressObjectPrivate;
enum  {
	IBUS_EMOJIER_LOAD_PROGRESS_OBJECT_0_PROPERTY,
	IBUS_EMOJIER_LOAD_PROGRESS_OBJECT_NUM_PROPERTIES
};
static GParamSpec* ibus_emojier_load_progress_object_properties[IBUS_EMOJIER_LOAD_PROGRESS_OBJECT_NUM_PROPERTIES];
enum  {
	IBUS_EMOJIER_LOAD_PROGRESS_OBJECT_DESERIALIZE_UNICODE_SIGNAL,
	IBUS_EMOJIER_LOAD_PROGRESS_OBJECT_NUM_SIGNALS
};
static guint ibus_emojier_load_progress_object_signals[IBUS_EMOJIER_LOAD_PROGRESS_OBJECT_NUM_SIGNALS] = {0};
enum  {
	IBUS_EMOJIER_CANDIDATE_CLICKED_SIGNAL,
	IBUS_EMOJIER_COMMIT_TEXT_SIGNAL,
	IBUS_EMOJIER_CANCEL_SIGNAL,
	IBUS_EMOJIER_NUM_SIGNALS
};
static guint ibus_emojier_signals[IBUS_EMOJIER_NUM_SIGNALS] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _IBusEmojier {
	GtkApplicationWindow parent_instance;
	IBusEmojierPrivate * priv;
};

struct _IBusEmojierClass {
	GtkApplicationWindowClass parent_class;
};

struct _IBusEmojierPrivate {
	ThemedRGBA* m_rgba;
	GtkBox* m_vbox;
	gchar* m_annotation;
	gchar* m_backward;
	gint m_backward_index;
	IBusEmojierEScrolledWindow* m_scrolled_window;
	IBusEmojierEListBox* m_list_box;
	gboolean m_is_running;
	gchar* m_input_context_path;
	GMainLoop* m_loop;
	gchar* m_result;
	gboolean m_candidate_panel_is_visible;
	gboolean m_candidate_panel_mode;
	gint m_category_active_index;
	IBusLookupTable* m_lookup_table;
	GtkLabel** m_candidates;
	gint m_candidates_length1;
	gint _m_candidates_size_;
	gboolean m_enter_notify_enable;
	guint m_entry_notify_show_id;
	guint m_entry_notify_disable_id;
	GtkProgressBar* m_unicode_progress_bar;
	guint m_unicode_progress_id;
	GtkLabel* m_unicode_percent_label;
	gdouble m_unicode_percent;
	GdkRectangle m_cursor_location;
	gboolean m_is_up_side_down;
	guint m_redraw_window_id;
};

struct _Block4Data {
	int _ref_count_;
	IBusEmojier* self;
	GtkButton* warning_button;
};

struct _Block5Data {
	int _ref_count_;
	IBusEmojier* self;
	guint index;
};

struct _IBusEmojierEListBox {
	GtkListBox parent_instance;
	IBusEmojierEListBoxPrivate * priv;
};

struct _IBusEmojierEListBoxClass {
	GtkListBoxClass parent_class;
};

struct _IBusEmojierEBoxRow {
	GtkListBoxRow parent_instance;
	IBusEmojierEBoxRowPrivate * priv;
};

struct _IBusEmojierEBoxRowClass {
	GtkListBoxRowClass parent_class;
};

struct _IBusEmojierEBoxRowPrivate {
	gchar* _text;
};

struct _IBusEmojierEScrolledWindow {
	GtkScrolledWindow parent_instance;
	IBusEmojierEScrolledWindowPrivate * priv;
};

struct _IBusEmojierEScrolledWindowClass {
	GtkScrolledWindowClass parent_class;
};

struct _IBusEmojierEGrid {
	GtkGrid parent_instance;
	IBusEmojierEGridPrivate * priv;
};

struct _IBusEmojierEGridClass {
	GtkGridClass parent_class;
};

struct _IBusEmojierEWhiteLabel {
	GtkLabel parent_instance;
	IBusEmojierEWhiteLabelPrivate * priv;
};

struct _IBusEmojierEWhiteLabelClass {
	GtkLabelClass parent_class;
};

struct _IBusEmojierEWhiteLabelPrivate {
	gint m_minimum_width;
	gint m_natural_width;
	gint m_minimum_height;
	gint m_natural_height;
};

struct _IBusEmojierESelectedLabel {
	IBusEmojierEWhiteLabel parent_instance;
	IBusEmojierESelectedLabelPrivate * priv;
};

struct _IBusEmojierESelectedLabelClass {
	IBusEmojierEWhiteLabelClass parent_class;
};

struct _IBusEmojierEGoldLabel {
	IBusEmojierEWhiteLabel parent_instance;
	IBusEmojierEGoldLabelPrivate * priv;
};

struct _IBusEmojierEGoldLabelClass {
	IBusEmojierEWhiteLabelClass parent_class;
};

struct _IBusEmojierEPaddedLabel {
	GtkLabel parent_instance;
	IBusEmojierEPaddedLabelPrivate * priv;
};

struct _IBusEmojierEPaddedLabelClass {
	GtkLabelClass parent_class;
};

struct _IBusEmojierEPaddedLabelBox {
	GtkBox parent_instance;
	IBusEmojierEPaddedLabelBoxPrivate * priv;
};

struct _IBusEmojierEPaddedLabelBoxClass {
	GtkBoxClass parent_class;
};

struct _IBusEmojierLoadProgressObject {
	GObject parent_instance;
	IBusEmojierLoadProgressObjectPrivate * priv;
};

struct _IBusEmojierLoadProgressObjectClass {
	GObjectClass parent_class;
};

static gint IBusEmojier_private_offset;
static gpointer ibus_emojier_parent_class = NULL;
static gchar* ibus_emojier_m_current_lang_id;
static gchar* ibus_emojier_m_current_lang_id = NULL;
static gchar* ibus_emojier_m_emoji_font_family;
static gchar* ibus_emojier_m_emoji_font_family = NULL;
static gint ibus_emojier_m_emoji_font_size;
static gint ibus_emojier_m_emoji_font_size = 0;
static gboolean ibus_emojier_m_emoji_font_changed;
static gboolean ibus_emojier_m_emoji_font_changed = FALSE;
static gchar** ibus_emojier_m_favorites;
static gint ibus_emojier_m_favorites_length1;
static gchar** ibus_emojier_m_favorites = NULL;
static gint ibus_emojier_m_favorites_length1 = 0;
static gint _ibus_emojier_m_favorites_size_ = 0;
static gchar** ibus_emojier_m_favorite_annotations;
static gint ibus_emojier_m_favorite_annotations_length1;
static gchar** ibus_emojier_m_favorite_annotations = NULL;
static gint ibus_emojier_m_favorite_annotations_length1 = 0;
static gint _ibus_emojier_m_favorite_annotations_size_ = 0;
static gint ibus_emojier_m_emoji_max_seq_len;
static gint ibus_emojier_m_emoji_max_seq_len = 0;
static gboolean ibus_emojier_m_has_partial_match;
static gboolean ibus_emojier_m_has_partial_match = FALSE;
static guint ibus_emojier_m_partial_match_length;
static guint ibus_emojier_m_partial_match_length = 0U;
static guint ibus_emojier_m_partial_match_condition;
static guint ibus_emojier_m_partial_match_condition = 0U;
static gboolean ibus_emojier_m_show_emoji_variant;
static gboolean ibus_emojier_m_show_emoji_variant = FALSE;
static gint ibus_emojier_m_default_window_width;
static gint ibus_emojier_m_default_window_width = 0;
static gint ibus_emojier_m_default_window_height;
static gint ibus_emojier_m_default_window_height = 0;
static GHashTable* ibus_emojier_m_annotation_to_emojis_dict;
static GHashTable* ibus_emojier_m_annotation_to_emojis_dict = NULL;
static GHashTable* ibus_emojier_m_emoji_to_data_dict;
static GHashTable* ibus_emojier_m_emoji_to_data_dict = NULL;
static GHashTable* ibus_emojier_m_category_to_emojis_dict;
static GHashTable* ibus_emojier_m_category_to_emojis_dict = NULL;
static GHashTable* ibus_emojier_m_emoji_to_emoji_variants_dict;
static GHashTable* ibus_emojier_m_emoji_to_emoji_variants_dict = NULL;
static GHashTable* ibus_emojier_m_unicode_to_data_dict;
static GHashTable* ibus_emojier_m_unicode_to_data_dict = NULL;
static GHashTable* ibus_emojier_m_name_to_unicodes_dict;
static GHashTable* ibus_emojier_m_name_to_unicodes_dict = NULL;
static GSList* ibus_emojier_m_unicode_block_list;
static GSList* ibus_emojier_m_unicode_block_list = NULL;
static gboolean ibus_emojier_m_show_unicode;
static gboolean ibus_emojier_m_show_unicode = FALSE;
static IBusEmojierLoadProgressObject* ibus_emojier_m_unicode_progress_object;
static IBusEmojierLoadProgressObject* ibus_emojier_m_unicode_progress_object = NULL;
static gboolean ibus_emojier_m_loaded_unicode;
static gboolean ibus_emojier_m_loaded_unicode = FALSE;
static gchar* ibus_emojier_m_warning_message;
static gchar* ibus_emojier_m_warning_message = NULL;
extern gdouble ibus_emojier_m_mouse_x;
gdouble ibus_emojier_m_mouse_x = 0.0;
extern gdouble ibus_emojier_m_mouse_y;
gdouble ibus_emojier_m_mouse_y = 0.0;
static gpointer ibus_emojier_elist_box_parent_class = NULL;
static gint IBusEmojierEBoxRow_private_offset;
static gpointer ibus_emojier_ebox_row_parent_class = NULL;
static gpointer ibus_emojier_escrolled_window_parent_class = NULL;
static gpointer ibus_emojier_egrid_parent_class = NULL;
static gint IBusEmojierEWhiteLabel_private_offset;
static gpointer ibus_emojier_ewhite_label_parent_class = NULL;
static gpointer ibus_emojier_eselected_label_parent_class = NULL;
static gpointer ibus_emojier_egold_label_parent_class = NULL;
static gpointer ibus_emojier_epadded_label_parent_class = NULL;
static gpointer ibus_emojier_epadded_label_box_parent_class = NULL;
static gpointer ibus_emojier_load_progress_object_parent_class = NULL;

GType ibus_emojier_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojier, g_object_unref)
gpointer themed_rgba_ref (gpointer instance);
void themed_rgba_unref (gpointer instance);
GParamSpec* param_spec_themed_rgba (const gchar* name,
                                    const gchar* nick,
                                    const gchar* blurb,
                                    GType object_type,
                                    GParamFlags flags);
void value_set_themed_rgba (GValue* value,
                            gpointer v_object);
void value_take_themed_rgba (GValue* value,
                             gpointer v_object);
gpointer value_get_themed_rgba (const GValue* value);
GType themed_rgba_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ThemedRGBA, themed_rgba_unref)
static GType ibus_emojier_escrolled_window_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierEScrolledWindow, g_object_unref)
static GType ibus_emojier_elist_box_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierEListBox, g_object_unref)
static GType ibus_emojier_travel_direction_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
#define IBUS_EMOJIER_BUTTON_CLOSE_BUTTON ((guint) 1000)
#define IBUS_EMOJIER_EMOJI_GRID_PAGE ((guint) 10)
#define IBUS_EMOJIER_EMOJI_CATEGORY_FAVORITES N_ ("Favorites")
#define IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS N_ ("Others")
#define IBUS_EMOJIER_EMOJI_CATEGORY_UNICODE N_ ("Open Unicode choice")
static GType ibus_emojier_load_progress_object_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierLoadProgressObject, g_object_unref)
IBusEmojier* ibus_emojier_new (void);
IBusEmojier* ibus_emojier_construct (GType object_type);
static void ibus_emojier_check_action_variant_cb (IBusEmojier* self,
                                           GSimpleAction* action,
                                           GVariant* parameter);
static void _ibus_emojier_check_action_variant_cb_g_simple_action_activate (GSimpleAction* _sender,
                                                                     GVariant* parameter,
                                                                     gpointer self);
static void ibus_emojier_action_close_cb (IBusEmojier* self,
                                   GSimpleAction* action,
                                   GVariant* parameter);
static void _ibus_emojier_action_close_cb_g_simple_action_activate (GSimpleAction* _sender,
                                                             GVariant* parameter,
                                                             gpointer self);
static void ibus_emojier_set_css_data (IBusEmojier* self);
static void __lambda12_ (IBusEmojier* self);
static void ___lambda12__gtk_widget_hide (GtkWidget* _sender,
                                   gpointer self);
static void __lambda13_ (IBusEmojier* self,
                  GtkWidget* w,
                  GtkAllocation* a);
static void ibus_emojier_adjust_window_position (IBusEmojier* self);
static void ___lambda13__gtk_widget_size_allocate (GtkWidget* _sender,
                                            GtkAllocation* allocation,
                                            gpointer self);
static void ibus_emojier_reload_emoji_dict (void);
static GObject* ibus_emojier_get_load_progress_object (void);
static void ibus_emojier_init_emoji_dict (void);
static void ibus_emojier_make_emoji_dict (const gchar* lang);
static void ibus_emojier_add_variants_to_component (void);
void ibus_emojier_update_favorite_emoji_dict (void);
static void _g_free0_ (gpointer var);
static inline void _g_slist_free__g_free0_ (GSList* self);
static void __g_slist_free__g_free0_0_ (gpointer var);
static void _g_object_unref0_ (gpointer var);
static void _g_slist_free0_ (gpointer var);
static inline void _g_slist_free__g_object_unref0_ (GSList* self);
static void ibus_emojier_update_emoji_to_data_dict (IBusEmojiData* data,
                                             const gchar* lang);
static void ibus_emojier_update_annotation_to_emojis_dict (IBusEmojiData* data);
static void ibus_emojier_update_category_to_emojis_dict (IBusEmojiData* data,
                                                  const gchar* lang);
static gpointer _g_strdup_gcopy_func (gconstpointer src,
                               gpointer self);
static gchar* ibus_emojier_utf8_code_point (const gchar* str);
static gchar* ibus_emojier_utf8_entity (const gchar* str);
static void ibus_emojier_update_annotations_with_description (IBusEmojiData* data,
                                                       const gchar* description);
static void ibus_emojier_make_unicode_block_dict (void);
static void ibus_emojier_make_unicode_name_dict (GObject* source_object);
static void ibus_emojier_make_unicode_name_dict_finish (GSList* unicode_list);
static void ibus_emojier_update_unicode_to_data_dict (IBusUnicodeData* data);
static void ibus_emojier_update_name_to_unicodes_dict (IBusUnicodeData* data);
ThemedRGBA* themed_rgba_new (GtkWidget* widget);
ThemedRGBA* themed_rgba_construct (GType object_type,
                                   GtkWidget* widget);
GdkRGBA* themed_rgba_get_normal_bg (ThemedRGBA* self);
GdkRGBA* themed_rgba_get_selected_fg (ThemedRGBA* self);
GdkRGBA* themed_rgba_get_selected_bg (ThemedRGBA* self);
static void ibus_emojier_set_fixed_size (IBusEmojier* self);
static void ibus_emojier_remove_all_children (IBusEmojier* self);
static void ibus_emojier_clamp_page (IBusEmojier* self);
static void ibus_emojier_show_category_list (IBusEmojier* self);
static IBusEmojierEScrolledWindow* ibus_emojier_escrolled_window_new (GtkAdjustment* hadjustment,
                                                               GtkAdjustment* vadjustment);
static IBusEmojierEScrolledWindow* ibus_emojier_escrolled_window_construct (GType object_type,
                                                                     GtkAdjustment* hadjustment,
                                                                     GtkAdjustment* vadjustment);
static IBusEmojierEListBox* ibus_emojier_elist_box_new (void);
static IBusEmojierEListBox* ibus_emojier_elist_box_construct (GType object_type);
static void __lambda28_ (IBusEmojier* self,
                  GtkListBox* box,
                  GtkListBoxRow* gtkrow);
static GType ibus_emojier_ebox_row_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierEBoxRow, g_object_unref)
static void ibus_emojier_show_emoji_for_category (IBusEmojier* self,
                                           const gchar* category);
static const gchar* ibus_emojier_ebox_row_get_text (IBusEmojierEBoxRow* self);
static void ___lambda28__gtk_list_box_row_activated (GtkListBox* _sender,
                                              GtkListBoxRow* row,
                                              gpointer self);
static IBusEmojierEBoxRow* ibus_emojier_ebox_row_new (const gchar* text);
static IBusEmojierEBoxRow* ibus_emojier_ebox_row_construct (GType object_type,
                                                     const gchar* text);
static GType ibus_emojier_epadded_label_box_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierEPaddedLabelBox, g_object_unref)
static IBusEmojierEPaddedLabelBox* ibus_emojier_epadded_label_box_new (const gchar* text,
                                                                GtkAlign align,
                                                                IBusEmojierTravelDirection direction,
                                                                const gchar* caption);
static IBusEmojierEPaddedLabelBox* ibus_emojier_epadded_label_box_construct (GType object_type,
                                                                      const gchar* text,
                                                                      GtkAlign align,
                                                                      IBusEmojierTravelDirection direction,
                                                                      const gchar* caption);
static void ibus_emojier_update_unicode_blocks (IBusEmojier* self);
static void ibus_emojier_show_emoji_variants (IBusEmojier* self,
                                       GSList* emojis);
static void ibus_emojier_show_unicode_blocks (IBusEmojier* self);
static gboolean __lambda25_ (IBusEmojier* self,
                      GtkWidget* w,
                      GdkEventButton* e);
static void ibus_emojier_hide_candidate_panel (IBusEmojier* self);
static gboolean ___lambda25__gtk_widget_button_press_event (GtkWidget* _sender,
                                                     GdkEventButton* event,
                                                     gpointer self);
static void __lambda26_ (IBusEmojier* self,
                  GtkListBox* box,
                  GtkListBoxRow* gtkrow);
static void ibus_emojier_show_unicode_for_block (IBusEmojier* self,
                                          const gchar* block_name);
static void ibus_emojier_show_candidate_panel (IBusEmojier* self);
static void ___lambda26__gtk_list_box_row_activated (GtkListBox* _sender,
                                              GtkListBoxRow* row,
                                              gpointer self);
static void __lambda27_ (IBusEmojier* self,
                  GtkWidget* w,
                  GtkAllocation* a);
static void ___lambda27__gtk_widget_size_allocate (GtkWidget* _sender,
                                            GtkAllocation* allocation,
                                            gpointer self);
static void ibus_emojier_show_arrow_buttons (IBusEmojier* self);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static void __lambda20_ (IBusEmojier* self);
static void ___lambda20__gtk_button_clicked (GtkButton* _sender,
                                      gpointer self);
static void __lambda21_ (IBusEmojier* self);
static void ___lambda21__gtk_button_clicked (GtkButton* _sender,
                                      gpointer self);
IBusText* ibus_emojier_get_title_text (IBusEmojier* self);
PangoAttrList* get_pango_attr_list_from_ibus_text (IBusText* text);
static void ___lambda22_ (Block4Data* _data4_);
static void ____lambda22__gtk_button_clicked (GtkButton* _sender,
                                       gpointer self);
static void ibus_emojier_show_unicode_progress_bar (IBusEmojier* self);
static void __lambda23_ (IBusEmojier* self,
                  guint i,
                  guint n);
static void ___lambda23__ibus_emojier_load_progress_object_deserialize_unicode (IBusEmojierLoadProgressObject* _sender,
                                                                         guint done,
                                                                         guint total,
                                                                         gpointer self);
static gboolean __lambda24_ (IBusEmojier* self);
static gboolean ___lambda24__gsource_func (gpointer self);
static gchar* ibus_emojier_check_unicode_point (const gchar* annotation);
static GSList* ibus_emojier_lookup_emojis_from_annotation (const gchar* annotation);
static void ibus_emojier_update_candidate_window (IBusEmojier* self);
static void ibus_emojier_update_category_list (IBusEmojier* self);
static void ibus_emojier_reset_window_mode (IBusEmojier* self);
static gint __lambda16_ (const gchar* a,
                  const gchar* b);
static gint ___lambda16__gcompare_func (gconstpointer a,
                                 gconstpointer b);
static void ibus_emojier_show_code_point_description (IBusEmojier* self,
                                               const gchar* text);
static gboolean ___lambda15_ (IBusEmojier* self,
                       GtkWidget* w,
                       GdkEventButton* e);
static gboolean ____lambda15__gtk_widget_button_press_event (GtkWidget* _sender,
                                                      GdkEventButton* event,
                                                      gpointer self);
static GType ibus_emojier_egrid_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierEGrid, g_object_unref)
static IBusEmojierEGrid* ibus_emojier_egrid_new (void);
static IBusEmojierEGrid* ibus_emojier_egrid_construct (GType object_type);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
static IBusEmojierESelectedLabel* ibus_emojier_eselected_label_new (const gchar* text);
static IBusEmojierESelectedLabel* ibus_emojier_eselected_label_construct (GType object_type,
                                                                   const gchar* text);
static GType ibus_emojier_ewhite_label_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierEWhiteLabel, g_object_unref)
static GType ibus_emojier_eselected_label_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierESelectedLabel, g_object_unref)
static IBusEmojierEGoldLabel* ibus_emojier_egold_label_new (const gchar* text);
static IBusEmojierEGoldLabel* ibus_emojier_egold_label_construct (GType object_type,
                                                           const gchar* text);
static GType ibus_emojier_egold_label_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierEGoldLabel, g_object_unref)
static IBusEmojierEWhiteLabel* ibus_emojier_ewhite_label_new (const gchar* text);
static IBusEmojierEWhiteLabel* ibus_emojier_ewhite_label_construct (GType object_type,
                                                             const gchar* text);
static gboolean _____lambda17_ (Block5Data* _data5_,
                         GtkWidget* w,
                         GdkEventButton* e);
static gboolean ______lambda17__gtk_widget_button_press_event (GtkWidget* _sender,
                                                        GdkEventButton* event,
                                                        gpointer self);
static gboolean _____lambda18_ (Block5Data* _data5_,
                         GdkEventMotion* e);
static GdkEventMotion* _vala_GdkEventMotion_copy (GdkEventMotion* self);
static void _vala_GdkEventMotion_free (GdkEventMotion* self);
static gboolean __lambda19_ (IBusEmojier* self);
static gboolean ___lambda19__gsource_func (gpointer self);
static gboolean ______lambda18__gtk_widget_motion_notify_event (GtkWidget* _sender,
                                                         GdkEventMotion* event,
                                                         gpointer self);
static void _vala_array_add8 (GtkLabel** * array,
                       gint* length,
                       gint* size,
                       GtkLabel* value);
static void ibus_emojier_show_description (IBusEmojier* self);
static void ibus_emojier_show_emoji_description (IBusEmojier* self,
                                          IBusEmojiData* data,
                                          const gchar* text);
static void ibus_emojier_show_unicode_description (IBusEmojier* self,
                                            IBusUnicodeData* data,
                                            const gchar* text);
static void ibus_emojier_enter_notify_disable_with_timer (IBusEmojier* self);
static gboolean __lambda29_ (IBusEmojier* self);
static gboolean ___lambda29__gsource_func (gpointer self);
static void ibus_emojier_candidate_panel_cursor_down (IBusEmojier* self);
static void ibus_emojier_candidate_panel_cursor_up (IBusEmojier* self);
static gint ibus_emojier_get_page_num (IBusEmojier* self);
static gboolean ibus_emojier_category_list_cursor_move (IBusEmojier* self,
                                                 guint keyval);
gboolean ibus_emojier_has_variants (IBusEmojier* self,
                                    guint index,
                                    gboolean need_commit_signal);
gboolean ibus_emojier_key_press_cursor_horizontal (IBusEmojier* self,
                                                   guint keyval,
                                                   guint modifiers);
gboolean ibus_emojier_key_press_cursor_vertical (IBusEmojier* self,
                                                 guint keyval,
                                                 guint modifiers);
gboolean ibus_emojier_key_press_cursor_home_end (IBusEmojier* self,
                                                 guint keyval,
                                                 guint modifiers);
gboolean ibus_emojier_key_press_escape (IBusEmojier* self);
gboolean ibus_emojier_key_press_enter (IBusEmojier* self,
                                       gboolean need_commit_signal);
static void ibus_emojier_get_monitor_geometry (IBusEmojier* self,
                                        GdkRectangle* result);
static gboolean ___lambda14_ (IBusEmojier* self);
static gboolean ____lambda14__gsource_func (gpointer self);
void ibus_emojier_set_annotation (IBusEmojier* self,
                                  const gchar* annotation);
IBusLookupTable* ibus_emojier_get_one_dimension_lookup_table (IBusEmojier* self);
guint ibus_emojier_get_number_of_candidates (IBusEmojier* self);
guint ibus_emojier_get_cursor_pos (IBusEmojier* self);
void ibus_emojier_set_cursor_pos (IBusEmojier* self,
                                  guint cursor_pos);
gchar* ibus_emojier_get_current_candidate (IBusEmojier* self);
static void ibus_emojier_real_show_all (GtkWidget* base);
static void ibus_emojier_real_hide (GtkWidget* base);
static gboolean ibus_emojier_real_key_press_event (GtkWidget* base,
                                            GdkEventKey* event);
gboolean ibus_emojier_is_running (IBusEmojier* self);
gchar* ibus_emojier_get_input_context_path (IBusEmojier* self);
void ibus_emojier_set_input_context_path (IBusEmojier* self,
                                          const gchar* input_context_path);
gchar* ibus_emojier_get_selected_string (IBusEmojier* self);
void ibus_emojier_reset (IBusEmojier* self);
void ibus_emojier_present_centralize (IBusEmojier* self,
                                      GdkEvent* event);
void ibus_emojier_set_cursor_location (IBusEmojier* self,
                                       gint x,
                                       gint y,
                                       gint width,
                                       gint height);
static gboolean _cairo_rectangle_int_equal (const cairo_rectangle_int_t * s1,
                                     const cairo_rectangle_int_t * s2);
gboolean ibus_emojier_is_candidate_panel_mode (IBusEmojier* self);
gboolean ibus_emojier_has_loaded_emoji_dict (void);
void ibus_emojier_set_annotation_lang (const gchar* lang);
gchar* ibus_emojier_get_annotation_lang (void);
void ibus_emojier_set_emoji_font (const gchar* emoji_font);
static void _vala_PangoFontDescription_free (PangoFontDescription* self);
void ibus_emojier_set_partial_match (gboolean has_partial_match);
void ibus_emojier_set_partial_match_length (gint length);
void ibus_emojier_set_partial_match_condition (gint condition);
void ibus_emojier_set_favorites (gchar** unowned_favorites,
                                 gint unowned_favorites_length1,
                                 gchar** unowned_favorite_annotations,
                                 gint unowned_favorite_annotations_length1);
static void _vala_array_add9 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static void _vala_array_add10 (gchar** * array,
                        gint* length,
                        gint* size,
                        gchar* value);
static IBusEmojierLoadProgressObject* ibus_emojier_load_progress_object_new (void);
static IBusEmojierLoadProgressObject* ibus_emojier_load_progress_object_construct (GType object_type);
void ibus_emojier_load_unicode_dict (void);
static void g_cclosure_user_marshal_VOID__UINT_UINT_UINT (GClosure * closure,
                                                   GValue * return_value,
                                                   guint n_param_values,
                                                   const GValue * param_values,
                                                   gpointer invocation_hint,
                                                   gpointer marshal_data);
static gboolean __lambda10_ (IBusEmojierEListBox* self,
                      GdkEventMotion* e);
static gboolean ___lambda10__gtk_widget_motion_notify_event (GtkWidget* _sender,
                                                      GdkEventMotion* event,
                                                      gpointer self);
static gboolean __lambda11_ (IBusEmojierEListBox* self,
                      GdkEventCrossing* e);
static gboolean ___lambda11__gtk_widget_enter_notify_event (GtkWidget* _sender,
                                                     GdkEventCrossing* event,
                                                     gpointer self);
static GType ibus_emojier_elist_box_get_type_once (void);
static void ibus_emojier_ebox_row_set_text (IBusEmojierEBoxRow* self,
                                     const gchar* value);
static void ibus_emojier_ebox_row_finalize (GObject * obj);
static GType ibus_emojier_ebox_row_get_type_once (void);
static void _vala_ibus_emojier_ebox_row_get_property (GObject * object,
                                               guint property_id,
                                               GValue * value,
                                               GParamSpec * pspec);
static void _vala_ibus_emojier_ebox_row_set_property (GObject * object,
                                               guint property_id,
                                               const GValue * value,
                                               GParamSpec * pspec);
static GType ibus_emojier_escrolled_window_get_type_once (void);
static GType ibus_emojier_egrid_get_type_once (void);
static void ibus_emojier_ewhite_label_real_get_preferred_width (GtkWidget* base,
                                                         gint* minimum_width,
                                                         gint* natural_width);
static void ibus_emojier_ewhite_label_real_get_preferred_height (GtkWidget* base,
                                                          gint* minimum_height,
                                                          gint* natural_height);
static void ibus_emojier_ewhite_label_finalize (GObject * obj);
static GType ibus_emojier_ewhite_label_get_type_once (void);
static GType ibus_emojier_eselected_label_get_type_once (void);
static GType ibus_emojier_egold_label_get_type_once (void);
static GType ibus_emojier_epadded_label_get_type (void) G_GNUC_CONST  G_GNUC_UNUSED ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IBusEmojierEPaddedLabel, g_object_unref)
static IBusEmojierEPaddedLabel* ibus_emojier_epadded_label_new (const gchar* text,
                                                         GtkAlign align);
static IBusEmojierEPaddedLabel* ibus_emojier_epadded_label_construct (GType object_type,
                                                               const gchar* text,
                                                               GtkAlign align);
static GType ibus_emojier_epadded_label_get_type_once (void);
GType icon_widget_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (IconWidget, g_object_unref)
IconWidget* icon_widget_new (const gchar* icon_name_or_path,
                             GtkIconSize size);
IconWidget* icon_widget_construct (GType object_type,
                                   const gchar* icon_name_or_path,
                                   GtkIconSize size);
static GType ibus_emojier_epadded_label_box_get_type_once (void);
static void g_cclosure_user_marshal_VOID__UINT_UINT (GClosure * closure,
                                              GValue * return_value,
                                              guint n_param_values,
                                              const GValue * param_values,
                                              gpointer invocation_hint,
                                              gpointer marshal_data);
static GType ibus_emojier_load_progress_object_get_type_once (void);
static void ibus_emojier_finalize (GObject * obj);
static GType ibus_emojier_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const gunichar IBUS_EMOJIER_EMOJI_VARIANT_LIST[6] = {(gunichar) 0x1f3fb, (gunichar) 0x1f3fc, (gunichar) 0x1f3fd, (gunichar) 0x1f3fe, (gunichar) 0x1f3ff, (gunichar) 0x200d};

static inline gpointer
ibus_emojier_get_instance_private (IBusEmojier* self)
{
	return G_STRUCT_MEMBER_P (self, IBusEmojier_private_offset);
}

static GType
ibus_emojier_travel_direction_get_type_once (void)
{
	static const GEnumValue values[] = {{IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, "IBUS_EMOJIER_TRAVEL_DIRECTION_NONE", "none"}, {IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD, "IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD", "backward"}, {0, NULL, NULL}};
	GType ibus_emojier_travel_direction_type_id;
	ibus_emojier_travel_direction_type_id = g_enum_register_static ("IBusEmojierTravelDirection", values);
	return ibus_emojier_travel_direction_type_id;
}

static GType
ibus_emojier_travel_direction_get_type (void)
{
	static volatile gsize ibus_emojier_travel_direction_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_travel_direction_type_id__volatile)) {
		GType ibus_emojier_travel_direction_type_id;
		ibus_emojier_travel_direction_type_id = ibus_emojier_travel_direction_get_type_once ();
		g_once_init_leave (&ibus_emojier_travel_direction_type_id__volatile, ibus_emojier_travel_direction_type_id);
	}
	return ibus_emojier_travel_direction_type_id__volatile;
}

static void
_ibus_emojier_check_action_variant_cb_g_simple_action_activate (GSimpleAction* _sender,
                                                                GVariant* parameter,
                                                                gpointer self)
{
	ibus_emojier_check_action_variant_cb ((IBusEmojier*) self, _sender, parameter);
}

static void
_ibus_emojier_action_close_cb_g_simple_action_activate (GSimpleAction* _sender,
                                                        GVariant* parameter,
                                                        gpointer self)
{
	ibus_emojier_action_close_cb ((IBusEmojier*) self, _sender, parameter);
}

static void
__lambda12_ (IBusEmojier* self)
{
	gboolean _tmp0_ = FALSE;
	GMainLoop* _tmp1_;
	_tmp1_ = self->priv->m_loop;
	if (_tmp1_ != NULL) {
		GMainLoop* _tmp2_;
		_tmp2_ = self->priv->m_loop;
		_tmp0_ = g_main_loop_is_running (_tmp2_);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GMainLoop* _tmp3_;
		_tmp3_ = self->priv->m_loop;
		g_main_loop_quit (_tmp3_);
	}
}

static void
___lambda12__gtk_widget_hide (GtkWidget* _sender,
                              gpointer self)
{
	__lambda12_ ((IBusEmojier*) self);
}

static void
__lambda13_ (IBusEmojier* self,
             GtkWidget* w,
             GtkAllocation* a)
{
	g_return_if_fail (w != NULL);
	g_return_if_fail (a != NULL);
	ibus_emojier_adjust_window_position (self);
}

static void
___lambda13__gtk_widget_size_allocate (GtkWidget* _sender,
                                       GtkAllocation* allocation,
                                       gpointer self)
{
	__lambda13_ ((IBusEmojier*) self, _sender, allocation);
}

IBusEmojier*
ibus_emojier_construct (GType object_type)
{
	IBusEmojier * self = NULL;
	GSimpleAction* action = NULL;
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	GSimpleAction* _tmp2_;
	GSimpleAction* _tmp3_;
	GSimpleAction* _tmp4_;
	GSimpleAction* _tmp5_;
	GSimpleAction* _tmp6_;
	GSimpleAction* _tmp7_;
	GSimpleAction* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp11_;
	gchar** _tmp13_;
	gint _tmp13__length1;
	gchar** _tmp15_;
	gint _tmp15__length1;
	GtkBox* _tmp17_;
	GtkBox* _tmp18_;
	IBusLookupTable* _tmp19_;
	IBusLookupTable* _tmp20_;
	GHashTable* _tmp21_;
	GObject* _tmp22_;
	GObject* _tmp23_;
	self = (IBusEmojier*) g_object_new (object_type, "type", GTK_WINDOW_POPUP, NULL);
	_tmp0_ = g_variant_new_boolean (ibus_emojier_m_show_emoji_variant);
	g_variant_ref_sink (_tmp0_);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_simple_action_new_stateful ("variant", NULL, _tmp1_);
	_tmp3_ = _tmp2_;
	_g_variant_unref0 (_tmp1_);
	action = _tmp3_;
	_tmp4_ = action;
	g_signal_connect_object (_tmp4_, "activate", (GCallback) _ibus_emojier_check_action_variant_cb_g_simple_action_activate, self, 0);
	_tmp5_ = action;
	g_action_map_add_action ((GActionMap*) self, (GAction*) _tmp5_);
	_tmp6_ = g_simple_action_new ("close", NULL);
	_g_object_unref0 (action);
	action = _tmp6_;
	_tmp7_ = action;
	g_signal_connect_object (_tmp7_, "activate", (GCallback) _ibus_emojier_action_close_cb_g_simple_action_activate, self, 0);
	_tmp8_ = action;
	g_action_map_add_action ((GActionMap*) self, (GAction*) _tmp8_);
	_tmp9_ = ibus_emojier_m_current_lang_id;
	if (_tmp9_ == NULL) {
		gchar* _tmp10_;
		_tmp10_ = g_strdup ("en");
		_g_free0 (ibus_emojier_m_current_lang_id);
		ibus_emojier_m_current_lang_id = _tmp10_;
	}
	_tmp11_ = ibus_emojier_m_emoji_font_family;
	if (_tmp11_ == NULL) {
		gchar* _tmp12_;
		_tmp12_ = g_strdup ("Monospace");
		_g_free0 (ibus_emojier_m_emoji_font_family);
		ibus_emojier_m_emoji_font_family = _tmp12_;
		ibus_emojier_m_emoji_font_changed = TRUE;
	}
	if (ibus_emojier_m_emoji_font_size == 0) {
		ibus_emojier_m_emoji_font_size = 16;
		ibus_emojier_m_emoji_font_changed = TRUE;
	}
	_tmp13_ = ibus_emojier_m_favorites;
	_tmp13__length1 = ibus_emojier_m_favorites_length1;
	if (_tmp13_ == NULL) {
		gchar** _tmp14_;
		_tmp14_ = g_new0 (gchar*, 0 + 1);
		ibus_emojier_m_favorites = (_vala_array_free (ibus_emojier_m_favorites, ibus_emojier_m_favorites_length1, (GDestroyNotify) g_free), NULL);
		ibus_emojier_m_favorites = _tmp14_;
		ibus_emojier_m_favorites_length1 = 0;
		_ibus_emojier_m_favorites_size_ = ibus_emojier_m_favorites_length1;
	}
	_tmp15_ = ibus_emojier_m_favorite_annotations;
	_tmp15__length1 = ibus_emojier_m_favorite_annotations_length1;
	if (_tmp15_ == NULL) {
		gchar** _tmp16_;
		_tmp16_ = g_new0 (gchar*, 0 + 1);
		ibus_emojier_m_favorite_annotations = (_vala_array_free (ibus_emojier_m_favorite_annotations, ibus_emojier_m_favorite_annotations_length1, (GDestroyNotify) g_free), NULL);
		ibus_emojier_m_favorite_annotations = _tmp16_;
		ibus_emojier_m_favorite_annotations_length1 = 0;
		_ibus_emojier_m_favorite_annotations_size_ = ibus_emojier_m_favorite_annotations_length1;
	}
	ibus_emojier_set_css_data (self);
	_tmp17_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp17_);
	_g_object_unref0 (self->priv->m_vbox);
	self->priv->m_vbox = _tmp17_;
	_tmp18_ = self->priv->m_vbox;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp18_);
	_tmp19_ = ibus_lookup_table_new ((guint) 1, (guint) 0, TRUE, TRUE);
	g_object_ref_sink (_tmp19_);
	_g_object_unref0 (self->priv->m_lookup_table);
	self->priv->m_lookup_table = _tmp19_;
	_tmp20_ = self->priv->m_lookup_table;
	ibus_lookup_table_set_page_size (_tmp20_, IBUS_EMOJIER_EMOJI_GRID_PAGE * IBUS_EMOJIER_EMOJI_GRID_PAGE);
	g_signal_connect_object ((GtkWidget*) self, "hide", (GCallback) ___lambda12__gtk_widget_hide, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "size-allocate", (GCallback) ___lambda13__gtk_widget_size_allocate, self, 0);
	_tmp21_ = ibus_emojier_m_annotation_to_emojis_dict;
	if (_tmp21_ == NULL) {
		ibus_emojier_reload_emoji_dict ();
	}
	_tmp22_ = ibus_emojier_get_load_progress_object ();
	_tmp23_ = _tmp22_;
	_g_object_unref0 (_tmp23_);
	_g_object_unref0 (action);
	return self;
}

IBusEmojier*
ibus_emojier_new (void)
{
	return ibus_emojier_construct (TYPE_IBUS_EMOJIER);
}

static void
ibus_emojier_reload_emoji_dict (void)
{
	const gchar* _tmp0_;
	GList* annotations = NULL;
	GHashTable* _tmp10_;
	GList* _tmp11_;
	GList* _tmp12_;
	ibus_emojier_init_emoji_dict ();
	ibus_emojier_make_emoji_dict ("en");
	_tmp0_ = ibus_emojier_m_current_lang_id;
	if (g_strcmp0 (_tmp0_, "en") != 0) {
		gchar** lang_ids = NULL;
		const gchar* _tmp1_;
		gchar** _tmp2_;
		gchar** _tmp3_;
		gint lang_ids_length1;
		gint _lang_ids_size_;
		gchar** _tmp4_;
		gint _tmp4__length1;
		const gchar* _tmp9_;
		_tmp1_ = ibus_emojier_m_current_lang_id;
		_tmp3_ = _tmp2_ = g_strsplit (_tmp1_, "_", 0);
		lang_ids = _tmp3_;
		lang_ids_length1 = _vala_array_length (_tmp2_);
		_lang_ids_size_ = lang_ids_length1;
		_tmp4_ = lang_ids;
		_tmp4__length1 = lang_ids_length1;
		if (_tmp4__length1 > 1) {
			gchar* sub_id = NULL;
			gchar** _tmp5_;
			gint _tmp5__length1;
			const gchar* _tmp6_;
			gchar* _tmp7_;
			const gchar* _tmp8_;
			_tmp5_ = lang_ids;
			_tmp5__length1 = lang_ids_length1;
			_tmp6_ = _tmp5_[0];
			_tmp7_ = g_strdup (_tmp6_);
			sub_id = _tmp7_;
			_tmp8_ = sub_id;
			ibus_emojier_make_emoji_dict (_tmp8_);
			_g_free0 (sub_id);
		}
		_tmp9_ = ibus_emojier_m_current_lang_id;
		ibus_emojier_make_emoji_dict (_tmp9_);
		lang_ids = (_vala_array_free (lang_ids, lang_ids_length1, (GDestroyNotify) g_free), NULL);
	}
	ibus_emojier_add_variants_to_component ();
	_tmp10_ = ibus_emojier_m_annotation_to_emojis_dict;
	_tmp11_ = g_hash_table_get_keys (_tmp10_);
	annotations = _tmp11_;
	_tmp12_ = annotations;
	{
		GList* annotation_collection = NULL;
		GList* annotation_it = NULL;
		annotation_collection = _tmp12_;
		for (annotation_it = annotation_collection; annotation_it != NULL; annotation_it = annotation_it->next) {
			const gchar* annotation = NULL;
			annotation = (const gchar*) annotation_it->data;
			{
				const gchar* _tmp13_;
				gint _tmp14_;
				gint _tmp15_;
				_tmp13_ = annotation;
				_tmp14_ = strlen (_tmp13_);
				_tmp15_ = _tmp14_;
				if (ibus_emojier_m_emoji_max_seq_len < _tmp15_) {
					const gchar* _tmp16_;
					gint _tmp17_;
					gint _tmp18_;
					_tmp16_ = annotation;
					_tmp17_ = strlen (_tmp16_);
					_tmp18_ = _tmp17_;
					ibus_emojier_m_emoji_max_seq_len = _tmp18_;
				}
			}
		}
	}
	ibus_emojier_update_favorite_emoji_dict ();
	(annotations == NULL) ? NULL : (annotations = (g_list_free (annotations), NULL));
}

static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}

static inline void
_g_slist_free__g_free0_ (GSList* self)
{
	g_slist_free_full (self, (GDestroyNotify) _g_free0_);
}

static void
__g_slist_free__g_free0_0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (_g_slist_free__g_free0_ (var), NULL));
}

static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}

static void
_g_slist_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_slist_free (var), NULL));
}

static void
ibus_emojier_init_emoji_dict (void)
{
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashFunc _tmp3_;
	GEqualFunc _tmp4_;
	GHashTable* _tmp5_;
	GHashFunc _tmp6_;
	GEqualFunc _tmp7_;
	GHashTable* _tmp8_;
	GHashFunc _tmp9_;
	GEqualFunc _tmp10_;
	GHashTable* _tmp11_;
	GHashTable* _tmp12_;
	GHashTable* _tmp16_;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, __g_slist_free__g_free0_0_);
	_g_hash_table_unref0 (ibus_emojier_m_annotation_to_emojis_dict);
	ibus_emojier_m_annotation_to_emojis_dict = _tmp2_;
	_tmp3_ = g_str_hash;
	_tmp4_ = g_str_equal;
	_tmp5_ = g_hash_table_new_full (_tmp3_, _tmp4_, _g_free0_, _g_object_unref0_);
	_g_hash_table_unref0 (ibus_emojier_m_emoji_to_data_dict);
	ibus_emojier_m_emoji_to_data_dict = _tmp5_;
	_tmp6_ = g_str_hash;
	_tmp7_ = g_str_equal;
	_tmp8_ = g_hash_table_new_full (_tmp6_, _tmp7_, _g_free0_, __g_slist_free__g_free0_0_);
	_g_hash_table_unref0 (ibus_emojier_m_category_to_emojis_dict);
	ibus_emojier_m_category_to_emojis_dict = _tmp8_;
	_tmp9_ = g_str_hash;
	_tmp10_ = g_str_equal;
	_tmp11_ = g_hash_table_new_full (_tmp9_, _tmp10_, _g_free0_, __g_slist_free__g_free0_0_);
	_g_hash_table_unref0 (ibus_emojier_m_emoji_to_emoji_variants_dict);
	ibus_emojier_m_emoji_to_emoji_variants_dict = _tmp11_;
	_tmp12_ = ibus_emojier_m_unicode_to_data_dict;
	if (_tmp12_ == NULL) {
		GHashFunc _tmp13_;
		GEqualFunc _tmp14_;
		GHashTable* _tmp15_;
		_tmp13_ = g_direct_hash;
		_tmp14_ = g_direct_equal;
		_tmp15_ = g_hash_table_new_full (_tmp13_, _tmp14_, NULL, _g_object_unref0_);
		_g_hash_table_unref0 (ibus_emojier_m_unicode_to_data_dict);
		ibus_emojier_m_unicode_to_data_dict = _tmp15_;
	}
	_tmp16_ = ibus_emojier_m_name_to_unicodes_dict;
	if (_tmp16_ == NULL) {
		GHashFunc _tmp17_;
		GEqualFunc _tmp18_;
		GHashTable* _tmp19_;
		_tmp17_ = g_str_hash;
		_tmp18_ = g_str_equal;
		_tmp19_ = g_hash_table_new_full (_tmp17_, _tmp18_, _g_free0_, _g_slist_free0_);
		_g_hash_table_unref0 (ibus_emojier_m_name_to_unicodes_dict);
		ibus_emojier_m_name_to_unicodes_dict = _tmp19_;
	}
}

static inline void
_g_slist_free__g_object_unref0_ (GSList* self)
{
	g_slist_free_full (self, (GDestroyNotify) _g_object_unref0_);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
ibus_emojier_make_emoji_dict (const gchar* lang)
{
	GSList* emoji_list = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	GSList* _tmp4_;
	GSList* _tmp5_;
	GSList* _tmp6_;
	GSList* _tmp7_;
	g_return_if_fail (lang != NULL);
	_tmp0_ = g_strconcat (PKGDATADIR "/dicts/emoji-", lang, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strconcat (_tmp1_, ".dict", NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = ibus_emoji_data_load (_tmp3_);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	_g_free0 (_tmp1_);
	emoji_list = _tmp5_;
	_tmp6_ = emoji_list;
	if (_tmp6_ == NULL) {
		(emoji_list == NULL) ? NULL : (emoji_list = (_g_slist_free__g_object_unref0_ (emoji_list), NULL));
		return;
	}
	_tmp7_ = emoji_list;
	{
		GSList* data_collection = NULL;
		GSList* data_it = NULL;
		data_collection = _tmp7_;
		for (data_it = data_collection; data_it != NULL; data_it = data_it->next) {
			IBusEmojiData* _tmp8_;
			IBusEmojiData* data = NULL;
			_tmp8_ = _g_object_ref0 ((IBusEmojiData*) data_it->data);
			data = _tmp8_;
			{
				IBusEmojiData* _tmp9_;
				IBusEmojiData* _tmp10_;
				IBusEmojiData* _tmp11_;
				_tmp9_ = data;
				ibus_emojier_update_emoji_to_data_dict (_tmp9_, lang);
				_tmp10_ = data;
				ibus_emojier_update_annotation_to_emojis_dict (_tmp10_);
				_tmp11_ = data;
				ibus_emojier_update_category_to_emojis_dict (_tmp11_, lang);
				_g_object_unref0 (data);
			}
		}
	}
	(emoji_list == NULL) ? NULL : (emoji_list = (_g_slist_free__g_object_unref0_ (emoji_list), NULL));
}

static void
ibus_emojier_add_variants_to_component (void)
{
	gchar* category = NULL;
	gchar* _tmp0_;
	GSList* hits = NULL;
	GHashTable* _tmp1_;
	const gchar* _tmp2_;
	gconstpointer _tmp3_;
	GSList* _tmp4_;
	GSList* _tmp9_;
	GSList* emoji_list = NULL;
	GSList* annotations = NULL;
	gchar* _tmp10_;
	IBusEmojiData* _data = NULL;
	GSList* _tmp11_;
	const gchar* _tmp12_;
	IBusEmojiData* _tmp13_;
	IBusEmojiData* _tmp14_;
	IBusEmojiData* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	GSList* _tmp19_;
	const gchar* _tmp20_;
	IBusEmojiData* _tmp21_;
	IBusEmojiData* _tmp22_;
	IBusEmojiData* _tmp23_;
	gchar* _tmp24_;
	gchar* _tmp25_;
	gchar* _tmp26_;
	GSList* _tmp27_;
	const gchar* _tmp28_;
	IBusEmojiData* _tmp29_;
	IBusEmojiData* _tmp30_;
	IBusEmojiData* _tmp31_;
	GSList* _tmp32_;
	_tmp0_ = g_strdup ("Component");
	category = _tmp0_;
	_tmp1_ = ibus_emojier_m_category_to_emojis_dict;
	_tmp2_ = category;
	_tmp3_ = g_hash_table_lookup (_tmp1_, _tmp2_);
	hits = (GSList*) _tmp3_;
	_tmp4_ = hits;
	if (_tmp4_ == NULL) {
		gchar* _tmp5_;
		GHashTable* _tmp6_;
		const gchar* _tmp7_;
		gconstpointer _tmp8_;
		_tmp5_ = g_strdup ("component");
		_g_free0 (category);
		category = _tmp5_;
		_tmp6_ = ibus_emojier_m_category_to_emojis_dict;
		_tmp7_ = category;
		_tmp8_ = g_hash_table_lookup (_tmp6_, _tmp7_);
		hits = (GSList*) _tmp8_;
	}
	_tmp9_ = hits;
	if (_tmp9_ == NULL) {
		_g_free0 (category);
		return;
	}
	emoji_list = NULL;
	annotations = NULL;
	_tmp10_ = g_strdup ("zero");
	annotations = g_slist_append (annotations, _tmp10_);
	_tmp11_ = annotations;
	_tmp12_ = category;
	_tmp13_ = ibus_emoji_data_new ("emoji", "\u200d", "annotations", _tmp11_, "description", "ZERO WIDTH JOINER", "category", _tmp12_, NULL);
	g_object_ref_sink (_tmp13_);
	_g_object_unref0 (_data);
	_data = _tmp13_;
	_tmp14_ = _data;
	_tmp15_ = _g_object_ref0 (_tmp14_);
	emoji_list = g_slist_append (emoji_list, _tmp15_);
	(annotations == NULL) ? NULL : (annotations = (_g_slist_free__g_free0_ (annotations), NULL));
	annotations = NULL;
	_tmp16_ = g_strdup ("text");
	annotations = g_slist_append (annotations, _tmp16_);
	_tmp17_ = g_strdup ("variation");
	annotations = g_slist_append (annotations, _tmp17_);
	_tmp18_ = g_strdup ("selector");
	annotations = g_slist_append (annotations, _tmp18_);
	_tmp19_ = annotations;
	_tmp20_ = category;
	_tmp21_ = ibus_emoji_data_new ("emoji", "\ufe0e", "annotations", _tmp19_, "description", "VARIATION SELECTOR-15", "category", _tmp20_, NULL);
	g_object_ref_sink (_tmp21_);
	_g_object_unref0 (_data);
	_data = _tmp21_;
	_tmp22_ = _data;
	_tmp23_ = _g_object_ref0 (_tmp22_);
	emoji_list = g_slist_append (emoji_list, _tmp23_);
	(annotations == NULL) ? NULL : (annotations = (_g_slist_free__g_free0_ (annotations), NULL));
	annotations = NULL;
	_tmp24_ = g_strdup ("emoji");
	annotations = g_slist_append (annotations, _tmp24_);
	_tmp25_ = g_strdup ("variation");
	annotations = g_slist_append (annotations, _tmp25_);
	_tmp26_ = g_strdup ("selector");
	annotations = g_slist_append (annotations, _tmp26_);
	_tmp27_ = annotations;
	_tmp28_ = category;
	_tmp29_ = ibus_emoji_data_new ("emoji", "\ufe0f", "annotations", _tmp27_, "description", "VARIATION SELECTOR-16", "category", _tmp28_, NULL);
	g_object_ref_sink (_tmp29_);
	_g_object_unref0 (_data);
	_data = _tmp29_;
	_tmp30_ = _data;
	_tmp31_ = _g_object_ref0 (_tmp30_);
	emoji_list = g_slist_append (emoji_list, _tmp31_);
	_tmp32_ = emoji_list;
	{
		GSList* data_collection = NULL;
		GSList* data_it = NULL;
		data_collection = _tmp32_;
		for (data_it = data_collection; data_it != NULL; data_it = data_it->next) {
			IBusEmojiData* _tmp33_;
			IBusEmojiData* data = NULL;
			_tmp33_ = _g_object_ref0 ((IBusEmojiData*) data_it->data);
			data = _tmp33_;
			{
				IBusEmojiData* _tmp34_;
				IBusEmojiData* _tmp35_;
				IBusEmojiData* _tmp36_;
				_tmp34_ = data;
				ibus_emojier_update_emoji_to_data_dict (_tmp34_, "en");
				_tmp35_ = data;
				ibus_emojier_update_annotation_to_emojis_dict (_tmp35_);
				_tmp36_ = data;
				ibus_emojier_update_category_to_emojis_dict (_tmp36_, "en");
				_g_object_unref0 (data);
			}
		}
	}
	_g_object_unref0 (_data);
	(annotations == NULL) ? NULL : (annotations = (_g_slist_free__g_free0_ (annotations), NULL));
	(emoji_list == NULL) ? NULL : (emoji_list = (_g_slist_free__g_object_unref0_ (emoji_list), NULL));
	_g_free0 (category);
}

static gpointer
_g_strdup_gcopy_func (gconstpointer src,
                      gpointer self)
{
	gpointer result;
	result = g_strdup ((const gchar*) src);
	return result;
}

static void
ibus_emojier_update_annotation_to_emojis_dict (IBusEmojiData* data)
{
	gchar* emoji = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GSList* annotations = NULL;
	GSList* _tmp2_;
	GSList* _tmp3_;
	g_return_if_fail (data != NULL);
	_tmp0_ = ibus_emoji_data_get_emoji (data);
	_tmp1_ = g_strdup (_tmp0_);
	emoji = _tmp1_;
	_tmp2_ = ibus_emoji_data_get_annotations (data);
	annotations = _tmp2_;
	_tmp3_ = annotations;
	{
		GSList* annotation_collection = NULL;
		GSList* annotation_it = NULL;
		annotation_collection = _tmp3_;
		for (annotation_it = annotation_collection; annotation_it != NULL; annotation_it = annotation_it->next) {
			gchar* _tmp4_;
			gchar* annotation = NULL;
			_tmp4_ = g_strdup ((const gchar*) annotation_it->data);
			annotation = _tmp4_;
			{
				gboolean has_emoji = FALSE;
				GSList* hits = NULL;
				GHashTable* _tmp5_;
				const gchar* _tmp6_;
				gconstpointer _tmp7_;
				GSList* _tmp8_;
				GSList* _tmp9_;
				has_emoji = FALSE;
				_tmp5_ = ibus_emojier_m_annotation_to_emojis_dict;
				_tmp6_ = annotation;
				_tmp7_ = g_hash_table_lookup (_tmp5_, _tmp6_);
				_tmp8_ = g_slist_copy_deep ((GSList*) _tmp7_, _g_strdup_gcopy_func, NULL);
				hits = _tmp8_;
				_tmp9_ = hits;
				{
					GSList* hit_emoji_collection = NULL;
					GSList* hit_emoji_it = NULL;
					hit_emoji_collection = _tmp9_;
					for (hit_emoji_it = hit_emoji_collection; hit_emoji_it != NULL; hit_emoji_it = hit_emoji_it->next) {
						gchar* _tmp10_;
						gchar* hit_emoji = NULL;
						_tmp10_ = g_strdup ((const gchar*) hit_emoji_it->data);
						hit_emoji = _tmp10_;
						{
							const gchar* _tmp11_;
							const gchar* _tmp12_;
							_tmp11_ = hit_emoji;
							_tmp12_ = emoji;
							if (g_strcmp0 (_tmp11_, _tmp12_) == 0) {
								has_emoji = TRUE;
								_g_free0 (hit_emoji);
								break;
							}
							_g_free0 (hit_emoji);
						}
					}
				}
				if (!has_emoji) {
					const gchar* _tmp13_;
					gchar* _tmp14_;
					GHashTable* _tmp15_;
					const gchar* _tmp16_;
					gchar* _tmp17_;
					GSList* _tmp18_;
					GSList* _tmp19_;
					_tmp13_ = emoji;
					_tmp14_ = g_strdup (_tmp13_);
					hits = g_slist_append (hits, _tmp14_);
					_tmp15_ = ibus_emojier_m_annotation_to_emojis_dict;
					_tmp16_ = annotation;
					_tmp17_ = g_strdup (_tmp16_);
					_tmp18_ = hits;
					_tmp19_ = g_slist_copy_deep (_tmp18_, _g_strdup_gcopy_func, NULL);
					g_hash_table_replace (_tmp15_, _tmp17_, _tmp19_);
				}
				(hits == NULL) ? NULL : (hits = (_g_slist_free__g_free0_ (hits), NULL));
				_g_free0 (annotation);
			}
		}
	}
	_g_free0 (emoji);
}

static gunichar
string_get_char (const gchar* self,
                 glong index)
{
	gunichar result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	result = g_utf8_get_char (((gchar*) self) + index);
	return result;
}

static gchar*
ibus_emojier_utf8_code_point (const gchar* str)
{
	GString* buff = NULL;
	GString* _tmp0_;
	gint length = 0;
	GString* _tmp16_;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* result = NULL;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = g_string_new ("");
	buff = _tmp0_;
	length = g_utf8_strlen (str, (gssize) -1);
	if (length == 0) {
		GString* _tmp1_;
		gchar* _tmp2_;
		gchar* _tmp3_;
		GString* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp1_ = buff;
		_tmp2_ = g_strdup_printf ("U+%04X", (guint) 0);
		_tmp3_ = _tmp2_;
		g_string_append (_tmp1_, _tmp3_);
		_g_free0 (_tmp3_);
		_tmp4_ = buff;
		_tmp5_ = _tmp4_->str;
		_tmp6_ = g_strdup (_tmp5_);
		result = _tmp6_;
		_g_string_free0 (buff);
		return result;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp7_ = FALSE;
			_tmp7_ = TRUE;
			while (TRUE) {
				gunichar ch = 0U;
				const gchar* _tmp15_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp7_ = FALSE;
				if (!(i < length)) {
					break;
				}
				ch = string_get_char (str, (glong) 0);
				if (i == 0) {
					GString* _tmp9_;
					gchar* _tmp10_;
					gchar* _tmp11_;
					_tmp9_ = buff;
					_tmp10_ = g_strdup_printf ("U+%04X", (guint) ch);
					_tmp11_ = _tmp10_;
					g_string_append (_tmp9_, _tmp11_);
					_g_free0 (_tmp11_);
				} else {
					GString* _tmp12_;
					gchar* _tmp13_;
					gchar* _tmp14_;
					_tmp12_ = buff;
					_tmp13_ = g_strdup_printf (" %04X", (guint) ch);
					_tmp14_ = _tmp13_;
					g_string_append (_tmp12_, _tmp14_);
					_g_free0 (_tmp14_);
				}
				_tmp15_ = g_utf8_next_char (str);
				str = _tmp15_;
			}
		}
	}
	_tmp16_ = buff;
	_tmp17_ = _tmp16_->str;
	_tmp18_ = g_strdup (_tmp17_);
	result = _tmp18_;
	_g_string_free0 (buff);
	return result;
}

static gchar*
ibus_emojier_utf8_entity (const gchar* str)
{
	GString* buff = NULL;
	GString* _tmp0_;
	gint length = 0;
	GString* _tmp8_;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* result = NULL;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = g_string_new ("");
	buff = _tmp0_;
	length = g_utf8_strlen (str, (gssize) -1);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gunichar ch = 0U;
				const gchar* _tmp7_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				if (!(i < length)) {
					break;
				}
				ch = string_get_char (str, (glong) 0);
				switch (ch) {
					case '<':
					{
						GString* _tmp3_;
						_tmp3_ = buff;
						g_string_append (_tmp3_, "&lt;");
						break;
					}
					case '>':
					{
						GString* _tmp4_;
						_tmp4_ = buff;
						g_string_append (_tmp4_, "&gt;");
						break;
					}
					case '&':
					{
						GString* _tmp5_;
						_tmp5_ = buff;
						g_string_append (_tmp5_, "&amp;");
						break;
					}
					default:
					{
						GString* _tmp6_;
						_tmp6_ = buff;
						g_string_append_unichar (_tmp6_, ch);
						break;
					}
				}
				_tmp7_ = g_utf8_next_char (str);
				str = _tmp7_;
			}
		}
	}
	_tmp8_ = buff;
	_tmp9_ = _tmp8_->str;
	_tmp10_ = g_strdup (_tmp9_);
	result = _tmp10_;
	_g_string_free0 (buff);
	return result;
}

static gint
string_index_of (const gchar* self,
                 const gchar* needle,
                 gint start_index)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = strstr (((gchar*) self) + start_index, (gchar*) needle);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_;
		_tmp2_ = _result_;
		result = (gint) (_tmp2_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}

static glong
string_strnlen (gchar* str,
                glong maxlen)
{
	gchar* end = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	glong result = 0L;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	_tmp1_ = end;
	if (_tmp1_ == NULL) {
		result = maxlen;
		return result;
	} else {
		gchar* _tmp2_;
		_tmp2_ = end;
		result = (glong) (_tmp2_ - str);
		return result;
	}
}

static gchar*
string_substring (const gchar* self,
                  glong offset,
                  glong len)
{
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp3_;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= ((glong) 0)) {
		_tmp0_ = len >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		string_length = string_strnlen ((gchar*) self, offset + len);
	} else {
		gint _tmp1_;
		gint _tmp2_;
		_tmp1_ = strlen (self);
		_tmp2_ = _tmp1_;
		string_length = (glong) _tmp2_;
	}
	if (offset < ((glong) 0)) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= ((glong) 0), NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < ((glong) 0)) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp3_;
	return result;
}

static void
ibus_emojier_update_annotations_with_description (IBusEmojiData* data,
                                                  const gchar* description)
{
	GSList* annotations = NULL;
	GSList* _tmp0_;
	GSList* _tmp1_;
	gboolean update_annotations = FALSE;
	gchar* former = NULL;
	gchar* later = NULL;
	gint index = 0;
	gchar** words = NULL;
	const gchar* _tmp11_;
	gchar** _tmp12_;
	gchar** _tmp13_;
	gint words_length1;
	gint _words_size_;
	gboolean _tmp14_ = FALSE;
	gchar** _tmp15_;
	gint _tmp15__length1;
	g_return_if_fail (data != NULL);
	g_return_if_fail (description != NULL);
	_tmp0_ = ibus_emoji_data_get_annotations (data);
	_tmp1_ = g_slist_copy_deep (_tmp0_, _g_strdup_gcopy_func, NULL);
	annotations = _tmp1_;
	update_annotations = FALSE;
	former = NULL;
	later = NULL;
	index = string_index_of (description, ": ", 0);
	if (index > 0) {
		gchar* _tmp2_;
		GSList* _tmp3_;
		const gchar* _tmp4_;
		GCompareFunc _tmp5_;
		GSList* _tmp6_;
		gchar* _tmp9_;
		_tmp2_ = string_substring (description, (glong) 0, (glong) index);
		_g_free0 (former);
		former = _tmp2_;
		_tmp3_ = annotations;
		_tmp4_ = former;
		_tmp5_ = ((GCompareFunc) g_strcmp0);
		_tmp6_ = g_slist_find_custom (_tmp3_, _tmp4_, _tmp5_);
		if (_tmp6_ == NULL) {
			const gchar* _tmp7_;
			gchar* _tmp8_;
			_tmp7_ = former;
			_tmp8_ = g_strdup (_tmp7_);
			annotations = g_slist_append (annotations, _tmp8_);
			update_annotations = TRUE;
		}
		_tmp9_ = string_substring (description, (glong) (index + 2), (glong) -1);
		_g_free0 (later);
		later = _tmp9_;
	} else {
		gchar* _tmp10_;
		_tmp10_ = g_strdup (description);
		_g_free0 (later);
		later = _tmp10_;
	}
	_tmp11_ = later;
	_tmp13_ = _tmp12_ = g_strsplit (_tmp11_, " ", 0);
	words = _tmp13_;
	words_length1 = _vala_array_length (_tmp12_);
	_words_size_ = words_length1;
	_tmp15_ = words;
	_tmp15__length1 = words_length1;
	if (_tmp15__length1 < 3) {
		GSList* _tmp16_;
		const gchar* _tmp17_;
		GCompareFunc _tmp18_;
		GSList* _tmp19_;
		_tmp16_ = annotations;
		_tmp17_ = later;
		_tmp18_ = ((GCompareFunc) g_strcmp0);
		_tmp19_ = g_slist_find_custom (_tmp16_, _tmp17_, _tmp18_);
		_tmp14_ = _tmp19_ == NULL;
	} else {
		_tmp14_ = FALSE;
	}
	if (_tmp14_) {
		const gchar* _tmp20_;
		gchar* _tmp21_;
		_tmp20_ = later;
		_tmp21_ = g_strdup (_tmp20_);
		annotations = g_slist_append (annotations, _tmp21_);
		update_annotations = TRUE;
	}
	if (update_annotations) {
		GSList* _tmp22_;
		GSList* _tmp23_;
		_tmp22_ = annotations;
		_tmp23_ = g_slist_copy_deep (_tmp22_, _g_strdup_gcopy_func, NULL);
		ibus_emoji_data_set_annotations (data, _tmp23_);
	}
	words = (_vala_array_free (words, words_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (later);
	_g_free0 (former);
	(annotations == NULL) ? NULL : (annotations = (_g_slist_free__g_free0_ (annotations), NULL));
}

static void
ibus_emojier_update_emoji_to_data_dict (IBusEmojiData* data,
                                        const gchar* lang)
{
	gchar* emoji = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (data != NULL);
	g_return_if_fail (lang != NULL);
	_tmp0_ = ibus_emoji_data_get_emoji (data);
	_tmp1_ = g_strdup (_tmp0_);
	emoji = _tmp1_;
	if (g_strcmp0 (lang, "en") == 0) {
		gchar* description = NULL;
		const gchar* _tmp2_;
		gchar* _tmp3_;
		const gchar* _tmp4_;
		GHashTable* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_;
		IBusEmojiData* _tmp8_;
		_tmp2_ = ibus_emoji_data_get_description (data);
		_tmp3_ = g_utf8_strdown (_tmp2_, (gssize) -1);
		description = _tmp3_;
		_tmp4_ = description;
		ibus_emojier_update_annotations_with_description (data, _tmp4_);
		_tmp5_ = ibus_emojier_m_emoji_to_data_dict;
		_tmp6_ = emoji;
		_tmp7_ = g_strdup (_tmp6_);
		_tmp8_ = _g_object_ref0 (data);
		g_hash_table_replace (_tmp5_, _tmp7_, _tmp8_);
		_g_free0 (description);
	} else {
		IBusEmojiData* en_data = NULL;
		GHashTable* _tmp9_;
		const gchar* _tmp10_;
		gconstpointer _tmp11_;
		IBusEmojiData* _tmp12_;
		gchar* trans_description = NULL;
		const gchar* _tmp17_;
		gchar* _tmp18_;
		IBusEmojiData* _tmp19_;
		const gchar* _tmp20_;
		const gchar* _tmp21_;
		gchar* _tmp22_;
		const gchar* _tmp23_;
		GSList* annotations = NULL;
		GSList* _tmp24_;
		GSList* en_annotations = NULL;
		IBusEmojiData* _tmp25_;
		GSList* _tmp26_;
		GSList* _tmp27_;
		IBusEmojiData* _tmp35_;
		GSList* _tmp36_;
		GSList* _tmp37_;
		en_data = NULL;
		_tmp9_ = ibus_emojier_m_emoji_to_data_dict;
		_tmp10_ = emoji;
		_tmp11_ = g_hash_table_lookup (_tmp9_, _tmp10_);
		en_data = (IBusEmojiData*) _tmp11_;
		_tmp12_ = en_data;
		if (_tmp12_ == NULL) {
			GHashTable* _tmp13_;
			const gchar* _tmp14_;
			gchar* _tmp15_;
			IBusEmojiData* _tmp16_;
			_tmp13_ = ibus_emojier_m_emoji_to_data_dict;
			_tmp14_ = emoji;
			_tmp15_ = g_strdup (_tmp14_);
			_tmp16_ = _g_object_ref0 (data);
			g_hash_table_insert (_tmp13_, _tmp15_, _tmp16_);
			_g_free0 (emoji);
			return;
		}
		_tmp17_ = ibus_emoji_data_get_description (data);
		_tmp18_ = g_strdup (_tmp17_);
		trans_description = _tmp18_;
		_tmp19_ = en_data;
		_tmp20_ = trans_description;
		ibus_emoji_data_set_description (_tmp19_, _tmp20_);
		_tmp21_ = trans_description;
		_tmp22_ = g_utf8_strdown (_tmp21_, (gssize) -1);
		_g_free0 (trans_description);
		trans_description = _tmp22_;
		_tmp23_ = trans_description;
		ibus_emojier_update_annotations_with_description (data, _tmp23_);
		_tmp24_ = ibus_emoji_data_get_annotations (data);
		annotations = _tmp24_;
		_tmp25_ = en_data;
		_tmp26_ = ibus_emoji_data_get_annotations (_tmp25_);
		en_annotations = _tmp26_;
		_tmp27_ = en_annotations;
		{
			GSList* annotation_collection = NULL;
			GSList* annotation_it = NULL;
			annotation_collection = _tmp27_;
			for (annotation_it = annotation_collection; annotation_it != NULL; annotation_it = annotation_it->next) {
				gchar* _tmp28_;
				gchar* annotation = NULL;
				_tmp28_ = g_strdup ((const gchar*) annotation_it->data);
				annotation = _tmp28_;
				{
					GSList* _tmp29_;
					const gchar* _tmp30_;
					GCompareFunc _tmp31_;
					GSList* _tmp32_;
					_tmp29_ = annotations;
					_tmp30_ = annotation;
					_tmp31_ = ((GCompareFunc) g_strcmp0);
					_tmp32_ = g_slist_find_custom (_tmp29_, _tmp30_, _tmp31_);
					if (_tmp32_ == NULL) {
						const gchar* _tmp33_;
						gchar* _tmp34_;
						_tmp33_ = annotation;
						_tmp34_ = g_strdup (_tmp33_);
						annotations = g_slist_append (annotations, _tmp34_);
					}
					_g_free0 (annotation);
				}
			}
		}
		_tmp35_ = en_data;
		_tmp36_ = annotations;
		_tmp37_ = g_slist_copy_deep (_tmp36_, _g_strdup_gcopy_func, NULL);
		ibus_emoji_data_set_annotations (_tmp35_, _tmp37_);
		_g_free0 (trans_description);
	}
	_g_free0 (emoji);
}

static gint
string_index_of_char (const gchar* self,
                      gunichar c,
                      gint start_index)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_utf8_strchr (((gchar*) self) + start_index, (gssize) -1, c);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_;
		_tmp2_ = _result_;
		result = (gint) (_tmp2_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}

static gchar*
g_unichar_to_string (gunichar self)
{
	gchar* str = NULL;
	gchar* _tmp0_;
	gchar* result = NULL;
	_tmp0_ = g_new0 (gchar, 7);
	str = (gchar*) _tmp0_;
	g_unichar_to_utf8 (self, str);
	result = str;
	return result;
}

static void
ibus_emojier_update_category_to_emojis_dict (IBusEmojiData* data,
                                             const gchar* lang)
{
	gchar* emoji = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* category = NULL;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	g_return_if_fail (data != NULL);
	g_return_if_fail (lang != NULL);
	_tmp0_ = ibus_emoji_data_get_emoji (data);
	_tmp1_ = g_strdup (_tmp0_);
	emoji = _tmp1_;
	_tmp2_ = ibus_emoji_data_get_category (data);
	_tmp3_ = g_strdup (_tmp2_);
	category = _tmp3_;
	_tmp4_ = category;
	if (g_strcmp0 (_tmp4_, "") == 0) {
		gchar* _tmp5_;
		_tmp5_ = g_strdup (IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS);
		_g_free0 (category);
		category = _tmp5_;
	}
	if (g_strcmp0 (lang, "en") == 0) {
		gboolean has_variant = FALSE;
		const gchar* _tmp6_;
		gboolean has_emoji = FALSE;
		GSList* hits = NULL;
		GHashTable* _tmp40_;
		const gchar* _tmp41_;
		gconstpointer _tmp42_;
		GSList* _tmp43_;
		GSList* _tmp44_;
		has_variant = FALSE;
		_tmp6_ = category;
		if (g_ascii_strcasecmp (_tmp6_, "component") != 0) {
			{
				gunichar* ch_collection = NULL;
				gint ch_collection_length1 = 0;
				gint _ch_collection_size_ = 0;
				gint ch_it = 0;
				ch_collection = IBUS_EMOJIER_EMOJI_VARIANT_LIST;
				ch_collection_length1 = G_N_ELEMENTS (IBUS_EMOJIER_EMOJI_VARIANT_LIST);
				for (ch_it = 0; ch_it < ch_collection_length1; ch_it = ch_it + 1) {
					gunichar ch = 0U;
					ch = ch_collection[ch_it];
					{
						const gchar* _tmp7_;
						_tmp7_ = emoji;
						if (string_index_of_char (_tmp7_, ch, 0) >= 0) {
							has_variant = TRUE;
							break;
						}
					}
				}
			}
		}
		if (has_variant) {
			gunichar base_ch = 0U;
			const gchar* _tmp8_;
			gchar* base_emoji = NULL;
			gchar* _tmp9_;
			GString* buff = NULL;
			GString* _tmp10_;
			GString* _tmp11_;
			GString* _tmp12_;
			GHashTable* _tmp13_;
			GString* _tmp14_;
			const gchar* _tmp15_;
			gconstpointer _tmp16_;
			GSList* variants = NULL;
			GHashTable* _tmp20_;
			const gchar* _tmp21_;
			gconstpointer _tmp22_;
			GSList* _tmp23_;
			GSList* _tmp24_;
			const gchar* _tmp25_;
			GCompareFunc _tmp26_;
			GSList* _tmp27_;
			_tmp8_ = emoji;
			base_ch = string_get_char (_tmp8_, (glong) 0);
			_tmp9_ = g_unichar_to_string (base_ch);
			base_emoji = _tmp9_;
			_tmp10_ = g_string_new ("");
			buff = _tmp10_;
			_tmp11_ = buff;
			g_string_append_unichar (_tmp11_, base_ch);
			_tmp12_ = buff;
			g_string_append_unichar (_tmp12_, (gunichar) 0xfe0f);
			_tmp13_ = ibus_emojier_m_emoji_to_data_dict;
			_tmp14_ = buff;
			_tmp15_ = _tmp14_->str;
			_tmp16_ = g_hash_table_lookup (_tmp13_, _tmp15_);
			if (((IBusEmojiData*) _tmp16_) != NULL) {
				GString* _tmp17_;
				const gchar* _tmp18_;
				gchar* _tmp19_;
				_tmp17_ = buff;
				_tmp18_ = _tmp17_->str;
				_tmp19_ = g_strdup (_tmp18_);
				_g_free0 (base_emoji);
				base_emoji = _tmp19_;
			}
			_tmp20_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
			_tmp21_ = base_emoji;
			_tmp22_ = g_hash_table_lookup (_tmp20_, _tmp21_);
			_tmp23_ = g_slist_copy_deep ((GSList*) _tmp22_, _g_strdup_gcopy_func, NULL);
			variants = _tmp23_;
			_tmp24_ = variants;
			_tmp25_ = emoji;
			_tmp26_ = ((GCompareFunc) g_strcmp0);
			_tmp27_ = g_slist_find_custom (_tmp24_, _tmp25_, _tmp26_);
			if (_tmp27_ == NULL) {
				GSList* _tmp28_;
				const gchar* _tmp31_;
				const gchar* _tmp32_;
				GHashTable* _tmp35_;
				const gchar* _tmp36_;
				gchar* _tmp37_;
				GSList* _tmp38_;
				GSList* _tmp39_;
				_tmp28_ = variants;
				if (_tmp28_ == NULL) {
					const gchar* _tmp29_;
					gchar* _tmp30_;
					_tmp29_ = base_emoji;
					_tmp30_ = g_strdup (_tmp29_);
					variants = g_slist_append (variants, _tmp30_);
				}
				_tmp31_ = base_emoji;
				_tmp32_ = emoji;
				if (g_strcmp0 (_tmp31_, _tmp32_) != 0) {
					const gchar* _tmp33_;
					gchar* _tmp34_;
					_tmp33_ = emoji;
					_tmp34_ = g_strdup (_tmp33_);
					variants = g_slist_append (variants, _tmp34_);
				}
				_tmp35_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
				_tmp36_ = base_emoji;
				_tmp37_ = g_strdup (_tmp36_);
				_tmp38_ = variants;
				_tmp39_ = g_slist_copy_deep (_tmp38_, _g_strdup_gcopy_func, NULL);
				g_hash_table_replace (_tmp35_, _tmp37_, _tmp39_);
			}
			(variants == NULL) ? NULL : (variants = (_g_slist_free__g_free0_ (variants), NULL));
			_g_string_free0 (buff);
			_g_free0 (base_emoji);
			_g_free0 (category);
			_g_free0 (emoji);
			return;
		}
		has_emoji = FALSE;
		_tmp40_ = ibus_emojier_m_category_to_emojis_dict;
		_tmp41_ = category;
		_tmp42_ = g_hash_table_lookup (_tmp40_, _tmp41_);
		_tmp43_ = g_slist_copy_deep ((GSList*) _tmp42_, _g_strdup_gcopy_func, NULL);
		hits = _tmp43_;
		_tmp44_ = hits;
		{
			GSList* hit_emoji_collection = NULL;
			GSList* hit_emoji_it = NULL;
			hit_emoji_collection = _tmp44_;
			for (hit_emoji_it = hit_emoji_collection; hit_emoji_it != NULL; hit_emoji_it = hit_emoji_it->next) {
				gchar* _tmp45_;
				gchar* hit_emoji = NULL;
				_tmp45_ = g_strdup ((const gchar*) hit_emoji_it->data);
				hit_emoji = _tmp45_;
				{
					const gchar* _tmp46_;
					const gchar* _tmp47_;
					_tmp46_ = hit_emoji;
					_tmp47_ = emoji;
					if (g_strcmp0 (_tmp46_, _tmp47_) == 0) {
						has_emoji = TRUE;
						_g_free0 (hit_emoji);
						break;
					}
					_g_free0 (hit_emoji);
				}
			}
		}
		if (!has_emoji) {
			const gchar* _tmp48_;
			gchar* _tmp49_;
			GHashTable* _tmp50_;
			const gchar* _tmp51_;
			gchar* _tmp52_;
			GSList* _tmp53_;
			GSList* _tmp54_;
			_tmp48_ = emoji;
			_tmp49_ = g_strdup (_tmp48_);
			hits = g_slist_append (hits, _tmp49_);
			_tmp50_ = ibus_emojier_m_category_to_emojis_dict;
			_tmp51_ = category;
			_tmp52_ = g_strdup (_tmp51_);
			_tmp53_ = hits;
			_tmp54_ = g_slist_copy_deep (_tmp53_, _g_strdup_gcopy_func, NULL);
			g_hash_table_replace (_tmp50_, _tmp52_, _tmp54_);
		}
		(hits == NULL) ? NULL : (hits = (_g_slist_free__g_free0_ (hits), NULL));
	}
	_g_free0 (category);
	_g_free0 (emoji);
}

static void
ibus_emojier_make_unicode_block_dict (void)
{
	GSList* _tmp0_;
	GSList* _tmp1_;
	_tmp0_ = ibus_unicode_block_load (PKGDATADIR "/dicts/unicode-blocks.dict");
	(ibus_emojier_m_unicode_block_list == NULL) ? NULL : (ibus_emojier_m_unicode_block_list = (_g_slist_free__g_object_unref0_ (ibus_emojier_m_unicode_block_list), NULL));
	ibus_emojier_m_unicode_block_list = _tmp0_;
	_tmp1_ = ibus_emojier_m_unicode_block_list;
	{
		GSList* block_collection = NULL;
		GSList* block_it = NULL;
		block_collection = _tmp1_;
		for (block_it = block_collection; block_it != NULL; block_it = block_it->next) {
			IBusUnicodeBlock* block = NULL;
			block = (IBusUnicodeBlock*) block_it->data;
			{
				const gchar* name = NULL;
				IBusUnicodeBlock* _tmp2_;
				const gchar* _tmp3_;
				const gchar* _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				_tmp2_ = block;
				_tmp3_ = ibus_unicode_block_get_name (_tmp2_);
				name = _tmp3_;
				_tmp4_ = name;
				_tmp5_ = strlen (_tmp4_);
				_tmp6_ = _tmp5_;
				if (ibus_emojier_m_emoji_max_seq_len < _tmp6_) {
					const gchar* _tmp7_;
					gint _tmp8_;
					gint _tmp9_;
					_tmp7_ = name;
					_tmp8_ = strlen (_tmp7_);
					_tmp9_ = _tmp8_;
					ibus_emojier_m_emoji_max_seq_len = _tmp9_;
				}
			}
		}
	}
}

static void
ibus_emojier_make_unicode_name_dict (GObject* source_object)
{
	g_return_if_fail (source_object != NULL);
	ibus_unicode_data_load_async (PKGDATADIR "/dicts/unicode-names.dict", source_object, NULL, (IBusUnicodeDataLoadAsyncFinish) ibus_emojier_make_unicode_name_dict_finish, NULL);
}

static void
ibus_emojier_make_unicode_name_dict_finish (GSList* unicode_list)
{
	GList* names = NULL;
	GHashTable* _tmp3_;
	GList* _tmp4_;
	GList* _tmp5_;
	if (unicode_list == NULL) {
		return;
	}
	{
		GSList* data_collection = NULL;
		GSList* data_it = NULL;
		data_collection = unicode_list;
		for (data_it = data_collection; data_it != NULL; data_it = data_it->next) {
			IBusUnicodeData* _tmp0_;
			IBusUnicodeData* data = NULL;
			_tmp0_ = _g_object_ref0 ((IBusUnicodeData*) data_it->data);
			data = _tmp0_;
			{
				IBusUnicodeData* _tmp1_;
				IBusUnicodeData* _tmp2_;
				_tmp1_ = data;
				ibus_emojier_update_unicode_to_data_dict (_tmp1_);
				_tmp2_ = data;
				ibus_emojier_update_name_to_unicodes_dict (_tmp2_);
				_g_object_unref0 (data);
			}
		}
	}
	_tmp3_ = ibus_emojier_m_name_to_unicodes_dict;
	_tmp4_ = g_hash_table_get_keys (_tmp3_);
	names = _tmp4_;
	_tmp5_ = names;
	{
		GList* name_collection = NULL;
		GList* name_it = NULL;
		name_collection = _tmp5_;
		for (name_it = name_collection; name_it != NULL; name_it = name_it->next) {
			const gchar* name = NULL;
			name = (const gchar*) name_it->data;
			{
				const gchar* _tmp6_;
				gint _tmp7_;
				gint _tmp8_;
				_tmp6_ = name;
				_tmp7_ = strlen (_tmp6_);
				_tmp8_ = _tmp7_;
				if (ibus_emojier_m_emoji_max_seq_len < _tmp8_) {
					const gchar* _tmp9_;
					gint _tmp10_;
					gint _tmp11_;
					_tmp9_ = name;
					_tmp10_ = strlen (_tmp9_);
					_tmp11_ = _tmp10_;
					ibus_emojier_m_emoji_max_seq_len = _tmp11_;
				}
			}
		}
	}
	ibus_emojier_m_loaded_unicode = TRUE;
	(names == NULL) ? NULL : (names = (g_list_free (names), NULL));
}

static void
ibus_emojier_update_unicode_to_data_dict (IBusUnicodeData* data)
{
	gunichar code = 0U;
	GHashTable* _tmp0_;
	IBusUnicodeData* _tmp1_;
	g_return_if_fail (data != NULL);
	code = ibus_unicode_data_get_code (data);
	_tmp0_ = ibus_emojier_m_unicode_to_data_dict;
	_tmp1_ = _g_object_ref0 (data);
	g_hash_table_replace (_tmp0_, (gpointer) ((gintptr) code), _tmp1_);
}

static void
ibus_emojier_update_name_to_unicodes_dict (IBusUnicodeData* data)
{
	gunichar code = 0U;
	gchar** names = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar** _tmp4_;
	gint names_length1;
	gint _names_size_;
	gchar** _tmp5_;
	gint _tmp5__length1;
	g_return_if_fail (data != NULL);
	code = ibus_unicode_data_get_code (data);
	_tmp0_ = ibus_unicode_data_get_name (data);
	_tmp1_ = g_utf8_strdown (_tmp0_, (gssize) -1);
	_tmp2_ = ibus_unicode_data_get_alias (data);
	_tmp3_ = g_utf8_strdown (_tmp2_, (gssize) -1);
	_tmp4_ = g_new0 (gchar*, 2 + 1);
	_tmp4_[0] = _tmp1_;
	_tmp4_[1] = _tmp3_;
	names = _tmp4_;
	names_length1 = 2;
	_names_size_ = names_length1;
	_tmp5_ = names;
	_tmp5__length1 = names_length1;
	{
		gchar** name_collection = NULL;
		gint name_collection_length1 = 0;
		gint _name_collection_size_ = 0;
		gint name_it = 0;
		name_collection = _tmp5_;
		name_collection_length1 = _tmp5__length1;
		for (name_it = 0; name_it < name_collection_length1; name_it = name_it + 1) {
			const gchar* name = NULL;
			name = name_collection[name_it];
			{
				const gchar* _tmp6_;
				gboolean has_code = FALSE;
				GSList* hits = NULL;
				GHashTable* _tmp7_;
				const gchar* _tmp8_;
				gconstpointer _tmp9_;
				GSList* _tmp10_;
				GSList* _tmp11_;
				_tmp6_ = name;
				if (g_strcmp0 (_tmp6_, "") == 0) {
					continue;
				}
				has_code = FALSE;
				_tmp7_ = ibus_emojier_m_name_to_unicodes_dict;
				_tmp8_ = name;
				_tmp9_ = g_hash_table_lookup (_tmp7_, _tmp8_);
				_tmp10_ = g_slist_copy ((GSList*) _tmp9_);
				hits = _tmp10_;
				_tmp11_ = hits;
				{
					GSList* hit_code_collection = NULL;
					GSList* hit_code_it = NULL;
					hit_code_collection = _tmp11_;
					for (hit_code_it = hit_code_collection; hit_code_it != NULL; hit_code_it = hit_code_it->next) {
						gunichar hit_code = 0U;
						hit_code = (gunichar) ((gintptr) hit_code_it->data);
						{
							if (hit_code == code) {
								has_code = TRUE;
								break;
							}
						}
					}
				}
				if (!has_code) {
					GHashTable* _tmp12_;
					const gchar* _tmp13_;
					gchar* _tmp14_;
					GSList* _tmp15_;
					GSList* _tmp16_;
					hits = g_slist_append (hits, (gpointer) ((gintptr) code));
					_tmp12_ = ibus_emojier_m_name_to_unicodes_dict;
					_tmp13_ = name;
					_tmp14_ = g_strdup (_tmp13_);
					_tmp15_ = hits;
					_tmp16_ = g_slist_copy (_tmp15_);
					g_hash_table_replace (_tmp12_, _tmp14_, _tmp16_);
				}
				(hits == NULL) ? NULL : (hits = (g_slist_free (hits), NULL));
			}
		}
	}
	names = (_vala_array_free (names, names_length1, (GDestroyNotify) g_free), NULL);
}

static void
ibus_emojier_set_css_data (IBusEmojier* self)
{
	GdkDisplay* display = NULL;
	GdkDisplay* _tmp0_;
	GdkDisplay* _tmp1_;
	GdkScreen* _tmp2_ = NULL;
	GdkDisplay* _tmp3_;
	GdkScreen* screen = NULL;
	GdkScreen* _tmp6_;
	GdkScreen* _tmp7_;
	gchar* backup_locale = NULL;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	ThemedRGBA* _tmp13_;
	guint bg_red = 0U;
	ThemedRGBA* _tmp15_;
	GdkRGBA* _tmp16_;
	GdkRGBA* _tmp17_;
	guint bg_green = 0U;
	ThemedRGBA* _tmp18_;
	GdkRGBA* _tmp19_;
	GdkRGBA* _tmp20_;
	guint bg_blue = 0U;
	ThemedRGBA* _tmp21_;
	GdkRGBA* _tmp22_;
	GdkRGBA* _tmp23_;
	gdouble bg_alpha = 0.0;
	ThemedRGBA* _tmp24_;
	GdkRGBA* _tmp25_;
	GdkRGBA* _tmp26_;
	gchar* data = NULL;
	gchar* _tmp27_;
	gchar* _tmp28_;
	gchar* _tmp29_;
	gchar* _tmp30_;
	const gchar* _tmp31_;
	gchar* _tmp32_;
	gchar* _tmp33_;
	gchar* _tmp34_;
	gchar* _tmp35_;
	gchar* _tmp36_;
	gchar* _tmp37_;
	guint fg_red = 0U;
	ThemedRGBA* _tmp38_;
	GdkRGBA* _tmp39_;
	GdkRGBA* _tmp40_;
	guint fg_green = 0U;
	ThemedRGBA* _tmp41_;
	GdkRGBA* _tmp42_;
	GdkRGBA* _tmp43_;
	guint fg_blue = 0U;
	ThemedRGBA* _tmp44_;
	GdkRGBA* _tmp45_;
	GdkRGBA* _tmp46_;
	gdouble fg_alpha = 0.0;
	ThemedRGBA* _tmp47_;
	GdkRGBA* _tmp48_;
	GdkRGBA* _tmp49_;
	ThemedRGBA* _tmp50_;
	GdkRGBA* _tmp51_;
	GdkRGBA* _tmp52_;
	ThemedRGBA* _tmp53_;
	GdkRGBA* _tmp54_;
	GdkRGBA* _tmp55_;
	ThemedRGBA* _tmp56_;
	GdkRGBA* _tmp57_;
	GdkRGBA* _tmp58_;
	ThemedRGBA* _tmp59_;
	GdkRGBA* _tmp60_;
	GdkRGBA* _tmp61_;
	const gchar* _tmp62_;
	gchar* _tmp63_;
	gchar* _tmp64_;
	gchar* _tmp65_;
	gchar* _tmp66_;
	const gchar* _tmp67_;
	gchar* _tmp68_;
	gchar* _tmp69_;
	gchar* _tmp70_;
	gchar* _tmp71_;
	gchar* _tmp72_;
	gchar* _tmp73_;
	gchar* _tmp74_;
	gchar* _tmp75_;
	gchar* _tmp76_;
	gchar* _tmp77_;
	gchar* _tmp78_;
	gchar* _tmp79_;
	gchar* _tmp80_;
	const gchar* _tmp81_;
	gchar* _tmp82_;
	gchar* _tmp83_;
	gchar* _tmp84_;
	gchar* _tmp85_;
	const gchar* _tmp86_;
	gchar* _tmp87_;
	gchar* _tmp88_;
	gchar* _tmp89_;
	gchar* _tmp90_;
	gchar* _tmp91_;
	gchar* _tmp92_;
	gchar* _tmp93_;
	gchar* _tmp94_;
	gchar* _tmp95_;
	GtkCssProvider* css_provider = NULL;
	GtkCssProvider* _tmp96_;
	const gchar* _tmp101_;
	GdkScreen* _tmp103_;
	GtkCssProvider* _tmp104_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gdk_display_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	display = _tmp1_;
	_tmp3_ = display;
	if (_tmp3_ != NULL) {
		GdkDisplay* _tmp4_;
		GdkScreen* _tmp5_;
		_tmp4_ = display;
		_tmp5_ = gdk_display_get_default_screen (_tmp4_);
		_tmp2_ = _tmp5_;
	} else {
		_tmp2_ = NULL;
	}
	_tmp6_ = _g_object_ref0 (_tmp2_);
	screen = _tmp6_;
	_tmp7_ = screen;
	if (_tmp7_ == NULL) {
		g_warning ("emojier.vala:762: Could not open display.");
		_g_object_unref0 (screen);
		_g_object_unref0 (display);
		return;
	}
	_tmp8_ = setlocale (LC_NUMERIC, NULL);
	_tmp9_ = g_strdup (_tmp8_);
	backup_locale = _tmp9_;
	_tmp10_ = setlocale (LC_NUMERIC, "en_US.UTF-8");
	if (_tmp10_ == NULL) {
		const gchar* _tmp11_;
		_tmp11_ = setlocale (LC_NUMERIC, "C.UTF-8");
		if (_tmp11_ == NULL) {
			const gchar* _tmp12_;
			_tmp12_ = setlocale (LC_NUMERIC, "C");
			if (_tmp12_ == NULL) {
				g_warning ("emojier.vala:771: %s", "You don't install either en_US.UTF-8 or C.UTF-8 " "or C locale");
			}
		}
	}
	_tmp13_ = self->priv->m_rgba;
	if (_tmp13_ == NULL) {
		ThemedRGBA* _tmp14_;
		_tmp14_ = themed_rgba_new ((GtkWidget*) self);
		_themed_rgba_unref0 (self->priv->m_rgba);
		self->priv->m_rgba = _tmp14_;
	}
	_tmp15_ = self->priv->m_rgba;
	_tmp16_ = themed_rgba_get_normal_bg (_tmp15_);
	_tmp17_ = _tmp16_;
	bg_red = (guint) ((*_tmp17_).red * 255);
	_tmp18_ = self->priv->m_rgba;
	_tmp19_ = themed_rgba_get_normal_bg (_tmp18_);
	_tmp20_ = _tmp19_;
	bg_green = (guint) ((*_tmp20_).green * 255);
	_tmp21_ = self->priv->m_rgba;
	_tmp22_ = themed_rgba_get_normal_bg (_tmp21_);
	_tmp23_ = _tmp22_;
	bg_blue = (guint) ((*_tmp23_).blue * 255);
	_tmp24_ = self->priv->m_rgba;
	_tmp25_ = themed_rgba_get_normal_bg (_tmp24_);
	_tmp26_ = _tmp25_;
	bg_alpha = (*_tmp26_).alpha;
	_tmp27_ = g_strdup_printf ("rgba(%u, %u, %u, %lf); ", bg_red, bg_green, bg_blue, bg_alpha);
	_tmp28_ = _tmp27_;
	_tmp29_ = g_strconcat ("#IBusEmojierWhiteLabel { background-color: ", _tmp28_, NULL);
	_tmp30_ = _tmp29_;
	_tmp31_ = ibus_emojier_m_emoji_font_family;
	_tmp32_ = g_strdup_printf ("font-family: %s; font-size: %dpt; ", _tmp31_, ibus_emojier_m_emoji_font_size);
	_tmp33_ = _tmp32_;
	_tmp34_ = g_strconcat (_tmp30_, _tmp33_, NULL);
	_tmp35_ = _tmp34_;
	_tmp36_ = g_strconcat (_tmp35_, "border-width: 4px; border-radius: 3px; } ", NULL);
	_tmp37_ = _tmp36_;
	_g_free0 (_tmp35_);
	_g_free0 (_tmp33_);
	_g_free0 (_tmp30_);
	_g_free0 (_tmp28_);
	data = _tmp37_;
	_tmp38_ = self->priv->m_rgba;
	_tmp39_ = themed_rgba_get_selected_fg (_tmp38_);
	_tmp40_ = _tmp39_;
	fg_red = (guint) ((*_tmp40_).red * 255);
	_tmp41_ = self->priv->m_rgba;
	_tmp42_ = themed_rgba_get_selected_fg (_tmp41_);
	_tmp43_ = _tmp42_;
	fg_green = (guint) ((*_tmp43_).green * 255);
	_tmp44_ = self->priv->m_rgba;
	_tmp45_ = themed_rgba_get_selected_fg (_tmp44_);
	_tmp46_ = _tmp45_;
	fg_blue = (guint) ((*_tmp46_).blue * 255);
	_tmp47_ = self->priv->m_rgba;
	_tmp48_ = themed_rgba_get_selected_fg (_tmp47_);
	_tmp49_ = _tmp48_;
	fg_alpha = (*_tmp49_).alpha;
	_tmp50_ = self->priv->m_rgba;
	_tmp51_ = themed_rgba_get_selected_bg (_tmp50_);
	_tmp52_ = _tmp51_;
	bg_red = (guint) ((*_tmp52_).red * 255);
	_tmp53_ = self->priv->m_rgba;
	_tmp54_ = themed_rgba_get_selected_bg (_tmp53_);
	_tmp55_ = _tmp54_;
	bg_green = (guint) ((*_tmp55_).green * 255);
	_tmp56_ = self->priv->m_rgba;
	_tmp57_ = themed_rgba_get_selected_bg (_tmp56_);
	_tmp58_ = _tmp57_;
	bg_blue = (guint) ((*_tmp58_).blue * 255);
	_tmp59_ = self->priv->m_rgba;
	_tmp60_ = themed_rgba_get_selected_bg (_tmp59_);
	_tmp61_ = _tmp60_;
	bg_alpha = (*_tmp61_).alpha;
	_tmp62_ = data;
	_tmp63_ = g_strdup_printf ("rgba(%u, %u, %u, %lf); ", fg_red, fg_green, fg_blue, fg_alpha);
	_tmp64_ = _tmp63_;
	_tmp65_ = g_strconcat ("#IBusEmojierSelectedLabel { color: ", _tmp64_, NULL);
	_tmp66_ = _tmp65_;
	_tmp67_ = ibus_emojier_m_emoji_font_family;
	_tmp68_ = g_strdup_printf ("font-family: %s; font-size: %dpt; ", _tmp67_, ibus_emojier_m_emoji_font_size);
	_tmp69_ = _tmp68_;
	_tmp70_ = g_strconcat (_tmp66_, _tmp69_, NULL);
	_tmp71_ = _tmp70_;
	_tmp72_ = g_strconcat (_tmp71_, "background-color: ", NULL);
	_tmp73_ = _tmp72_;
	_tmp74_ = g_strdup_printf ("rgba(%u, %u, %u, %lf); ", bg_red, bg_green, bg_blue, bg_alpha);
	_tmp75_ = _tmp74_;
	_tmp76_ = g_strconcat (_tmp73_, _tmp75_, NULL);
	_tmp77_ = _tmp76_;
	_tmp78_ = g_strconcat (_tmp77_, "border-width: 4px; border-radius: 3px; }", NULL);
	_tmp79_ = _tmp78_;
	_tmp80_ = g_strconcat (_tmp62_, _tmp79_, NULL);
	_g_free0 (data);
	data = _tmp80_;
	_g_free0 (_tmp79_);
	_g_free0 (_tmp77_);
	_g_free0 (_tmp75_);
	_g_free0 (_tmp73_);
	_g_free0 (_tmp71_);
	_g_free0 (_tmp69_);
	_g_free0 (_tmp66_);
	_g_free0 (_tmp64_);
	_tmp81_ = data;
	_tmp82_ = g_strdup_printf ("rgba(%u, %u, %u, %lf); ", fg_red, fg_green, fg_blue, fg_alpha);
	_tmp83_ = _tmp82_;
	_tmp84_ = g_strconcat ("#IBusEmojierGoldLabel { color: ", _tmp83_, NULL);
	_tmp85_ = _tmp84_;
	_tmp86_ = ibus_emojier_m_emoji_font_family;
	_tmp87_ = g_strdup_printf ("font-family: %s; font-size: %dpt; ", _tmp86_, ibus_emojier_m_emoji_font_size);
	_tmp88_ = _tmp87_;
	_tmp89_ = g_strconcat (_tmp85_, _tmp88_, NULL);
	_tmp90_ = _tmp89_;
	_tmp91_ = g_strconcat (_tmp90_, "background-color: #b09c5f; ", NULL);
	_tmp92_ = _tmp91_;
	_tmp93_ = g_strconcat (_tmp92_, "border-width: 4px; border-radius: 3px; }", NULL);
	_tmp94_ = _tmp93_;
	_tmp95_ = g_strconcat (_tmp81_, _tmp94_, NULL);
	_g_free0 (data);
	data = _tmp95_;
	_g_free0 (_tmp94_);
	_g_free0 (_tmp92_);
	_g_free0 (_tmp90_);
	_g_free0 (_tmp88_);
	_g_free0 (_tmp85_);
	_g_free0 (_tmp83_);
	_tmp96_ = gtk_css_provider_new ();
	css_provider = _tmp96_;
	{
		GtkCssProvider* _tmp97_;
		const gchar* _tmp98_;
		_tmp97_ = css_provider;
		_tmp98_ = data;
		gtk_css_provider_load_from_data (_tmp97_, _tmp98_, (gssize) -1, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp99_;
		const gchar* _tmp100_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp99_ = e;
		_tmp100_ = _tmp99_->message;
		g_warning ("emojier.vala:819: Failed css_provider_from_data: %s", _tmp100_);
		_g_error_free0 (e);
		_g_object_unref0 (css_provider);
		_g_free0 (data);
		_g_free0 (backup_locale);
		_g_object_unref0 (screen);
		_g_object_unref0 (display);
		return;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (css_provider);
		_g_free0 (data);
		_g_free0 (backup_locale);
		_g_object_unref0 (screen);
		_g_object_unref0 (display);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp101_ = backup_locale;
	if (_tmp101_ != NULL) {
		const gchar* _tmp102_;
		_tmp102_ = backup_locale;
		setlocale (LC_NUMERIC, _tmp102_);
	} else {
		setlocale (LC_NUMERIC, "");
	}
	_tmp103_ = screen;
	_tmp104_ = css_provider;
	gtk_style_context_add_provider_for_screen (_tmp103_, (GtkStyleProvider*) _tmp104_, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
	_g_object_unref0 (css_provider);
	_g_free0 (data);
	_g_free0 (backup_locale);
	_g_object_unref0 (screen);
	_g_object_unref0 (display);
}

static void
ibus_emojier_set_fixed_size (IBusEmojier* self)
{
	g_return_if_fail (self != NULL);
	gtk_window_resize ((GtkWindow*) self, 20, 1);
}

static void
ibus_emojier_remove_all_children (IBusEmojier* self)
{
	IBusEmojierEListBox* _tmp0_;
	GtkBox* _tmp5_;
	GList* _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_list_box;
	if (_tmp0_ != NULL) {
		IBusEmojierEListBox* _tmp1_;
		GList* _tmp2_;
		_tmp1_ = self->priv->m_list_box;
		_tmp2_ = gtk_container_get_children ((GtkContainer*) _tmp1_);
		{
			GList* w_collection = NULL;
			GList* w_it = NULL;
			w_collection = _tmp2_;
			for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
				GtkWidget* _tmp3_;
				GtkWidget* w = NULL;
				_tmp3_ = _g_object_ref0 ((GtkWidget*) w_it->data);
				w = _tmp3_;
				{
					GtkWidget* _tmp4_;
					_tmp4_ = w;
					gtk_widget_destroy (_tmp4_);
					_g_object_unref0 (w);
				}
			}
			(w_collection == NULL) ? NULL : (w_collection = (g_list_free (w_collection), NULL));
		}
		_g_object_unref0 (self->priv->m_list_box);
		self->priv->m_list_box = NULL;
	}
	_tmp5_ = self->priv->m_vbox;
	_tmp6_ = gtk_container_get_children ((GtkContainer*) _tmp5_);
	{
		GList* w_collection = NULL;
		GList* w_it = NULL;
		w_collection = _tmp6_;
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			GtkWidget* _tmp7_;
			GtkWidget* w = NULL;
			_tmp7_ = _g_object_ref0 ((GtkWidget*) w_it->data);
			w = _tmp7_;
			{
				gboolean _tmp8_ = FALSE;
				GtkWidget* _tmp9_;
				const gchar* _tmp10_;
				const gchar* _tmp11_;
				GtkWidget* _tmp15_;
				_tmp9_ = w;
				_tmp10_ = gtk_widget_get_name (_tmp9_);
				_tmp11_ = _tmp10_;
				if (g_strcmp0 (_tmp11_, "IBusEmojierEntry") == 0) {
					_tmp8_ = TRUE;
				} else {
					GtkWidget* _tmp12_;
					const gchar* _tmp13_;
					const gchar* _tmp14_;
					_tmp12_ = w;
					_tmp13_ = gtk_widget_get_name (_tmp12_);
					_tmp14_ = _tmp13_;
					_tmp8_ = g_strcmp0 (_tmp14_, "IBusEmojierTitleLabelBox") == 0;
				}
				if (_tmp8_) {
					_g_object_unref0 (w);
					continue;
				}
				_tmp15_ = w;
				gtk_widget_destroy (_tmp15_);
				_g_object_unref0 (w);
			}
		}
		(w_collection == NULL) ? NULL : (w_collection = (g_list_free (w_collection), NULL));
	}
}

static void
ibus_emojier_clamp_page (IBusEmojier* self)
{
	GtkListBoxRow* row = NULL;
	GtkAllocation alloc = {0};
	GtkAllocation _tmp8_ = {0};
	GtkListBoxRow* _tmp9_;
	GtkAllocation _tmp10_ = {0};
	GtkAdjustment* adjustment = NULL;
	IBusEmojierEScrolledWindow* _tmp11_;
	GtkAdjustment* _tmp12_;
	GtkAdjustment* _tmp13_;
	GtkAllocation _tmp14_;
	GtkAllocation _tmp15_;
	GtkAllocation _tmp16_;
	IBusLookupTable* _tmp17_;
	g_return_if_fail (self != NULL);
	if (self->priv->m_category_active_index >= 0) {
		IBusEmojierEListBox* _tmp0_;
		GtkListBoxRow* _tmp1_;
		GtkListBoxRow* _tmp2_;
		IBusEmojierEListBox* _tmp3_;
		GtkListBoxRow* _tmp4_;
		_tmp0_ = self->priv->m_list_box;
		_tmp1_ = gtk_list_box_get_row_at_index ((GtkListBox*) _tmp0_, self->priv->m_category_active_index);
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_g_object_unref0 (row);
		row = _tmp2_;
		_tmp3_ = self->priv->m_list_box;
		_tmp4_ = row;
		gtk_list_box_select_row ((GtkListBox*) _tmp3_, _tmp4_);
	} else {
		IBusEmojierEListBox* _tmp5_;
		GtkListBoxRow* _tmp6_;
		GtkListBoxRow* _tmp7_;
		_tmp5_ = self->priv->m_list_box;
		_tmp6_ = gtk_list_box_get_row_at_index ((GtkListBox*) _tmp5_, 0);
		_tmp7_ = _g_object_ref0 (_tmp6_);
		_g_object_unref0 (row);
		row = _tmp7_;
	}
	_tmp8_.x = 0;
	_tmp8_.y = 0;
	_tmp8_.width = 0;
	_tmp8_.height = 0;
	alloc = _tmp8_;
	_tmp9_ = row;
	gtk_widget_get_allocation ((GtkWidget*) _tmp9_, &_tmp10_);
	alloc = _tmp10_;
	_tmp11_ = self->priv->m_scrolled_window;
	_tmp12_ = gtk_scrolled_window_get_vadjustment ((GtkScrolledWindow*) _tmp11_);
	_tmp13_ = _g_object_ref0 (_tmp12_);
	adjustment = _tmp13_;
	_tmp14_ = alloc;
	_tmp15_ = alloc;
	_tmp16_ = alloc;
	gtk_adjustment_clamp_page (adjustment, (gdouble) _tmp14_.y, (gdouble) (_tmp15_.y + _tmp16_.height));
	g_return_if_fail (self->priv->m_category_active_index >= 0);
	_tmp17_ = self->priv->m_lookup_table;
	ibus_lookup_table_set_cursor_pos (_tmp17_, (guint) self->priv->m_category_active_index);
	_g_object_unref0 (adjustment);
	_g_object_unref0 (row);
}

static void
__lambda28_ (IBusEmojier* self,
             GtkListBox* box,
             GtkListBoxRow* gtkrow)
{
	IBusEmojierEBoxRow* row = NULL;
	IBusEmojierEBoxRow* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_if_fail (box != NULL);
	g_return_if_fail (gtkrow != NULL);
	self->priv->m_category_active_index = gtk_list_box_row_get_index (gtkrow);
	_tmp0_ = _g_object_ref0 (IBUS_EMOJIER_IS_EBOX_ROW (gtkrow) ? ((IBusEmojierEBoxRow*) gtkrow) : NULL);
	row = _tmp0_;
	_tmp1_ = ibus_emojier_ebox_row_get_text (row);
	_tmp2_ = _tmp1_;
	ibus_emojier_show_emoji_for_category (self, _tmp2_);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (row);
}

static void
___lambda28__gtk_list_box_row_activated (GtkListBox* _sender,
                                         GtkListBoxRow* row,
                                         gpointer self)
{
	__lambda28_ ((IBusEmojier*) self, _sender, row);
}

static void
ibus_emojier_show_category_list (IBusEmojier* self)
{
	gboolean _tmp0_ = FALSE;
	IBusEmojierEScrolledWindow* _tmp7_;
	GtkBox* _tmp8_;
	IBusEmojierEScrolledWindow* _tmp9_;
	GtkViewport* viewport = NULL;
	GtkViewport* _tmp10_;
	IBusEmojierEScrolledWindow* _tmp11_;
	GtkViewport* _tmp12_;
	IBusEmojierEListBox* _tmp13_;
	GtkViewport* _tmp14_;
	IBusEmojierEListBox* _tmp15_;
	GtkAdjustment* adjustment = NULL;
	IBusEmojierEScrolledWindow* _tmp16_;
	GtkAdjustment* _tmp17_;
	GtkAdjustment* _tmp18_;
	IBusEmojierEListBox* _tmp19_;
	GtkAdjustment* _tmp20_;
	IBusEmojierEListBox* _tmp21_;
	guint ncandidates = 0U;
	IBusLookupTable* _tmp22_;
	IBusEmojierEScrolledWindow* _tmp39_;
	IBusEmojierEListBox* _tmp41_;
	IBusEmojierEListBox* _tmp42_;
	g_return_if_fail (self != NULL);
	if (self->priv->m_category_active_index >= 0) {
		IBusEmojierEListBox* _tmp1_;
		_tmp1_ = self->priv->m_list_box;
		_tmp0_ = _tmp1_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GtkListBoxRow* row = NULL;
		IBusEmojierEListBox* _tmp2_;
		GtkListBoxRow* _tmp3_;
		GtkListBoxRow* _tmp4_;
		IBusEmojierEListBox* _tmp5_;
		GtkListBoxRow* _tmp6_;
		_tmp2_ = self->priv->m_list_box;
		_tmp3_ = gtk_list_box_get_row_at_index ((GtkListBox*) _tmp2_, self->priv->m_category_active_index);
		_tmp4_ = _g_object_ref0 (_tmp3_);
		row = _tmp4_;
		_tmp5_ = self->priv->m_list_box;
		_tmp6_ = row;
		gtk_list_box_select_row ((GtkListBox*) _tmp5_, _tmp6_);
		_g_object_unref0 (row);
		return;
	}
	if (self->priv->m_category_active_index < 0) {
		self->priv->m_category_active_index = 0;
	}
	ibus_emojier_remove_all_children (self);
	_tmp7_ = ibus_emojier_escrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp7_);
	_g_object_unref0 (self->priv->m_scrolled_window);
	self->priv->m_scrolled_window = _tmp7_;
	ibus_emojier_set_fixed_size (self);
	_tmp8_ = self->priv->m_vbox;
	_tmp9_ = self->priv->m_scrolled_window;
	gtk_container_add ((GtkContainer*) _tmp8_, (GtkWidget*) _tmp9_);
	_tmp10_ = (GtkViewport*) gtk_viewport_new (NULL, NULL);
	g_object_ref_sink (_tmp10_);
	viewport = _tmp10_;
	_tmp11_ = self->priv->m_scrolled_window;
	_tmp12_ = viewport;
	gtk_container_add ((GtkContainer*) _tmp11_, (GtkWidget*) _tmp12_);
	_tmp13_ = ibus_emojier_elist_box_new ();
	g_object_ref_sink (_tmp13_);
	_g_object_unref0 (self->priv->m_list_box);
	self->priv->m_list_box = _tmp13_;
	_tmp14_ = viewport;
	_tmp15_ = self->priv->m_list_box;
	gtk_container_add ((GtkContainer*) _tmp14_, (GtkWidget*) _tmp15_);
	_tmp16_ = self->priv->m_scrolled_window;
	_tmp17_ = gtk_scrolled_window_get_vadjustment ((GtkScrolledWindow*) _tmp16_);
	_tmp18_ = _g_object_ref0 (_tmp17_);
	adjustment = _tmp18_;
	_tmp19_ = self->priv->m_list_box;
	_tmp20_ = adjustment;
	gtk_list_box_set_adjustment ((GtkListBox*) _tmp19_, _tmp20_);
	_tmp21_ = self->priv->m_list_box;
	g_signal_connect_object ((GtkListBox*) _tmp21_, "row-activated", (GCallback) ___lambda28__gtk_list_box_row_activated, self, 0);
	_tmp22_ = self->priv->m_lookup_table;
	ncandidates = ibus_lookup_table_get_number_of_candidates (_tmp22_);
	{
		guint i = 0U;
		i = (guint) 0;
		{
			gboolean _tmp23_ = FALSE;
			_tmp23_ = TRUE;
			while (TRUE) {
				gchar* category = NULL;
				IBusLookupTable* _tmp25_;
				IBusText* _tmp26_;
				const gchar* _tmp27_;
				gchar* _tmp28_;
				IBusEmojierEBoxRow* row = NULL;
				const gchar* _tmp29_;
				IBusEmojierEBoxRow* _tmp30_;
				IBusEmojierEPaddedLabelBox* widget = NULL;
				const gchar* _tmp31_;
				IBusEmojierEPaddedLabelBox* _tmp32_;
				IBusEmojierEBoxRow* _tmp33_;
				IBusEmojierEPaddedLabelBox* _tmp34_;
				IBusEmojierEListBox* _tmp35_;
				IBusEmojierEBoxRow* _tmp36_;
				if (!_tmp23_) {
					guint _tmp24_;
					_tmp24_ = i;
					i = _tmp24_ + 1;
				}
				_tmp23_ = FALSE;
				if (!(i < ncandidates)) {
					break;
				}
				_tmp25_ = self->priv->m_lookup_table;
				_tmp26_ = ibus_lookup_table_get_candidate (_tmp25_, i);
				_tmp27_ = _tmp26_->text;
				_tmp28_ = g_strdup (_tmp27_);
				category = _tmp28_;
				_tmp29_ = category;
				_tmp30_ = ibus_emojier_ebox_row_new (_tmp29_);
				g_object_ref_sink (_tmp30_);
				row = _tmp30_;
				_tmp31_ = category;
				_tmp32_ = ibus_emojier_epadded_label_box_new (_ (_tmp31_), GTK_ALIGN_CENTER, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, NULL);
				g_object_ref_sink (_tmp32_);
				widget = _tmp32_;
				_tmp33_ = row;
				_tmp34_ = widget;
				gtk_container_add ((GtkContainer*) _tmp33_, (GtkWidget*) _tmp34_);
				_tmp35_ = self->priv->m_list_box;
				_tmp36_ = row;
				gtk_container_add ((GtkContainer*) _tmp35_, (GtkWidget*) _tmp36_);
				if (i == ((guint) self->priv->m_category_active_index)) {
					IBusEmojierEListBox* _tmp37_;
					IBusEmojierEBoxRow* _tmp38_;
					_tmp37_ = self->priv->m_list_box;
					_tmp38_ = row;
					gtk_list_box_select_row ((GtkListBox*) _tmp37_, (GtkListBoxRow*) _tmp38_);
				}
				_g_object_unref0 (widget);
				_g_object_unref0 (row);
				_g_free0 (category);
			}
		}
	}
	_tmp39_ = self->priv->m_scrolled_window;
	gtk_widget_show_all ((GtkWidget*) _tmp39_);
	if (self->priv->m_category_active_index == -1) {
		IBusEmojierEListBox* _tmp40_;
		_tmp40_ = self->priv->m_list_box;
		gtk_list_box_unselect_all ((GtkListBox*) _tmp40_);
	}
	_tmp41_ = self->priv->m_list_box;
	gtk_list_box_invalidate_filter ((GtkListBox*) _tmp41_);
	_tmp42_ = self->priv->m_list_box;
	gtk_list_box_set_selection_mode ((GtkListBox*) _tmp42_, GTK_SELECTION_SINGLE);
	_g_object_unref0 (adjustment);
	_g_object_unref0 (viewport);
}

static void
ibus_emojier_show_emoji_for_category (IBusEmojier* self,
                                      const gchar* category)
{
	IBusLookupTable* _tmp17_;
	IBusText* _tmp18_;
	const gchar* _tmp19_;
	gchar* _tmp20_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (category != NULL);
	if (g_strcmp0 (category, IBUS_EMOJIER_EMOJI_CATEGORY_FAVORITES) == 0) {
		IBusLookupTable* _tmp0_;
		gchar** _tmp1_;
		gint _tmp1__length1;
		gchar* _tmp6_;
		_tmp0_ = self->priv->m_lookup_table;
		ibus_lookup_table_clear (_tmp0_);
		self->priv->m_candidate_panel_mode = TRUE;
		_tmp1_ = ibus_emojier_m_favorites;
		_tmp1__length1 = ibus_emojier_m_favorites_length1;
		{
			gchar** favorate_collection = NULL;
			gint favorate_collection_length1 = 0;
			gint _favorate_collection_size_ = 0;
			gint favorate_it = 0;
			favorate_collection = _tmp1_;
			favorate_collection_length1 = _tmp1__length1;
			for (favorate_it = 0; favorate_it < favorate_collection_length1; favorate_it = favorate_it + 1) {
				const gchar* favorate = NULL;
				favorate = favorate_collection[favorate_it];
				{
					IBusText* text = NULL;
					const gchar* _tmp2_;
					IBusText* _tmp3_;
					IBusLookupTable* _tmp4_;
					IBusText* _tmp5_;
					_tmp2_ = favorate;
					_tmp3_ = ibus_text_new_from_string (_tmp2_);
					g_object_ref_sink (_tmp3_);
					text = _tmp3_;
					_tmp4_ = self->priv->m_lookup_table;
					_tmp5_ = text;
					ibus_lookup_table_append_candidate (_tmp4_, _tmp5_);
					_g_object_unref0 (text);
				}
			}
		}
		_tmp6_ = g_strdup (category);
		_g_free0 (self->priv->m_backward);
		self->priv->m_backward = _tmp6_;
	} else {
		if (g_strcmp0 (category, IBUS_EMOJIER_EMOJI_CATEGORY_UNICODE) == 0) {
			self->priv->m_category_active_index = -1;
			ibus_emojier_m_show_unicode = TRUE;
			ibus_emojier_update_unicode_blocks (self);
			return;
		} else {
			GSList* emojis = NULL;
			GHashTable* _tmp7_;
			gconstpointer _tmp8_;
			GSList* _tmp9_;
			IBusLookupTable* _tmp10_;
			GSList* _tmp11_;
			gchar* _tmp16_;
			_tmp7_ = ibus_emojier_m_category_to_emojis_dict;
			_tmp8_ = g_hash_table_lookup (_tmp7_, category);
			_tmp9_ = g_slist_copy_deep ((GSList*) _tmp8_, _g_strdup_gcopy_func, NULL);
			emojis = _tmp9_;
			_tmp10_ = self->priv->m_lookup_table;
			ibus_lookup_table_clear (_tmp10_);
			self->priv->m_candidate_panel_mode = TRUE;
			_tmp11_ = emojis;
			{
				GSList* emoji_collection = NULL;
				GSList* emoji_it = NULL;
				emoji_collection = _tmp11_;
				for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
					const gchar* emoji = NULL;
					emoji = (const gchar*) emoji_it->data;
					{
						IBusText* text = NULL;
						const gchar* _tmp12_;
						IBusText* _tmp13_;
						IBusLookupTable* _tmp14_;
						IBusText* _tmp15_;
						_tmp12_ = emoji;
						_tmp13_ = ibus_text_new_from_string (_tmp12_);
						g_object_ref_sink (_tmp13_);
						text = _tmp13_;
						_tmp14_ = self->priv->m_lookup_table;
						_tmp15_ = text;
						ibus_lookup_table_append_candidate (_tmp14_, _tmp15_);
						_g_object_unref0 (text);
					}
				}
			}
			_tmp16_ = g_strdup (category);
			_g_free0 (self->priv->m_backward);
			self->priv->m_backward = _tmp16_;
			(emojis == NULL) ? NULL : (emojis = (_g_slist_free__g_free0_ (emojis), NULL));
		}
	}
	_tmp17_ = self->priv->m_lookup_table;
	_tmp18_ = ibus_lookup_table_get_candidate (_tmp17_, (guint) 0);
	_tmp19_ = _tmp18_->text;
	_tmp20_ = g_strdup (_tmp19_);
	_g_free0 (self->priv->m_annotation);
	self->priv->m_annotation = _tmp20_;
	if (self->priv->m_backward_index >= 0) {
		IBusLookupTable* _tmp21_;
		_tmp21_ = self->priv->m_lookup_table;
		ibus_lookup_table_set_cursor_pos (_tmp21_, (guint) self->priv->m_backward_index);
		self->priv->m_backward_index = -1;
	}
}

static void
ibus_emojier_show_emoji_variants (IBusEmojier* self,
                                  GSList* emojis)
{
	IBusLookupTable* _tmp0_;
	IBusLookupTable* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_lookup_table;
	self->priv->m_backward_index = (gint) ibus_lookup_table_get_cursor_pos (_tmp0_);
	_tmp1_ = self->priv->m_lookup_table;
	ibus_lookup_table_clear (_tmp1_);
	{
		GSList* emoji_collection = NULL;
		GSList* emoji_it = NULL;
		emoji_collection = emojis;
		for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
			const gchar* emoji = NULL;
			emoji = (const gchar*) emoji_it->data;
			{
				IBusText* text = NULL;
				const gchar* _tmp2_;
				IBusText* _tmp3_;
				IBusLookupTable* _tmp4_;
				IBusText* _tmp5_;
				_tmp2_ = emoji;
				_tmp3_ = ibus_text_new_from_string (_tmp2_);
				g_object_ref_sink (_tmp3_);
				text = _tmp3_;
				_tmp4_ = self->priv->m_lookup_table;
				_tmp5_ = text;
				ibus_lookup_table_append_candidate (_tmp4_, _tmp5_);
				_g_object_unref0 (text);
			}
		}
	}
}

static gboolean
__lambda25_ (IBusEmojier* self,
             GtkWidget* w,
             GdkEventButton* e)
{
	gboolean result = FALSE;
	g_return_val_if_fail (w != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	self->priv->m_category_active_index = -1;
	ibus_emojier_m_show_unicode = FALSE;
	ibus_emojier_hide_candidate_panel (self);
	gtk_widget_show_all ((GtkWidget*) self);
	result = TRUE;
	return result;
}

static gboolean
___lambda25__gtk_widget_button_press_event (GtkWidget* _sender,
                                            GdkEventButton* event,
                                            gpointer self)
{
	gboolean result;
	result = __lambda25_ ((IBusEmojier*) self, _sender, event);
	return result;
}

static void
__lambda26_ (IBusEmojier* self,
             GtkListBox* box,
             GtkListBoxRow* gtkrow)
{
	IBusEmojierEBoxRow* row = NULL;
	IBusEmojierEBoxRow* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	g_return_if_fail (box != NULL);
	g_return_if_fail (gtkrow != NULL);
	self->priv->m_category_active_index = gtk_list_box_row_get_index (gtkrow);
	_tmp0_ = _g_object_ref0 (IBUS_EMOJIER_IS_EBOX_ROW (gtkrow) ? ((IBusEmojierEBoxRow*) gtkrow) : NULL);
	row = _tmp0_;
	_tmp1_ = ibus_emojier_ebox_row_get_text (row);
	_tmp2_ = _tmp1_;
	ibus_emojier_show_unicode_for_block (self, _tmp2_);
	ibus_emojier_show_candidate_panel (self);
	_g_object_unref0 (row);
}

static void
___lambda26__gtk_list_box_row_activated (GtkListBox* _sender,
                                         GtkListBoxRow* row,
                                         gpointer self)
{
	__lambda26_ ((IBusEmojier*) self, _sender, row);
}

static void
__lambda27_ (IBusEmojier* self,
             GtkWidget* w,
             GtkAllocation* a)
{
	g_return_if_fail (w != NULL);
	g_return_if_fail (a != NULL);
	ibus_emojier_clamp_page (self);
}

static void
___lambda27__gtk_widget_size_allocate (GtkWidget* _sender,
                                       GtkAllocation* allocation,
                                       gpointer self)
{
	__lambda27_ ((IBusEmojier*) self, _sender, allocation);
}

static void
ibus_emojier_show_unicode_blocks (IBusEmojier* self)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp7_ = FALSE;
	IBusEmojierEPaddedLabelBox* label = NULL;
	IBusEmojierEPaddedLabelBox* _tmp10_;
	GtkButton* button = NULL;
	GtkButton* _tmp11_;
	GtkButton* _tmp12_;
	IBusEmojierEPaddedLabelBox* _tmp13_;
	GtkBox* _tmp14_;
	GtkButton* _tmp15_;
	GtkButton* _tmp16_;
	GtkButton* _tmp17_;
	IBusEmojierEScrolledWindow* _tmp18_;
	GtkBox* _tmp19_;
	IBusEmojierEScrolledWindow* _tmp20_;
	GtkViewport* viewport = NULL;
	GtkViewport* _tmp21_;
	IBusEmojierEScrolledWindow* _tmp22_;
	GtkViewport* _tmp23_;
	IBusEmojierEListBox* _tmp24_;
	GtkViewport* _tmp25_;
	IBusEmojierEListBox* _tmp26_;
	GtkAdjustment* adjustment = NULL;
	IBusEmojierEScrolledWindow* _tmp27_;
	GtkAdjustment* _tmp28_;
	GtkAdjustment* _tmp29_;
	IBusEmojierEListBox* _tmp30_;
	GtkAdjustment* _tmp31_;
	IBusEmojierEListBox* _tmp32_;
	guint n = 0U;
	GSList* _tmp33_;
	IBusEmojierEScrolledWindow* _tmp52_;
	IBusEmojierEScrolledWindow* _tmp53_;
	IBusEmojierEListBox* _tmp55_;
	IBusEmojierEListBox* _tmp56_;
	GtkListBoxRow* row = NULL;
	IBusEmojierEListBox* _tmp57_;
	GtkListBoxRow* _tmp58_;
	GtkListBoxRow* _tmp59_;
	GtkListBoxRow* _tmp60_;
	g_return_if_fail (self != NULL);
	if (self->priv->m_category_active_index >= 0) {
		IBusEmojierEListBox* _tmp1_;
		_tmp1_ = self->priv->m_list_box;
		_tmp0_ = _tmp1_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GtkListBoxRow* row = NULL;
		IBusEmojierEListBox* _tmp2_;
		GtkListBoxRow* _tmp3_;
		GtkListBoxRow* _tmp4_;
		IBusEmojierEListBox* _tmp5_;
		GtkListBoxRow* _tmp6_;
		_tmp2_ = self->priv->m_list_box;
		_tmp3_ = gtk_list_box_get_row_at_index ((GtkListBox*) _tmp2_, self->priv->m_category_active_index);
		_tmp4_ = _g_object_ref0 (_tmp3_);
		row = _tmp4_;
		_tmp5_ = self->priv->m_list_box;
		_tmp6_ = row;
		gtk_list_box_select_row ((GtkListBox*) _tmp5_, _tmp6_);
		_g_object_unref0 (row);
		return;
	}
	if (self->priv->m_category_active_index < 0) {
		self->priv->m_category_active_index = 0;
	}
	ibus_emojier_m_show_unicode = TRUE;
	if (ibus_emojier_m_default_window_width == 0) {
		_tmp7_ = ibus_emojier_m_default_window_height == 0;
	} else {
		_tmp7_ = FALSE;
	}
	if (_tmp7_) {
		gint _tmp8_ = 0;
		gint _tmp9_ = 0;
		gtk_window_get_size ((GtkWindow*) self, &_tmp8_, &_tmp9_);
		ibus_emojier_m_default_window_width = _tmp8_;
		ibus_emojier_m_default_window_height = _tmp9_;
	}
	ibus_emojier_remove_all_children (self);
	ibus_emojier_set_fixed_size (self);
	_tmp10_ = ibus_emojier_epadded_label_box_new (_ ("Bring back emoji choice"), GTK_ALIGN_CENTER, IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD, NULL);
	g_object_ref_sink (_tmp10_);
	label = _tmp10_;
	_tmp11_ = (GtkButton*) gtk_button_new ();
	g_object_ref_sink (_tmp11_);
	button = _tmp11_;
	_tmp12_ = button;
	_tmp13_ = label;
	gtk_container_add ((GtkContainer*) _tmp12_, (GtkWidget*) _tmp13_);
	_tmp14_ = self->priv->m_vbox;
	_tmp15_ = button;
	gtk_container_add ((GtkContainer*) _tmp14_, (GtkWidget*) _tmp15_);
	_tmp16_ = button;
	gtk_widget_show_all ((GtkWidget*) _tmp16_);
	_tmp17_ = button;
	g_signal_connect_object ((GtkWidget*) _tmp17_, "button-press-event", (GCallback) ___lambda25__gtk_widget_button_press_event, self, 0);
	_tmp18_ = ibus_emojier_escrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp18_);
	_g_object_unref0 (self->priv->m_scrolled_window);
	self->priv->m_scrolled_window = _tmp18_;
	_tmp19_ = self->priv->m_vbox;
	_tmp20_ = self->priv->m_scrolled_window;
	gtk_container_add ((GtkContainer*) _tmp19_, (GtkWidget*) _tmp20_);
	_tmp21_ = (GtkViewport*) gtk_viewport_new (NULL, NULL);
	g_object_ref_sink (_tmp21_);
	viewport = _tmp21_;
	_tmp22_ = self->priv->m_scrolled_window;
	_tmp23_ = viewport;
	gtk_container_add ((GtkContainer*) _tmp22_, (GtkWidget*) _tmp23_);
	_tmp24_ = ibus_emojier_elist_box_new ();
	g_object_ref_sink (_tmp24_);
	_g_object_unref0 (self->priv->m_list_box);
	self->priv->m_list_box = _tmp24_;
	_tmp25_ = viewport;
	_tmp26_ = self->priv->m_list_box;
	gtk_container_add ((GtkContainer*) _tmp25_, (GtkWidget*) _tmp26_);
	_tmp27_ = self->priv->m_scrolled_window;
	_tmp28_ = gtk_scrolled_window_get_vadjustment ((GtkScrolledWindow*) _tmp27_);
	_tmp29_ = _g_object_ref0 (_tmp28_);
	adjustment = _tmp29_;
	_tmp30_ = self->priv->m_list_box;
	_tmp31_ = adjustment;
	gtk_list_box_set_adjustment ((GtkListBox*) _tmp30_, _tmp31_);
	_tmp32_ = self->priv->m_list_box;
	g_signal_connect_object ((GtkListBox*) _tmp32_, "row-activated", (GCallback) ___lambda26__gtk_list_box_row_activated, self, 0);
	n = (guint) 0;
	_tmp33_ = ibus_emojier_m_unicode_block_list;
	{
		GSList* block_collection = NULL;
		GSList* block_it = NULL;
		block_collection = _tmp33_;
		for (block_it = block_collection; block_it != NULL; block_it = block_it->next) {
			IBusUnicodeBlock* block = NULL;
			block = (IBusUnicodeBlock*) block_it->data;
			{
				gchar* name = NULL;
				IBusUnicodeBlock* _tmp34_;
				const gchar* _tmp35_;
				gchar* _tmp36_;
				gchar* caption = NULL;
				IBusUnicodeBlock* _tmp37_;
				gchar* _tmp38_;
				IBusEmojierEBoxRow* row = NULL;
				const gchar* _tmp39_;
				IBusEmojierEBoxRow* _tmp40_;
				IBusEmojierEPaddedLabelBox* widget = NULL;
				const gchar* _tmp41_;
				const gchar* _tmp42_;
				IBusEmojierEPaddedLabelBox* _tmp43_;
				IBusEmojierEBoxRow* _tmp44_;
				IBusEmojierEPaddedLabelBox* _tmp45_;
				IBusEmojierEListBox* _tmp46_;
				IBusEmojierEBoxRow* _tmp47_;
				guint _tmp48_;
				gint _tmp49_;
				_tmp34_ = block;
				_tmp35_ = ibus_unicode_block_get_name (_tmp34_);
				_tmp36_ = g_strdup (_tmp35_);
				name = _tmp36_;
				_tmp37_ = block;
				_tmp38_ = g_strdup_printf ("U+%08X", (guint) ibus_unicode_block_get_start (_tmp37_));
				caption = _tmp38_;
				_tmp39_ = name;
				_tmp40_ = ibus_emojier_ebox_row_new (_tmp39_);
				g_object_ref_sink (_tmp40_);
				row = _tmp40_;
				_tmp41_ = name;
				_tmp42_ = caption;
				_tmp43_ = ibus_emojier_epadded_label_box_new (_ (_tmp41_), GTK_ALIGN_CENTER, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, _tmp42_);
				g_object_ref_sink (_tmp43_);
				widget = _tmp43_;
				_tmp44_ = row;
				_tmp45_ = widget;
				gtk_container_add ((GtkContainer*) _tmp44_, (GtkWidget*) _tmp45_);
				_tmp46_ = self->priv->m_list_box;
				_tmp47_ = row;
				gtk_container_add ((GtkContainer*) _tmp46_, (GtkWidget*) _tmp47_);
				_tmp48_ = n;
				n = _tmp48_ + 1;
				_tmp49_ = self->priv->m_category_active_index;
				if (_tmp48_ == ((guint) _tmp49_)) {
					IBusEmojierEListBox* _tmp50_;
					IBusEmojierEBoxRow* _tmp51_;
					_tmp50_ = self->priv->m_list_box;
					_tmp51_ = row;
					gtk_list_box_select_row ((GtkListBox*) _tmp50_, (GtkListBoxRow*) _tmp51_);
				}
				_g_object_unref0 (widget);
				_g_object_unref0 (row);
				_g_free0 (caption);
				_g_free0 (name);
			}
		}
	}
	gtk_widget_set_size_request ((GtkWidget*) self, -1, ibus_emojier_m_default_window_height + 100);
	_tmp52_ = self->priv->m_scrolled_window;
	gtk_scrolled_window_set_policy ((GtkScrolledWindow*) _tmp52_, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	_tmp53_ = self->priv->m_scrolled_window;
	gtk_widget_show_all ((GtkWidget*) _tmp53_);
	if (self->priv->m_category_active_index == -1) {
		IBusEmojierEListBox* _tmp54_;
		_tmp54_ = self->priv->m_list_box;
		gtk_list_box_unselect_all ((GtkListBox*) _tmp54_);
	}
	_tmp55_ = self->priv->m_list_box;
	gtk_list_box_invalidate_filter ((GtkListBox*) _tmp55_);
	_tmp56_ = self->priv->m_list_box;
	gtk_list_box_set_selection_mode ((GtkListBox*) _tmp56_, GTK_SELECTION_SINGLE);
	_tmp57_ = self->priv->m_list_box;
	_tmp58_ = gtk_list_box_get_row_at_index ((GtkListBox*) _tmp57_, ((gint) n) - 1);
	_tmp59_ = _g_object_ref0 (_tmp58_);
	row = _tmp59_;
	_tmp60_ = row;
	g_signal_connect_object ((GtkWidget*) _tmp60_, "size-allocate", (GCallback) ___lambda27__gtk_widget_size_allocate, self, 0);
	_g_object_unref0 (row);
	_g_object_unref0 (adjustment);
	_g_object_unref0 (viewport);
	_g_object_unref0 (button);
	_g_object_unref0 (label);
}

static void
ibus_emojier_show_unicode_for_block (IBusEmojier* self,
                                     const gchar* block_name)
{
	gunichar start = 0U;
	gunichar end = 0U;
	GSList* _tmp0_;
	IBusLookupTable* _tmp7_;
	gchar* _tmp16_;
	IBusLookupTable* _tmp17_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block_name != NULL);
	start = (gunichar) 0;
	end = (gunichar) 0;
	_tmp0_ = ibus_emojier_m_unicode_block_list;
	{
		GSList* block_collection = NULL;
		GSList* block_it = NULL;
		block_collection = _tmp0_;
		for (block_it = block_collection; block_it != NULL; block_it = block_it->next) {
			IBusUnicodeBlock* block = NULL;
			block = (IBusUnicodeBlock*) block_it->data;
			{
				gchar* name = NULL;
				IBusUnicodeBlock* _tmp1_;
				const gchar* _tmp2_;
				gchar* _tmp3_;
				const gchar* _tmp4_;
				_tmp1_ = block;
				_tmp2_ = ibus_unicode_block_get_name (_tmp1_);
				_tmp3_ = g_strdup (_tmp2_);
				name = _tmp3_;
				_tmp4_ = name;
				if (g_strcmp0 (block_name, _tmp4_) == 0) {
					IBusUnicodeBlock* _tmp5_;
					IBusUnicodeBlock* _tmp6_;
					_tmp5_ = block;
					start = ibus_unicode_block_get_start (_tmp5_);
					_tmp6_ = block;
					end = ibus_unicode_block_get_end (_tmp6_);
				}
				_g_free0 (name);
			}
		}
	}
	_tmp7_ = self->priv->m_lookup_table;
	ibus_lookup_table_clear (_tmp7_);
	self->priv->m_candidate_panel_mode = TRUE;
	{
		gunichar ch = 0U;
		ch = start;
		{
			gboolean _tmp8_ = FALSE;
			_tmp8_ = TRUE;
			while (TRUE) {
				IBusUnicodeData* data = NULL;
				GHashTable* _tmp10_;
				gconstpointer _tmp11_;
				IBusUnicodeData* _tmp12_;
				IBusText* text = NULL;
				IBusText* _tmp13_;
				IBusLookupTable* _tmp14_;
				IBusText* _tmp15_;
				if (!_tmp8_) {
					gunichar _tmp9_;
					_tmp9_ = ch;
					ch = _tmp9_ + 1;
				}
				_tmp8_ = FALSE;
				if (!(ch < end)) {
					break;
				}
				_tmp10_ = ibus_emojier_m_unicode_to_data_dict;
				_tmp11_ = g_hash_table_lookup (_tmp10_, (gpointer) ((gintptr) ch));
				data = (IBusUnicodeData*) _tmp11_;
				_tmp12_ = data;
				if (_tmp12_ == NULL) {
					continue;
				}
				_tmp13_ = ibus_text_new_from_unichar (ch);
				g_object_ref_sink (_tmp13_);
				text = _tmp13_;
				_tmp14_ = self->priv->m_lookup_table;
				_tmp15_ = text;
				ibus_lookup_table_append_candidate (_tmp14_, _tmp15_);
				_g_object_unref0 (text);
			}
		}
	}
	_tmp16_ = g_strdup (block_name);
	_g_free0 (self->priv->m_backward);
	self->priv->m_backward = _tmp16_;
	_tmp17_ = self->priv->m_lookup_table;
	if (ibus_lookup_table_get_number_of_candidates (_tmp17_) > ((guint) 0)) {
		IBusLookupTable* _tmp18_;
		IBusText* _tmp19_;
		const gchar* _tmp20_;
		gchar* _tmp21_;
		_tmp18_ = self->priv->m_lookup_table;
		_tmp19_ = ibus_lookup_table_get_candidate (_tmp18_, (guint) 0);
		_tmp20_ = _tmp19_->text;
		_tmp21_ = g_strdup (_tmp20_);
		_g_free0 (self->priv->m_annotation);
		self->priv->m_annotation = _tmp21_;
	}
}

static Block4Data*
block4_data_ref (Block4Data* _data4_)
{
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}

static void
block4_data_unref (void * _userdata_)
{
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		IBusEmojier* self;
		self = _data4_->self;
		_g_object_unref0 (_data4_->warning_button);
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}

static void
__lambda20_ (IBusEmojier* self)
{
	IBusLookupTable* _tmp0_;
	_tmp0_ = self->priv->m_lookup_table;
	ibus_lookup_table_page_down (_tmp0_);
	ibus_emojier_show_candidate_panel (self);
}

static void
___lambda20__gtk_button_clicked (GtkButton* _sender,
                                 gpointer self)
{
	__lambda20_ ((IBusEmojier*) self);
}

static void
__lambda21_ (IBusEmojier* self)
{
	IBusLookupTable* _tmp0_;
	_tmp0_ = self->priv->m_lookup_table;
	ibus_lookup_table_page_up (_tmp0_);
	ibus_emojier_show_candidate_panel (self);
}

static void
___lambda21__gtk_button_clicked (GtkButton* _sender,
                                 gpointer self)
{
	__lambda21_ ((IBusEmojier*) self);
}

static void
___lambda22_ (Block4Data* _data4_)
{
	IBusEmojier* self;
	GtkLabel* warning_label = NULL;
	const gchar* _tmp0_;
	GtkLabel* _tmp1_;
	GtkPopover* popover = NULL;
	GtkButton* _tmp2_;
	GtkPopover* _tmp3_;
	self = _data4_->self;
	_tmp0_ = ibus_emojier_m_warning_message;
	_tmp1_ = (GtkLabel*) gtk_label_new (_tmp0_);
	g_object_ref_sink (_tmp1_);
	warning_label = _tmp1_;
	gtk_label_set_line_wrap (warning_label, TRUE);
	gtk_label_set_max_width_chars (warning_label, 40);
	_tmp2_ = _data4_->warning_button;
	_tmp3_ = (GtkPopover*) gtk_popover_new ((GtkWidget*) _tmp2_);
	g_object_ref_sink (_tmp3_);
	popover = _tmp3_;
	gtk_container_add ((GtkContainer*) popover, (GtkWidget*) warning_label);
	gtk_widget_show_all ((GtkWidget*) popover);
	gtk_popover_popup (popover);
	_g_object_unref0 (popover);
	_g_object_unref0 (warning_label);
}

static void
____lambda22__gtk_button_clicked (GtkButton* _sender,
                                  gpointer self)
{
	___lambda22_ (self);
}

static void
ibus_emojier_show_arrow_buttons (IBusEmojier* self)
{
	Block4Data* _data4_;
	GtkButton* next_button = NULL;
	GtkButton* _tmp0_;
	GtkButton* _tmp1_;
	GtkButton* _tmp2_;
	GtkImage* _tmp3_;
	GtkImage* _tmp4_;
	GtkButton* _tmp5_;
	GtkButton* _tmp6_;
	GtkButton* prev_button = NULL;
	GtkButton* _tmp7_;
	GtkButton* _tmp8_;
	GtkButton* _tmp9_;
	GtkImage* _tmp10_;
	GtkImage* _tmp11_;
	GtkButton* _tmp12_;
	GtkButton* _tmp13_;
	GMenu* menu = NULL;
	GMenu* _tmp14_;
	GMenu* _tmp15_;
	GMenu* _tmp16_;
	GtkMenuButton* menu_button = NULL;
	GtkMenuButton* _tmp17_;
	GtkMenuButton* _tmp18_;
	GtkMenuButton* _tmp19_;
	GtkMenuButton* _tmp20_;
	GMenu* _tmp21_;
	GtkMenuButton* _tmp22_;
	GtkMenuButton* _tmp23_;
	IBusText* text = NULL;
	IBusText* _tmp24_;
	PangoAttrList* attrs = NULL;
	IBusText* _tmp25_;
	PangoAttrList* _tmp26_;
	GtkLabel* title_label = NULL;
	IBusText* _tmp27_;
	const gchar* _tmp28_;
	GtkLabel* _tmp29_;
	GtkLabel* _tmp30_;
	PangoAttrList* _tmp31_;
	const gchar* _tmp32_;
	GtkBox* buttons_hbox = NULL;
	GtkBox* _tmp40_;
	GtkLabel* state_label = NULL;
	GtkLabel* _tmp41_;
	GtkLabel* _tmp42_;
	GtkLabel* _tmp43_;
	GtkLabel* _tmp44_;
	GtkBox* _tmp45_;
	GtkLabel* _tmp46_;
	GtkBox* _tmp47_;
	GtkButton* _tmp48_;
	GtkBox* _tmp49_;
	GtkButton* _tmp50_;
	GtkBox* _tmp51_;
	GtkLabel* _tmp52_;
	GtkButton* _tmp53_;
	GtkBox* _tmp56_;
	GtkMenuButton* _tmp57_;
	GtkBox* _tmp58_;
	GtkBox* _tmp59_;
	GtkBox* _tmp60_;
	g_return_if_fail (self != NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_tmp0_ = (GtkButton*) gtk_button_new ();
	g_object_ref_sink (_tmp0_);
	next_button = _tmp0_;
	_tmp1_ = next_button;
	g_signal_connect_object (_tmp1_, "clicked", (GCallback) ___lambda20__gtk_button_clicked, self, 0);
	_tmp2_ = next_button;
	_tmp3_ = (GtkImage*) gtk_image_new_from_icon_name ("go-down", (GtkIconSize) GTK_ICON_SIZE_MENU);
	g_object_ref_sink (_tmp3_);
	_tmp4_ = _tmp3_;
	gtk_button_set_image (_tmp2_, (GtkWidget*) _tmp4_);
	_g_object_unref0 (_tmp4_);
	_tmp5_ = next_button;
	gtk_button_set_relief (_tmp5_, GTK_RELIEF_NONE);
	_tmp6_ = next_button;
	gtk_widget_set_tooltip_text ((GtkWidget*) _tmp6_, _ ("Page Down"));
	_tmp7_ = (GtkButton*) gtk_button_new ();
	g_object_ref_sink (_tmp7_);
	prev_button = _tmp7_;
	_tmp8_ = prev_button;
	g_signal_connect_object (_tmp8_, "clicked", (GCallback) ___lambda21__gtk_button_clicked, self, 0);
	_tmp9_ = prev_button;
	_tmp10_ = (GtkImage*) gtk_image_new_from_icon_name ("go-up", (GtkIconSize) GTK_ICON_SIZE_MENU);
	g_object_ref_sink (_tmp10_);
	_tmp11_ = _tmp10_;
	gtk_button_set_image (_tmp9_, (GtkWidget*) _tmp11_);
	_g_object_unref0 (_tmp11_);
	_tmp12_ = prev_button;
	gtk_button_set_relief (_tmp12_, GTK_RELIEF_NONE);
	_tmp13_ = prev_button;
	gtk_widget_set_tooltip_text ((GtkWidget*) _tmp13_, _ ("Page Up"));
	_tmp14_ = g_menu_new ();
	menu = _tmp14_;
	_tmp15_ = menu;
	g_menu_append (_tmp15_, _ ("Show emoji variants"), "win.variant");
	_tmp16_ = menu;
	g_menu_append (_tmp16_, _ ("Close"), "win.close");
	_tmp17_ = (GtkMenuButton*) gtk_menu_button_new ();
	g_object_ref_sink (_tmp17_);
	menu_button = _tmp17_;
	_tmp18_ = menu_button;
	gtk_menu_button_set_direction (_tmp18_, GTK_ARROW_NONE);
	_tmp19_ = menu_button;
	gtk_widget_set_valign ((GtkWidget*) _tmp19_, GTK_ALIGN_CENTER);
	_tmp20_ = menu_button;
	_tmp21_ = menu;
	gtk_menu_button_set_menu_model (_tmp20_, (GMenuModel*) _tmp21_);
	_tmp22_ = menu_button;
	gtk_button_set_relief ((GtkButton*) _tmp22_, GTK_RELIEF_NONE);
	_tmp23_ = menu_button;
	gtk_widget_set_tooltip_text ((GtkWidget*) _tmp23_, _ ("Menu"));
	_tmp24_ = ibus_emojier_get_title_text (self);
	text = _tmp24_;
	_tmp25_ = text;
	_tmp26_ = get_pango_attr_list_from_ibus_text (_tmp25_);
	attrs = _tmp26_;
	_tmp27_ = text;
	_tmp28_ = ibus_text_get_text (_tmp27_);
	_tmp29_ = (GtkLabel*) gtk_label_new (_tmp28_);
	g_object_ref_sink (_tmp29_);
	title_label = _tmp29_;
	_tmp30_ = title_label;
	_tmp31_ = attrs;
	gtk_label_set_attributes (_tmp30_, _tmp31_);
	_data4_->warning_button = NULL;
	_tmp32_ = ibus_emojier_m_warning_message;
	if (g_strcmp0 (_tmp32_, "") != 0) {
		GtkButton* _tmp33_;
		GtkButton* _tmp34_;
		GtkButton* _tmp35_;
		GtkImage* _tmp36_;
		GtkImage* _tmp37_;
		GtkButton* _tmp38_;
		GtkButton* _tmp39_;
		_tmp33_ = (GtkButton*) gtk_button_new ();
		g_object_ref_sink (_tmp33_);
		_g_object_unref0 (_data4_->warning_button);
		_data4_->warning_button = _tmp33_;
		_tmp34_ = _data4_->warning_button;
		gtk_widget_set_tooltip_text ((GtkWidget*) _tmp34_, _ ("Click to view a warning message"));
		_tmp35_ = _data4_->warning_button;
		_tmp36_ = (GtkImage*) gtk_image_new_from_icon_name ("dialog-warning", (GtkIconSize) GTK_ICON_SIZE_MENU);
		g_object_ref_sink (_tmp36_);
		_tmp37_ = _tmp36_;
		gtk_button_set_image (_tmp35_, (GtkWidget*) _tmp37_);
		_g_object_unref0 (_tmp37_);
		_tmp38_ = _data4_->warning_button;
		gtk_button_set_relief (_tmp38_, GTK_RELIEF_NONE);
		_tmp39_ = _data4_->warning_button;
		g_signal_connect_data (_tmp39_, "clicked", (GCallback) ____lambda22__gtk_button_clicked, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
	}
	_tmp40_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp40_);
	buttons_hbox = _tmp40_;
	_tmp41_ = (GtkLabel*) gtk_label_new (NULL);
	g_object_ref_sink (_tmp41_);
	state_label = _tmp41_;
	_tmp42_ = state_label;
	gtk_widget_set_size_request ((GtkWidget*) _tmp42_, 10, -1);
	_tmp43_ = state_label;
	gtk_widget_set_halign ((GtkWidget*) _tmp43_, GTK_ALIGN_CENTER);
	_tmp44_ = state_label;
	gtk_widget_set_valign ((GtkWidget*) _tmp44_, GTK_ALIGN_CENTER);
	_tmp45_ = buttons_hbox;
	_tmp46_ = state_label;
	gtk_box_pack_start (_tmp45_, (GtkWidget*) _tmp46_, FALSE, TRUE, (guint) 0);
	_tmp47_ = buttons_hbox;
	_tmp48_ = prev_button;
	gtk_box_pack_start (_tmp47_, (GtkWidget*) _tmp48_, FALSE, FALSE, (guint) 0);
	_tmp49_ = buttons_hbox;
	_tmp50_ = next_button;
	gtk_box_pack_start (_tmp49_, (GtkWidget*) _tmp50_, FALSE, FALSE, (guint) 0);
	_tmp51_ = buttons_hbox;
	_tmp52_ = title_label;
	gtk_box_pack_start (_tmp51_, (GtkWidget*) _tmp52_, FALSE, FALSE, (guint) 0);
	_tmp53_ = _data4_->warning_button;
	if (_tmp53_ != NULL) {
		GtkBox* _tmp54_;
		GtkButton* _tmp55_;
		_tmp54_ = buttons_hbox;
		_tmp55_ = _data4_->warning_button;
		gtk_box_pack_start (_tmp54_, (GtkWidget*) _tmp55_, FALSE, FALSE, (guint) 0);
	}
	_tmp56_ = buttons_hbox;
	_tmp57_ = menu_button;
	gtk_box_pack_end (_tmp56_, (GtkWidget*) _tmp57_, FALSE, FALSE, (guint) 0);
	_tmp58_ = self->priv->m_vbox;
	_tmp59_ = buttons_hbox;
	gtk_box_pack_start (_tmp58_, (GtkWidget*) _tmp59_, FALSE, FALSE, (guint) 0);
	_tmp60_ = buttons_hbox;
	gtk_widget_show_all ((GtkWidget*) _tmp60_);
	_g_object_unref0 (state_label);
	_g_object_unref0 (buttons_hbox);
	_g_object_unref0 (title_label);
	_pango_attr_list_unref0 (attrs);
	_g_object_unref0 (text);
	_g_object_unref0 (menu_button);
	_g_object_unref0 (menu);
	_g_object_unref0 (prev_button);
	_g_object_unref0 (next_button);
	block4_data_unref (_data4_);
	_data4_ = NULL;
}

static void
__lambda23_ (IBusEmojier* self,
             guint i,
             guint n)
{
	self->priv->m_unicode_percent = ((gdouble) i) / n;
}

static void
___lambda23__ibus_emojier_load_progress_object_deserialize_unicode (IBusEmojierLoadProgressObject* _sender,
                                                                    guint done,
                                                                    guint total,
                                                                    gpointer self)
{
	__lambda23_ ((IBusEmojier*) self, done, total);
}

static gboolean
__lambda24_ (IBusEmojier* self)
{
	GtkProgressBar* _tmp0_;
	GtkLabel* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	GtkProgressBar* _tmp4_;
	GtkLabel* _tmp5_;
	gboolean result = FALSE;
	self->priv->m_unicode_progress_id = (guint) 0;
	_tmp0_ = self->priv->m_unicode_progress_bar;
	gtk_progress_bar_set_fraction (_tmp0_, self->priv->m_unicode_percent);
	_tmp1_ = self->priv->m_unicode_percent_label;
	_tmp2_ = g_strdup_printf ("%.0f%%\n", self->priv->m_unicode_percent * 100);
	_tmp3_ = _tmp2_;
	gtk_label_set_text (_tmp1_, _tmp3_);
	_g_free0 (_tmp3_);
	_tmp4_ = self->priv->m_unicode_progress_bar;
	gtk_widget_show ((GtkWidget*) _tmp4_);
	_tmp5_ = self->priv->m_unicode_percent_label;
	gtk_widget_show ((GtkWidget*) _tmp5_);
	if (ibus_emojier_m_loaded_unicode) {
		ibus_emojier_show_candidate_panel (self);
	}
	result = !ibus_emojier_m_loaded_unicode;
	return result;
}

static gboolean
___lambda24__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda24_ ((IBusEmojier*) self);
	return result;
}

static void
ibus_emojier_show_unicode_progress_bar (IBusEmojier* self)
{
	GtkProgressBar* _tmp0_;
	GtkProgressBar* _tmp1_;
	GtkProgressBar* _tmp2_;
	GtkProgressBar* _tmp3_;
	GtkBox* _tmp4_;
	GtkProgressBar* _tmp5_;
	GtkProgressBar* _tmp6_;
	GtkBox* hbox = NULL;
	GtkBox* _tmp7_;
	GtkBox* _tmp8_;
	GtkBox* _tmp9_;
	GtkBox* _tmp10_;
	GtkBox* _tmp11_;
	GtkLabel* label = NULL;
	GtkLabel* _tmp12_;
	GtkBox* _tmp13_;
	GtkLabel* _tmp14_;
	GtkLabel* _tmp15_;
	GtkBox* _tmp16_;
	GtkLabel* _tmp17_;
	GtkBox* _tmp18_;
	IBusEmojierLoadProgressObject* _tmp19_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (GtkProgressBar*) gtk_progress_bar_new ();
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->m_unicode_progress_bar);
	self->priv->m_unicode_progress_bar = _tmp0_;
	_tmp1_ = self->priv->m_unicode_progress_bar;
	gtk_progress_bar_set_ellipsize (_tmp1_, PANGO_ELLIPSIZE_MIDDLE);
	_tmp2_ = self->priv->m_unicode_progress_bar;
	gtk_widget_set_halign ((GtkWidget*) _tmp2_, GTK_ALIGN_CENTER);
	_tmp3_ = self->priv->m_unicode_progress_bar;
	gtk_widget_set_valign ((GtkWidget*) _tmp3_, GTK_ALIGN_CENTER);
	_tmp4_ = self->priv->m_vbox;
	_tmp5_ = self->priv->m_unicode_progress_bar;
	gtk_container_add ((GtkContainer*) _tmp4_, (GtkWidget*) _tmp5_);
	_tmp6_ = self->priv->m_unicode_progress_bar;
	gtk_widget_show ((GtkWidget*) _tmp6_);
	_tmp7_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 5);
	g_object_ref_sink (_tmp7_);
	hbox = _tmp7_;
	_tmp8_ = hbox;
	gtk_widget_set_halign ((GtkWidget*) _tmp8_, GTK_ALIGN_CENTER);
	_tmp9_ = hbox;
	gtk_widget_set_valign ((GtkWidget*) _tmp9_, GTK_ALIGN_CENTER);
	_tmp10_ = self->priv->m_vbox;
	_tmp11_ = hbox;
	gtk_container_add ((GtkContainer*) _tmp10_, (GtkWidget*) _tmp11_);
	_tmp12_ = (GtkLabel*) gtk_label_new (_ ("Loading a Unicode dictionary:"));
	g_object_ref_sink (_tmp12_);
	label = _tmp12_;
	_tmp13_ = hbox;
	_tmp14_ = label;
	gtk_box_pack_start (_tmp13_, (GtkWidget*) _tmp14_, FALSE, TRUE, (guint) 0);
	_tmp15_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp15_);
	_g_object_unref0 (self->priv->m_unicode_percent_label);
	self->priv->m_unicode_percent_label = _tmp15_;
	_tmp16_ = hbox;
	_tmp17_ = self->priv->m_unicode_percent_label;
	gtk_box_pack_start (_tmp16_, (GtkWidget*) _tmp17_, FALSE, TRUE, (guint) 0);
	_tmp18_ = hbox;
	gtk_widget_show_all ((GtkWidget*) _tmp18_);
	_tmp19_ = ibus_emojier_m_unicode_progress_object;
	g_signal_connect_object (_tmp19_, "deserialize-unicode", (GCallback) ___lambda23__ibus_emojier_load_progress_object_deserialize_unicode, self, 0);
	if (self->priv->m_unicode_progress_id > ((guint) 0)) {
		g_source_remove (self->priv->m_unicode_progress_id);
	}
	self->priv->m_unicode_progress_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 100, ___lambda24__gsource_func, g_object_ref (self), g_object_unref);
	_g_object_unref0 (label);
	_g_object_unref0 (hbox);
}

static guint64
uint64_parse (const gchar* str,
              guint _base)
{
	guint64 result = 0ULL;
	g_return_val_if_fail (str != NULL, 0ULL);
	result = g_ascii_strtoull (str, NULL, _base);
	return result;
}

static gchar*
ibus_emojier_check_unicode_point (const gchar* annotation)
{
	gchar* unicode_point = NULL;
	GString* buff = NULL;
	GString* _tmp0_;
	GString* retval = NULL;
	GString* _tmp1_;
	gunichar code = 0U;
	GString* _tmp11_;
	const gchar* _tmp12_;
	GString* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	GString* _tmp16_;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	const gchar* _tmp19_;
	gchar* result = NULL;
	g_return_val_if_fail (annotation != NULL, NULL);
	unicode_point = NULL;
	_tmp0_ = g_string_new ("0x");
	buff = _tmp0_;
	_tmp1_ = g_string_new ("");
	retval = _tmp1_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gunichar ch = 0U;
				GString* _tmp10_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				if (!(i < g_utf8_strlen (annotation, (gssize) -1))) {
					break;
				}
				ch = string_get_char (annotation, (glong) i);
				if (ch == ((gunichar) 0)) {
					result = NULL;
					_g_string_free0 (retval);
					_g_string_free0 (buff);
					_g_free0 (unicode_point);
					return result;
				}
				if (g_unichar_isspace (ch)) {
					gunichar code = 0U;
					GString* _tmp4_;
					const gchar* _tmp5_;
					GString* _tmp6_;
					GString* _tmp7_;
					gchar* _tmp8_;
					gchar* _tmp9_;
					_tmp4_ = buff;
					_tmp5_ = _tmp4_->str;
					code = (gunichar) uint64_parse (_tmp5_, (guint) 0);
					_tmp6_ = buff;
					g_string_assign (_tmp6_, "0x");
					if (!g_unichar_validate (code)) {
						result = NULL;
						_g_string_free0 (retval);
						_g_string_free0 (buff);
						_g_free0 (unicode_point);
						return result;
					}
					_tmp7_ = retval;
					_tmp8_ = g_unichar_to_string (code);
					_tmp9_ = _tmp8_;
					g_string_append (_tmp7_, _tmp9_);
					_g_free0 (_tmp9_);
					continue;
				}
				if (!g_unichar_isxdigit (ch)) {
					result = NULL;
					_g_string_free0 (retval);
					_g_string_free0 (buff);
					_g_free0 (unicode_point);
					return result;
				}
				_tmp10_ = buff;
				g_string_append_unichar (_tmp10_, ch);
			}
		}
	}
	_tmp11_ = buff;
	_tmp12_ = _tmp11_->str;
	code = (gunichar) uint64_parse (_tmp12_, (guint) 0);
	if (!g_unichar_validate (code)) {
		result = NULL;
		_g_string_free0 (retval);
		_g_string_free0 (buff);
		_g_free0 (unicode_point);
		return result;
	}
	_tmp13_ = retval;
	_tmp14_ = g_unichar_to_string (code);
	_tmp15_ = _tmp14_;
	g_string_append (_tmp13_, _tmp15_);
	_g_free0 (_tmp15_);
	_tmp16_ = retval;
	_tmp17_ = _tmp16_->str;
	_tmp18_ = g_strdup (_tmp17_);
	_g_free0 (unicode_point);
	unicode_point = _tmp18_;
	_tmp19_ = unicode_point;
	if (_tmp19_ == NULL) {
		result = NULL;
		_g_string_free0 (retval);
		_g_string_free0 (buff);
		_g_free0 (unicode_point);
		return result;
	}
	result = unicode_point;
	_g_string_free0 (retval);
	_g_string_free0 (buff);
	return result;
}

static GSList*
ibus_emojier_lookup_emojis_from_annotation (const gchar* annotation)
{
	GSList* total_emojis = NULL;
	GSList* sub_emojis = NULL;
	GSList* sub_exact_unicodes = NULL;
	GSList* sub_unicodes = NULL;
	gint length = 0;
	gint _tmp0_;
	gint _tmp1_;
	gboolean _tmp2_ = FALSE;
	GHashTable* _tmp35_;
	gconstpointer _tmp36_;
	GSList* _tmp37_;
	GSList* result = NULL;
	g_return_val_if_fail (annotation != NULL, NULL);
	total_emojis = NULL;
	sub_emojis = NULL;
	sub_exact_unicodes = NULL;
	sub_unicodes = NULL;
	_tmp0_ = strlen (annotation);
	_tmp1_ = _tmp0_;
	length = _tmp1_;
	if (ibus_emojier_m_has_partial_match) {
		_tmp2_ = ((guint) length) >= ibus_emojier_m_partial_match_length;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		GSList* sorted_emojis = NULL;
		GHashTable* _tmp3_;
		GList* _tmp4_;
		GSList* _tmp22_;
		sorted_emojis = NULL;
		_tmp3_ = ibus_emojier_m_annotation_to_emojis_dict;
		_tmp4_ = g_hash_table_get_keys (_tmp3_);
		{
			GList* key_collection = NULL;
			GList* key_it = NULL;
			key_collection = _tmp4_;
			for (key_it = key_collection; key_it != NULL; key_it = key_it->next) {
				const gchar* key = NULL;
				key = (const gchar*) key_it->data;
				{
					const gchar* _tmp5_;
					gint _tmp6_;
					gint _tmp7_;
					gboolean matched = FALSE;
					GHashTable* _tmp11_;
					const gchar* _tmp12_;
					gconstpointer _tmp13_;
					GSList* _tmp14_;
					_tmp5_ = key;
					_tmp6_ = strlen (_tmp5_);
					_tmp7_ = _tmp6_;
					if (_tmp7_ < length) {
						continue;
					}
					matched = FALSE;
					switch (ibus_emojier_m_partial_match_condition) {
						case 0:
						{
							const gchar* _tmp8_;
							_tmp8_ = key;
							if (g_str_has_prefix (_tmp8_, annotation)) {
								matched = TRUE;
							}
							break;
						}
						case 1:
						{
							const gchar* _tmp9_;
							_tmp9_ = key;
							if (g_str_has_suffix (_tmp9_, annotation)) {
								matched = TRUE;
							}
							break;
						}
						case 2:
						{
							const gchar* _tmp10_;
							_tmp10_ = key;
							if (string_index_of (_tmp10_, annotation, 0) >= 0) {
								matched = TRUE;
							}
							break;
						}
						default:
						{
							break;
						}
					}
					if (!matched) {
						continue;
					}
					_tmp11_ = ibus_emojier_m_annotation_to_emojis_dict;
					_tmp12_ = key;
					_tmp13_ = g_hash_table_lookup (_tmp11_, _tmp12_);
					sub_emojis = (GSList*) _tmp13_;
					_tmp14_ = sub_emojis;
					{
						GSList* emoji_collection = NULL;
						GSList* emoji_it = NULL;
						emoji_collection = _tmp14_;
						for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
							const gchar* emoji = NULL;
							emoji = (const gchar*) emoji_it->data;
							{
								GSList* _tmp15_;
								const gchar* _tmp16_;
								GCompareFunc _tmp17_;
								GSList* _tmp18_;
								_tmp15_ = total_emojis;
								_tmp16_ = emoji;
								_tmp17_ = ((GCompareFunc) g_strcmp0);
								_tmp18_ = g_slist_find_custom (_tmp15_, _tmp16_, _tmp17_);
								if (_tmp18_ == NULL) {
									const gchar* _tmp19_;
									gchar* _tmp20_;
									GCompareFunc _tmp21_;
									_tmp19_ = emoji;
									_tmp20_ = g_strdup (_tmp19_);
									_tmp21_ = ((GCompareFunc) g_strcmp0);
									sorted_emojis = g_slist_insert_sorted (sorted_emojis, _tmp20_, _tmp21_);
								}
							}
						}
					}
				}
			}
			(key_collection == NULL) ? NULL : (key_collection = (g_list_free (key_collection), NULL));
		}
		_tmp22_ = sorted_emojis;
		{
			GSList* emoji_collection = NULL;
			GSList* emoji_it = NULL;
			emoji_collection = _tmp22_;
			for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
				gchar* _tmp23_;
				gchar* emoji = NULL;
				_tmp23_ = g_strdup ((const gchar*) emoji_it->data);
				emoji = _tmp23_;
				{
					GSList* _tmp24_;
					const gchar* _tmp25_;
					GCompareFunc _tmp26_;
					GSList* _tmp27_;
					_tmp24_ = total_emojis;
					_tmp25_ = emoji;
					_tmp26_ = ((GCompareFunc) g_strcmp0);
					_tmp27_ = g_slist_find_custom (_tmp24_, _tmp25_, _tmp26_);
					if (_tmp27_ == NULL) {
						const gchar* _tmp28_;
						gchar* _tmp29_;
						_tmp28_ = emoji;
						_tmp29_ = g_strdup (_tmp28_);
						total_emojis = g_slist_append (total_emojis, _tmp29_);
					}
					_g_free0 (emoji);
				}
			}
		}
		(sorted_emojis == NULL) ? NULL : (sorted_emojis = (_g_slist_free__g_free0_ (sorted_emojis), NULL));
	} else {
		GHashTable* _tmp30_;
		gconstpointer _tmp31_;
		GSList* _tmp32_;
		_tmp30_ = ibus_emojier_m_annotation_to_emojis_dict;
		_tmp31_ = g_hash_table_lookup (_tmp30_, annotation);
		sub_emojis = (GSList*) _tmp31_;
		_tmp32_ = sub_emojis;
		{
			GSList* emoji_collection = NULL;
			GSList* emoji_it = NULL;
			emoji_collection = _tmp32_;
			for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
				const gchar* emoji = NULL;
				emoji = (const gchar*) emoji_it->data;
				{
					const gchar* _tmp33_;
					gchar* _tmp34_;
					_tmp33_ = emoji;
					_tmp34_ = g_strdup (_tmp33_);
					total_emojis = g_slist_append (total_emojis, _tmp34_);
				}
			}
		}
	}
	_tmp35_ = ibus_emojier_m_name_to_unicodes_dict;
	_tmp36_ = g_hash_table_lookup (_tmp35_, annotation);
	sub_exact_unicodes = (GSList*) _tmp36_;
	_tmp37_ = sub_exact_unicodes;
	{
		GSList* code_collection = NULL;
		GSList* code_it = NULL;
		code_collection = _tmp37_;
		for (code_it = code_collection; code_it != NULL; code_it = code_it->next) {
			gunichar code = 0U;
			code = (gunichar) ((gintptr) code_it->data);
			{
				gchar* ch = NULL;
				gchar* _tmp38_;
				GSList* _tmp39_;
				const gchar* _tmp40_;
				GCompareFunc _tmp41_;
				GSList* _tmp42_;
				_tmp38_ = g_unichar_to_string (code);
				ch = _tmp38_;
				_tmp39_ = total_emojis;
				_tmp40_ = ch;
				_tmp41_ = ((GCompareFunc) g_strcmp0);
				_tmp42_ = g_slist_find_custom (_tmp39_, _tmp40_, _tmp41_);
				if (_tmp42_ == NULL) {
					const gchar* _tmp43_;
					gchar* _tmp44_;
					_tmp43_ = ch;
					_tmp44_ = g_strdup (_tmp43_);
					total_emojis = g_slist_append (total_emojis, _tmp44_);
				}
				_g_free0 (ch);
			}
		}
	}
	if (((guint) length) >= ibus_emojier_m_partial_match_length) {
		GSList* sorted_unicodes = NULL;
		GHashTable* _tmp45_;
		GList* _tmp46_;
		GSList* _tmp60_;
		sorted_unicodes = NULL;
		_tmp45_ = ibus_emojier_m_name_to_unicodes_dict;
		_tmp46_ = g_hash_table_get_keys (_tmp45_);
		{
			GList* key_collection = NULL;
			GList* key_it = NULL;
			key_collection = _tmp46_;
			for (key_it = key_collection; key_it != NULL; key_it = key_it->next) {
				const gchar* key = NULL;
				key = (const gchar*) key_it->data;
				{
					gboolean matched = FALSE;
					const gchar* _tmp47_;
					GHashTable* _tmp48_;
					const gchar* _tmp49_;
					gconstpointer _tmp50_;
					GSList* _tmp51_;
					matched = FALSE;
					_tmp47_ = key;
					if (string_index_of (_tmp47_, annotation, 0) >= 0) {
						matched = TRUE;
					}
					if (!matched) {
						continue;
					}
					_tmp48_ = ibus_emojier_m_name_to_unicodes_dict;
					_tmp49_ = key;
					_tmp50_ = g_hash_table_lookup (_tmp48_, _tmp49_);
					sub_unicodes = (GSList*) _tmp50_;
					_tmp51_ = sub_unicodes;
					{
						GSList* code_collection = NULL;
						GSList* code_it = NULL;
						code_collection = _tmp51_;
						for (code_it = code_collection; code_it != NULL; code_it = code_it->next) {
							gunichar code = 0U;
							code = (gunichar) ((gintptr) code_it->data);
							{
								gchar* ch = NULL;
								gchar* _tmp52_;
								GSList* _tmp53_;
								const gchar* _tmp54_;
								GCompareFunc _tmp55_;
								GSList* _tmp56_;
								_tmp52_ = g_unichar_to_string (code);
								ch = _tmp52_;
								_tmp53_ = sorted_unicodes;
								_tmp54_ = ch;
								_tmp55_ = ((GCompareFunc) g_strcmp0);
								_tmp56_ = g_slist_find_custom (_tmp53_, _tmp54_, _tmp55_);
								if (_tmp56_ == NULL) {
									const gchar* _tmp57_;
									gchar* _tmp58_;
									GCompareFunc _tmp59_;
									_tmp57_ = ch;
									_tmp58_ = g_strdup (_tmp57_);
									_tmp59_ = ((GCompareFunc) g_strcmp0);
									sorted_unicodes = g_slist_insert_sorted (sorted_unicodes, _tmp58_, _tmp59_);
								}
								_g_free0 (ch);
							}
						}
					}
				}
			}
			(key_collection == NULL) ? NULL : (key_collection = (g_list_free (key_collection), NULL));
		}
		_tmp60_ = sorted_unicodes;
		{
			GSList* ch_collection = NULL;
			GSList* ch_it = NULL;
			ch_collection = _tmp60_;
			for (ch_it = ch_collection; ch_it != NULL; ch_it = ch_it->next) {
				gchar* _tmp61_;
				gchar* ch = NULL;
				_tmp61_ = g_strdup ((const gchar*) ch_it->data);
				ch = _tmp61_;
				{
					GSList* _tmp62_;
					const gchar* _tmp63_;
					GCompareFunc _tmp64_;
					GSList* _tmp65_;
					_tmp62_ = total_emojis;
					_tmp63_ = ch;
					_tmp64_ = ((GCompareFunc) g_strcmp0);
					_tmp65_ = g_slist_find_custom (_tmp62_, _tmp63_, _tmp64_);
					if (_tmp65_ == NULL) {
						const gchar* _tmp66_;
						gchar* _tmp67_;
						_tmp66_ = ch;
						_tmp67_ = g_strdup (_tmp66_);
						total_emojis = g_slist_append (total_emojis, _tmp67_);
					}
					_g_free0 (ch);
				}
			}
		}
		(sorted_unicodes == NULL) ? NULL : (sorted_unicodes = (_g_slist_free__g_free0_ (sorted_unicodes), NULL));
	}
	result = total_emojis;
	return result;
}

static void
ibus_emojier_update_candidate_window (IBusEmojier* self)
{
	gchar* annotation = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	IBusLookupTable* _tmp5_;
	const gchar* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	gchar* unicode_point = NULL;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	GSList* total_emojis = NULL;
	const gchar* _tmp11_;
	GSList* _tmp18_;
	GSList* _tmp21_;
	gboolean _tmp26_ = FALSE;
	GSList* _tmp27_;
	const gchar* _tmp29_;
	GSList* _tmp34_;
	gboolean _tmp39_ = FALSE;
	IBusLookupTable* _tmp40_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_annotation;
	_tmp1_ = g_strdup (_tmp0_);
	annotation = _tmp1_;
	_tmp2_ = annotation;
	_tmp3_ = strlen (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 0) {
		_g_free0 (self->priv->m_backward);
		self->priv->m_backward = NULL;
		_g_free0 (annotation);
		return;
	}
	_tmp5_ = self->priv->m_lookup_table;
	ibus_lookup_table_clear (_tmp5_);
	self->priv->m_category_active_index = -1;
	_tmp6_ = annotation;
	_tmp7_ = strlen (_tmp6_);
	_tmp8_ = _tmp7_;
	if (_tmp8_ > ibus_emojier_m_emoji_max_seq_len) {
		_g_free0 (annotation);
		return;
	}
	_tmp9_ = annotation;
	_tmp10_ = ibus_emojier_check_unicode_point (_tmp9_);
	unicode_point = _tmp10_;
	total_emojis = NULL;
	_tmp11_ = annotation;
	if (g_ascii_strcasecmp (_tmp11_, "history") == 0) {
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp12_ = FALSE;
				_tmp12_ = TRUE;
				while (TRUE) {
					gchar** _tmp14_;
					gint _tmp14__length1;
					gchar** _tmp15_;
					gint _tmp15__length1;
					const gchar* _tmp16_;
					gchar* _tmp17_;
					if (!_tmp12_) {
						gint _tmp13_;
						_tmp13_ = i;
						i = _tmp13_ + 1;
					}
					_tmp12_ = FALSE;
					_tmp14_ = ibus_emojier_m_favorites;
					_tmp14__length1 = ibus_emojier_m_favorites_length1;
					if (!(i < _tmp14__length1)) {
						break;
					}
					_tmp15_ = ibus_emojier_m_favorites;
					_tmp15__length1 = ibus_emojier_m_favorites_length1;
					_tmp16_ = _tmp15_[i];
					_tmp17_ = g_strdup (_tmp16_);
					total_emojis = g_slist_append (total_emojis, _tmp17_);
				}
			}
		}
	}
	_tmp18_ = total_emojis;
	if (_tmp18_ == NULL) {
		const gchar* _tmp19_;
		GSList* _tmp20_;
		_tmp19_ = annotation;
		_tmp20_ = ibus_emojier_lookup_emojis_from_annotation (_tmp19_);
		(total_emojis == NULL) ? NULL : (total_emojis = (_g_slist_free__g_free0_ (total_emojis), NULL));
		total_emojis = _tmp20_;
	}
	_tmp21_ = total_emojis;
	if (_tmp21_ == NULL) {
		const gchar* _tmp22_;
		gchar* _tmp23_;
		const gchar* _tmp24_;
		GSList* _tmp25_;
		_tmp22_ = annotation;
		_tmp23_ = g_utf8_strdown (_tmp22_, (gssize) -1);
		_g_free0 (annotation);
		annotation = _tmp23_;
		_tmp24_ = annotation;
		_tmp25_ = ibus_emojier_lookup_emojis_from_annotation (_tmp24_);
		(total_emojis == NULL) ? NULL : (total_emojis = (_g_slist_free__g_free0_ (total_emojis), NULL));
		total_emojis = _tmp25_;
	}
	_tmp27_ = total_emojis;
	if (_tmp27_ == NULL) {
		const gchar* _tmp28_;
		_tmp28_ = unicode_point;
		_tmp26_ = _tmp28_ == NULL;
	} else {
		_tmp26_ = FALSE;
	}
	if (_tmp26_) {
		(total_emojis == NULL) ? NULL : (total_emojis = (_g_slist_free__g_free0_ (total_emojis), NULL));
		_g_free0 (unicode_point);
		_g_free0 (annotation);
		return;
	}
	_tmp29_ = unicode_point;
	if (_tmp29_ != NULL) {
		IBusText* text = NULL;
		const gchar* _tmp30_;
		IBusText* _tmp31_;
		IBusLookupTable* _tmp32_;
		IBusText* _tmp33_;
		_tmp30_ = unicode_point;
		_tmp31_ = ibus_text_new_from_string (_tmp30_);
		g_object_ref_sink (_tmp31_);
		text = _tmp31_;
		_tmp32_ = self->priv->m_lookup_table;
		_tmp33_ = text;
		ibus_lookup_table_append_candidate (_tmp32_, _tmp33_);
		_g_object_unref0 (text);
	}
	_tmp34_ = total_emojis;
	{
		GSList* emoji_collection = NULL;
		GSList* emoji_it = NULL;
		emoji_collection = _tmp34_;
		for (emoji_it = emoji_collection; emoji_it != NULL; emoji_it = emoji_it->next) {
			const gchar* emoji = NULL;
			emoji = (const gchar*) emoji_it->data;
			{
				IBusText* text = NULL;
				const gchar* _tmp35_;
				IBusText* _tmp36_;
				IBusLookupTable* _tmp37_;
				IBusText* _tmp38_;
				_tmp35_ = emoji;
				_tmp36_ = ibus_text_new_from_string (_tmp35_);
				g_object_ref_sink (_tmp36_);
				text = _tmp36_;
				_tmp37_ = self->priv->m_lookup_table;
				_tmp38_ = text;
				ibus_lookup_table_append_candidate (_tmp37_, _tmp38_);
				_g_object_unref0 (text);
			}
		}
	}
	_tmp40_ = self->priv->m_lookup_table;
	if (ibus_lookup_table_get_number_of_candidates (_tmp40_) > ((guint) 0)) {
		_tmp39_ = TRUE;
	} else {
		_tmp39_ = FALSE;
	}
	self->priv->m_candidate_panel_is_visible = _tmp39_;
	self->priv->m_candidate_panel_mode = TRUE;
	(total_emojis == NULL) ? NULL : (total_emojis = (_g_slist_free__g_free0_ (total_emojis), NULL));
	_g_free0 (unicode_point);
	_g_free0 (annotation);
}

static gint
__lambda16_ (const gchar* a,
             const gchar* b)
{
	gboolean _tmp0_ = FALSE;
	GCompareFunc _tmp2_;
	gint result = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	if (g_strcmp0 (a, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) == 0) {
		_tmp0_ = g_strcmp0 (b, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) != 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = 1;
		return result;
	} else {
		gboolean _tmp1_ = FALSE;
		if (g_strcmp0 (a, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) != 0) {
			_tmp1_ = g_strcmp0 (b, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) == 0;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			result = -1;
			return result;
		}
	}
	_tmp2_ = ((GCompareFunc) g_strcmp0);
	result = _tmp2_ (_ (a), _ (b));
	return result;
}

static gint
___lambda16__gcompare_func (gconstpointer a,
                            gconstpointer b)
{
	gint result;
	result = __lambda16_ ((const gchar*) a, (const gchar*) b);
	return result;
}

static void
ibus_emojier_update_category_list (IBusEmojier* self)
{
	IBusLookupTable* _tmp0_;
	IBusText* text = NULL;
	gchar** _tmp1_;
	gint _tmp1__length1;
	GList* categories = NULL;
	GHashTable* _tmp5_;
	GList* _tmp6_;
	GList* _tmp7_;
	GSList* _tmp13_;
	g_return_if_fail (self != NULL);
	ibus_emojier_reset_window_mode (self);
	_tmp0_ = self->priv->m_lookup_table;
	ibus_lookup_table_clear (_tmp0_);
	_tmp1_ = ibus_emojier_m_favorites;
	_tmp1__length1 = ibus_emojier_m_favorites_length1;
	if (_tmp1__length1 > 0) {
		IBusText* _tmp2_;
		IBusLookupTable* _tmp3_;
		IBusText* _tmp4_;
		_tmp2_ = ibus_text_new_from_string (IBUS_EMOJIER_EMOJI_CATEGORY_FAVORITES);
		g_object_ref_sink (_tmp2_);
		_g_object_unref0 (text);
		text = _tmp2_;
		_tmp3_ = self->priv->m_lookup_table;
		_tmp4_ = text;
		ibus_lookup_table_append_candidate (_tmp3_, _tmp4_);
	}
	_tmp5_ = ibus_emojier_m_category_to_emojis_dict;
	_tmp6_ = g_hash_table_get_keys (_tmp5_);
	categories = _tmp6_;
	categories = g_list_sort (categories, ___lambda16__gcompare_func);
	_tmp7_ = categories;
	{
		GList* category_collection = NULL;
		GList* category_it = NULL;
		category_collection = _tmp7_;
		for (category_it = category_collection; category_it != NULL; category_it = category_it->next) {
			const gchar* category = NULL;
			category = (const gchar*) category_it->data;
			{
				const gchar* _tmp8_;
				const gchar* _tmp9_;
				IBusText* _tmp10_;
				IBusLookupTable* _tmp11_;
				IBusText* _tmp12_;
				_tmp8_ = category;
				if (g_strcmp0 (_tmp8_, IBUS_EMOJIER_EMOJI_CATEGORY_OTHERS) == 0) {
					continue;
				}
				_tmp9_ = category;
				_tmp10_ = ibus_text_new_from_string (_tmp9_);
				g_object_ref_sink (_tmp10_);
				_g_object_unref0 (text);
				text = _tmp10_;
				_tmp11_ = self->priv->m_lookup_table;
				_tmp12_ = text;
				ibus_lookup_table_append_candidate (_tmp11_, _tmp12_);
			}
		}
	}
	_tmp13_ = ibus_emojier_m_unicode_block_list;
	if (g_slist_length (_tmp13_) > ((guint) 0)) {
		IBusText* _tmp14_;
		IBusLookupTable* _tmp15_;
		IBusText* _tmp16_;
		_tmp14_ = ibus_text_new_from_string (IBUS_EMOJIER_EMOJI_CATEGORY_UNICODE);
		g_object_ref_sink (_tmp14_);
		_g_object_unref0 (text);
		text = _tmp14_;
		_tmp15_ = self->priv->m_lookup_table;
		_tmp16_ = text;
		ibus_lookup_table_append_candidate (_tmp15_, _tmp16_);
	}
	(categories == NULL) ? NULL : (categories = (g_list_free (categories), NULL));
	_g_object_unref0 (text);
}

static void
ibus_emojier_update_unicode_blocks (IBusEmojier* self)
{
	IBusLookupTable* _tmp0_;
	GSList* _tmp1_;
	g_return_if_fail (self != NULL);
	ibus_emojier_reset_window_mode (self);
	_tmp0_ = self->priv->m_lookup_table;
	ibus_lookup_table_clear (_tmp0_);
	ibus_emojier_m_show_unicode = TRUE;
	_tmp1_ = ibus_emojier_m_unicode_block_list;
	{
		GSList* block_collection = NULL;
		GSList* block_it = NULL;
		block_collection = _tmp1_;
		for (block_it = block_collection; block_it != NULL; block_it = block_it->next) {
			IBusUnicodeBlock* block = NULL;
			block = (IBusUnicodeBlock*) block_it->data;
			{
				gchar* name = NULL;
				IBusUnicodeBlock* _tmp2_;
				const gchar* _tmp3_;
				gchar* _tmp4_;
				IBusText* text = NULL;
				const gchar* _tmp5_;
				IBusText* _tmp6_;
				IBusLookupTable* _tmp7_;
				IBusText* _tmp8_;
				_tmp2_ = block;
				_tmp3_ = ibus_unicode_block_get_name (_tmp2_);
				_tmp4_ = g_strdup (_tmp3_);
				name = _tmp4_;
				_tmp5_ = name;
				_tmp6_ = ibus_text_new_from_string (_tmp5_);
				g_object_ref_sink (_tmp6_);
				text = _tmp6_;
				_tmp7_ = self->priv->m_lookup_table;
				_tmp8_ = text;
				ibus_lookup_table_append_candidate (_tmp7_, _tmp8_);
				_g_object_unref0 (text);
				_g_free0 (name);
			}
		}
	}
}

static void
ibus_emojier_show_code_point_description (IBusEmojier* self,
                                          const gchar* text)
{
	IBusEmojierEPaddedLabelBox* widget_code = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	IBusEmojierEPaddedLabelBox* _tmp4_;
	IBusEmojierEPaddedLabelBox* _tmp5_;
	GtkBox* _tmp6_;
	IBusEmojierEPaddedLabelBox* _tmp7_;
	IBusEmojierEPaddedLabelBox* _tmp8_;
	GHashTable* _tmp9_;
	gconstpointer _tmp10_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = ibus_emojier_utf8_code_point (text);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strdup_printf (_ ("Code point: %s"), _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = ibus_emojier_epadded_label_box_new (_tmp3_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, NULL);
	g_object_ref_sink (_tmp4_);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	_g_free0 (_tmp1_);
	widget_code = _tmp5_;
	_tmp6_ = self->priv->m_vbox;
	_tmp7_ = widget_code;
	gtk_container_add ((GtkContainer*) _tmp6_, (GtkWidget*) _tmp7_);
	_tmp8_ = widget_code;
	gtk_widget_show_all ((GtkWidget*) _tmp8_);
	_tmp9_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
	_tmp10_ = g_hash_table_lookup (_tmp9_, text);
	if (((GSList*) _tmp10_) != NULL) {
		IBusEmojierEPaddedLabelBox* widget_has_variant = NULL;
		IBusEmojierEPaddedLabelBox* _tmp11_;
		GtkBox* _tmp12_;
		IBusEmojierEPaddedLabelBox* _tmp13_;
		IBusEmojierEPaddedLabelBox* _tmp14_;
		_tmp11_ = ibus_emojier_epadded_label_box_new (_ ("Has emoji variants"), GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, NULL);
		g_object_ref_sink (_tmp11_);
		widget_has_variant = _tmp11_;
		_tmp12_ = self->priv->m_vbox;
		_tmp13_ = widget_has_variant;
		gtk_container_add ((GtkContainer*) _tmp12_, (GtkWidget*) _tmp13_);
		_tmp14_ = widget_has_variant;
		gtk_widget_show_all ((GtkWidget*) _tmp14_);
		_g_object_unref0 (widget_has_variant);
	}
	_g_object_unref0 (widget_code);
}

static gboolean
___lambda15_ (IBusEmojier* self,
              GtkWidget* w,
              GdkEventButton* e)
{
	gboolean _tmp0_ = FALSE;
	gboolean result = FALSE;
	g_return_val_if_fail (w != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	if (self->priv->m_backward_index >= 0) {
		const gchar* _tmp1_;
		_tmp1_ = self->priv->m_backward;
		_tmp0_ = _tmp1_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		const gchar* _tmp2_;
		_tmp2_ = self->priv->m_backward;
		ibus_emojier_show_emoji_for_category (self, _tmp2_);
		ibus_emojier_show_candidate_panel (self);
	} else {
		ibus_emojier_hide_candidate_panel (self);
		gtk_widget_show_all ((GtkWidget*) self);
	}
	result = TRUE;
	return result;
}

static gboolean
____lambda15__gtk_widget_button_press_event (GtkWidget* _sender,
                                             GdkEventButton* event,
                                             gpointer self)
{
	gboolean result;
	result = ___lambda15_ ((IBusEmojier*) self, _sender, event);
	return result;
}

static Block5Data*
block5_data_ref (Block5Data* _data5_)
{
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}

static void
block5_data_unref (void * _userdata_)
{
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		IBusEmojier* self;
		self = _data5_->self;
		_g_object_unref0 (self);
		g_slice_free (Block5Data, _data5_);
	}
}

static gboolean
_____lambda17_ (Block5Data* _data5_,
                GtkWidget* w,
                GdkEventButton* e)
{
	IBusEmojier* self;
	GdkModifierType _tmp0_;
	gboolean result = FALSE;
	self = _data5_->self;
	g_return_val_if_fail (w != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = e->state;
	g_signal_emit (self, ibus_emojier_signals[IBUS_EMOJIER_CANDIDATE_CLICKED_SIGNAL], 0, _data5_->index, e->button, (guint) _tmp0_);
	result = TRUE;
	return result;
}

static gboolean
______lambda17__gtk_widget_button_press_event (GtkWidget* _sender,
                                               GdkEventButton* event,
                                               gpointer self)
{
	gboolean result;
	result = _____lambda17_ (self, _sender, event);
	return result;
}

static GdkEventMotion*
_vala_GdkEventMotion_copy (GdkEventMotion* self)
{
	return g_boxed_copy (gdk_event_get_type (), self);
}

static gpointer
__vala_GdkEventMotion_copy0 (gpointer self)
{
	return self ? _vala_GdkEventMotion_copy (self) : NULL;
}

static void
_vala_GdkEventMotion_free (GdkEventMotion* self)
{
	g_boxed_free (gdk_event_get_type (), self);
}

static gboolean
__lambda19_ (IBusEmojier* self)
{
	gboolean result = FALSE;
	ibus_emojier_show_candidate_panel (self);
	result = FALSE;
	return result;
}

static gboolean
___lambda19__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda19_ ((IBusEmojier*) self);
	return result;
}

static gboolean
_____lambda18_ (Block5Data* _data5_,
                GdkEventMotion* e)
{
	IBusEmojier* self;
	IBusLookupTable* _tmp0_;
	GdkEventMotion* pe = NULL;
	GdkEventMotion* _tmp1_;
	gboolean _tmp2_ = FALSE;
	GdkEventMotion* _tmp3_;
	GdkEventMotion* _tmp5_;
	GdkEventMotion* _tmp6_;
	IBusLookupTable* _tmp7_;
	gboolean _tmp8_ = FALSE;
	gboolean result = FALSE;
	self = _data5_->self;
	g_return_val_if_fail (e != NULL, FALSE);
	if (!self->priv->m_enter_notify_enable) {
		result = FALSE;
		return result;
	}
	_tmp0_ = self->priv->m_lookup_table;
	if (ibus_lookup_table_get_cursor_pos (_tmp0_) == _data5_->index) {
		result = FALSE;
		return result;
	}
	_tmp1_ = __vala_GdkEventMotion_copy0 (e);
	pe = _tmp1_;
	_tmp3_ = pe;
	if (ibus_emojier_m_mouse_x == _tmp3_->x_root) {
		GdkEventMotion* _tmp4_;
		_tmp4_ = pe;
		_tmp2_ = ibus_emojier_m_mouse_y == _tmp4_->y_root;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		result = FALSE;
		__vala_GdkEventMotion_free0 (pe);
		return result;
	}
	_tmp5_ = pe;
	ibus_emojier_m_mouse_x = _tmp5_->x_root;
	_tmp6_ = pe;
	ibus_emojier_m_mouse_y = _tmp6_->y_root;
	_tmp7_ = self->priv->m_lookup_table;
	ibus_lookup_table_set_cursor_pos (_tmp7_, _data5_->index);
	if (self->priv->m_entry_notify_show_id > ((guint) 0)) {
		GMainContext* _tmp9_;
		GSource* _tmp10_;
		_tmp9_ = g_main_context_default ();
		_tmp10_ = g_main_context_find_source_by_id (_tmp9_, self->priv->m_entry_notify_show_id);
		_tmp8_ = _tmp10_ != NULL;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		g_source_remove (self->priv->m_entry_notify_show_id);
	}
	self->priv->m_entry_notify_show_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 100, ___lambda19__gsource_func, g_object_ref (self), g_object_unref);
	result = FALSE;
	__vala_GdkEventMotion_free0 (pe);
	return result;
}

static gboolean
______lambda18__gtk_widget_motion_notify_event (GtkWidget* _sender,
                                                GdkEventMotion* event,
                                                gpointer self)
{
	gboolean result;
	result = _____lambda18_ (self, event);
	return result;
}

static void
_vala_array_add8 (GtkLabel** * array,
                  gint* length,
                  gint* size,
                  GtkLabel* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkLabel*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static void
ibus_emojier_show_candidate_panel (IBusEmojier* self)
{
	guint page_size = 0U;
	IBusLookupTable* _tmp0_;
	guint ncandidates = 0U;
	IBusLookupTable* _tmp1_;
	guint cursor = 0U;
	IBusLookupTable* _tmp2_;
	guint page_start_pos = 0U;
	guint page_end_pos = 0U;
	GtkButton* backward_button = NULL;
	const gchar* _tmp3_;
	IBusEmojierEGrid* grid = NULL;
	IBusEmojierEGrid* _tmp12_;
	gint n = 0;
	g_return_if_fail (self != NULL);
	ibus_emojier_remove_all_children (self);
	ibus_emojier_set_fixed_size (self);
	if (ibus_emojier_m_emoji_font_changed) {
		ibus_emojier_set_css_data (self);
		ibus_emojier_m_emoji_font_changed = FALSE;
	}
	_tmp0_ = self->priv->m_lookup_table;
	page_size = ibus_lookup_table_get_page_size (_tmp0_);
	_tmp1_ = self->priv->m_lookup_table;
	ncandidates = ibus_lookup_table_get_number_of_candidates (_tmp1_);
	_tmp2_ = self->priv->m_lookup_table;
	cursor = ibus_lookup_table_get_cursor_pos (_tmp2_);
	page_start_pos = (cursor / page_size) * page_size;
	page_end_pos = MIN (page_start_pos + page_size, ncandidates);
	backward_button = NULL;
	_tmp3_ = self->priv->m_backward;
	if (_tmp3_ != NULL) {
		gchar* backward_desc = NULL;
		const gchar* _tmp4_;
		gchar* _tmp5_;
		IBusEmojierEPaddedLabelBox* label = NULL;
		const gchar* _tmp6_;
		IBusEmojierEPaddedLabelBox* _tmp7_;
		GtkButton* _tmp8_;
		GtkButton* _tmp9_;
		IBusEmojierEPaddedLabelBox* _tmp10_;
		GtkButton* _tmp11_;
		_tmp4_ = self->priv->m_backward;
		_tmp5_ = g_strdup (_ (_tmp4_));
		backward_desc = _tmp5_;
		_tmp6_ = backward_desc;
		_tmp7_ = ibus_emojier_epadded_label_box_new (_tmp6_, GTK_ALIGN_CENTER, IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD, NULL);
		g_object_ref_sink (_tmp7_);
		label = _tmp7_;
		_tmp8_ = (GtkButton*) gtk_button_new ();
		g_object_ref_sink (_tmp8_);
		_g_object_unref0 (backward_button);
		backward_button = _tmp8_;
		_tmp9_ = backward_button;
		_tmp10_ = label;
		gtk_container_add ((GtkContainer*) _tmp9_, (GtkWidget*) _tmp10_);
		_tmp11_ = backward_button;
		g_signal_connect_object ((GtkWidget*) _tmp11_, "button-press-event", (GCallback) ____lambda15__gtk_widget_button_press_event, self, 0);
		_g_object_unref0 (label);
		_g_free0 (backward_desc);
	}
	_tmp12_ = ibus_emojier_egrid_new ();
	g_object_ref_sink (_tmp12_);
	grid = _tmp12_;
	n = 0;
	{
		guint i = 0U;
		i = page_start_pos;
		{
			gboolean _tmp13_ = FALSE;
			_tmp13_ = TRUE;
			while (TRUE) {
				Block5Data* _data5_;
				gchar* text = NULL;
				IBusLookupTable* _tmp15_;
				IBusText* _tmp16_;
				const gchar* _tmp17_;
				gchar* _tmp18_;
				gboolean has_variant = FALSE;
				GHashTable* _tmp19_;
				const gchar* _tmp20_;
				gconstpointer _tmp21_;
				GtkLabel* label = NULL;
				const gchar* _tmp33_;
				GtkLabel* _tmp46_;
				GtkLabel* _tmp47_;
				GtkEventBox* candidate_ebox = NULL;
				GtkEventBox* _tmp48_;
				GtkEventBox* _tmp49_;
				GtkEventBox* _tmp50_;
				GtkLabel* _tmp51_;
				GtkEventBox* _tmp52_;
				GtkEventBox* _tmp53_;
				IBusEmojierEGrid* _tmp54_;
				GtkEventBox* _tmp55_;
				gint _tmp56_;
				GtkLabel* _tmp57_;
				GtkLabel* _tmp58_;
				_data5_ = g_slice_new0 (Block5Data);
				_data5_->_ref_count_ = 1;
				_data5_->self = g_object_ref (self);
				if (!_tmp13_) {
					guint _tmp14_;
					_tmp14_ = i;
					i = _tmp14_ + 1;
				}
				_tmp13_ = FALSE;
				if (!(i < page_end_pos)) {
					block5_data_unref (_data5_);
					_data5_ = NULL;
					break;
				}
				_tmp15_ = self->priv->m_lookup_table;
				_tmp16_ = ibus_lookup_table_get_candidate (_tmp15_, i);
				_tmp17_ = _tmp16_->text;
				_tmp18_ = g_strdup (_tmp17_);
				text = _tmp18_;
				_tmp19_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
				_tmp20_ = text;
				_tmp21_ = g_hash_table_lookup (_tmp19_, _tmp20_);
				has_variant = ((GSList*) _tmp21_) != NULL;
				if (i == cursor) {
					const gchar* _tmp22_;
					IBusEmojierESelectedLabel* _tmp23_;
					GtkLabel* _tmp24_;
					_tmp22_ = text;
					_tmp23_ = ibus_emojier_eselected_label_new (_tmp22_);
					_tmp24_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp23_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp23_) : NULL;
					if (_tmp24_ == NULL) {
						_g_object_unref0 (_tmp23_);
					}
					if (_tmp24_ != NULL) {
						g_object_ref_sink (_tmp24_);
					}
					_g_object_unref0 (label);
					label = _tmp24_;
				} else {
					gboolean _tmp25_ = FALSE;
					gboolean _tmp26_ = FALSE;
					if (ibus_emojier_m_show_emoji_variant) {
						_tmp26_ = has_variant;
					} else {
						_tmp26_ = FALSE;
					}
					if (_tmp26_) {
						_tmp25_ = self->priv->m_backward_index < 0;
					} else {
						_tmp25_ = FALSE;
					}
					if (_tmp25_) {
						const gchar* _tmp27_;
						IBusEmojierEGoldLabel* _tmp28_;
						GtkLabel* _tmp29_;
						_tmp27_ = text;
						_tmp28_ = ibus_emojier_egold_label_new (_tmp27_);
						_tmp29_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp28_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp28_) : NULL;
						if (_tmp29_ == NULL) {
							_g_object_unref0 (_tmp28_);
						}
						if (_tmp29_ != NULL) {
							g_object_ref_sink (_tmp29_);
						}
						_g_object_unref0 (label);
						label = _tmp29_;
					} else {
						const gchar* _tmp30_;
						IBusEmojierEWhiteLabel* _tmp31_;
						GtkLabel* _tmp32_;
						_tmp30_ = text;
						_tmp31_ = ibus_emojier_ewhite_label_new (_tmp30_);
						_tmp32_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp31_, gtk_label_get_type ()) ? ((GtkLabel*) _tmp31_) : NULL;
						if (_tmp32_ == NULL) {
							_g_object_unref0 (_tmp31_);
						}
						if (_tmp32_ != NULL) {
							g_object_ref_sink (_tmp32_);
						}
						_g_object_unref0 (label);
						label = _tmp32_;
					}
				}
				_tmp33_ = text;
				if (g_utf8_strlen (_tmp33_, (gssize) -1) > 2) {
					gchar* font_family = NULL;
					const gchar* _tmp34_;
					gchar* _tmp35_;
					gint font_size = 0;
					gchar* emoji_font = NULL;
					const gchar* _tmp36_;
					gchar* _tmp37_;
					gchar* markup = NULL;
					const gchar* _tmp38_;
					const gchar* _tmp39_;
					gchar* _tmp40_;
					gchar* _tmp41_;
					gchar* _tmp42_;
					gchar* _tmp43_;
					GtkLabel* _tmp44_;
					const gchar* _tmp45_;
					_tmp34_ = ibus_emojier_m_emoji_font_family;
					_tmp35_ = g_strdup (_tmp34_);
					font_family = _tmp35_;
					font_size = ibus_emojier_m_emoji_font_size - 2;
					_tmp36_ = font_family;
					_tmp37_ = g_strdup_printf ("%s %d", _tmp36_, font_size);
					emoji_font = _tmp37_;
					_tmp38_ = emoji_font;
					_tmp39_ = text;
					_tmp40_ = ibus_emojier_utf8_entity (_tmp39_);
					_tmp41_ = _tmp40_;
					_tmp42_ = g_strdup_printf ("<span font=\"%s\">%s</span>", _tmp38_, _tmp41_);
					_tmp43_ = _tmp42_;
					_g_free0 (_tmp41_);
					markup = _tmp43_;
					_tmp44_ = label;
					_tmp45_ = markup;
					gtk_label_set_markup (_tmp44_, _tmp45_);
					_g_free0 (markup);
					_g_free0 (emoji_font);
					_g_free0 (font_family);
				}
				_tmp46_ = label;
				gtk_widget_set_halign ((GtkWidget*) _tmp46_, GTK_ALIGN_FILL);
				_tmp47_ = label;
				gtk_widget_set_valign ((GtkWidget*) _tmp47_, GTK_ALIGN_FILL);
				_tmp48_ = (GtkEventBox*) gtk_event_box_new ();
				g_object_ref_sink (_tmp48_);
				candidate_ebox = _tmp48_;
				_tmp49_ = candidate_ebox;
				gtk_widget_add_events ((GtkWidget*) _tmp49_, (gint) GDK_POINTER_MOTION_MASK);
				_tmp50_ = candidate_ebox;
				_tmp51_ = label;
				gtk_container_add ((GtkContainer*) _tmp50_, (GtkWidget*) _tmp51_);
				_data5_->index = i;
				_tmp52_ = candidate_ebox;
				g_signal_connect_data ((GtkWidget*) _tmp52_, "button-press-event", (GCallback) ______lambda17__gtk_widget_button_press_event, block5_data_ref (_data5_), (GClosureNotify) block5_data_unref, 0);
				_tmp53_ = candidate_ebox;
				g_signal_connect_data ((GtkWidget*) _tmp53_, "motion-notify-event", (GCallback) ______lambda18__gtk_widget_motion_notify_event, block5_data_ref (_data5_), (GClosureNotify) block5_data_unref, 0);
				_tmp54_ = grid;
				_tmp55_ = candidate_ebox;
				gtk_grid_attach ((GtkGrid*) _tmp54_, (GtkWidget*) _tmp55_, n % ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE), n / ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE), 1, 1);
				_tmp56_ = n;
				n = _tmp56_ + 1;
				_tmp57_ = label;
				_tmp58_ = _g_object_ref0 (_tmp57_);
				_vala_array_add8 (&self->priv->m_candidates, &self->priv->m_candidates_length1, &self->priv->_m_candidates_size_, _tmp58_);
				_g_object_unref0 (candidate_ebox);
				_g_object_unref0 (label);
				_g_free0 (text);
				block5_data_unref (_data5_);
				_data5_ = NULL;
			}
		}
	}
	self->priv->m_candidate_panel_is_visible = TRUE;
	if (!self->priv->m_is_up_side_down) {
		GtkButton* _tmp59_;
		ibus_emojier_show_arrow_buttons (self);
		_tmp59_ = backward_button;
		if (_tmp59_ != NULL) {
			GtkBox* _tmp60_;
			GtkButton* _tmp61_;
			GtkButton* _tmp62_;
			_tmp60_ = self->priv->m_vbox;
			_tmp61_ = backward_button;
			gtk_container_add ((GtkContainer*) _tmp60_, (GtkWidget*) _tmp61_);
			_tmp62_ = backward_button;
			gtk_widget_show_all ((GtkWidget*) _tmp62_);
		}
		if (n > 0) {
			GtkBox* _tmp63_;
			IBusEmojierEGrid* _tmp64_;
			IBusEmojierEGrid* _tmp65_;
			_tmp63_ = self->priv->m_vbox;
			_tmp64_ = grid;
			gtk_container_add ((GtkContainer*) _tmp63_, (GtkWidget*) _tmp64_);
			_tmp65_ = grid;
			gtk_widget_show_all ((GtkWidget*) _tmp65_);
			ibus_emojier_show_description (self);
		}
		if (!ibus_emojier_m_loaded_unicode) {
			ibus_emojier_show_unicode_progress_bar (self);
		}
	} else {
		GtkButton* _tmp69_;
		if (!ibus_emojier_m_loaded_unicode) {
			ibus_emojier_show_unicode_progress_bar (self);
		}
		if (n > 0) {
			GtkBox* _tmp66_;
			IBusEmojierEGrid* _tmp67_;
			IBusEmojierEGrid* _tmp68_;
			ibus_emojier_show_description (self);
			_tmp66_ = self->priv->m_vbox;
			_tmp67_ = grid;
			gtk_container_add ((GtkContainer*) _tmp66_, (GtkWidget*) _tmp67_);
			_tmp68_ = grid;
			gtk_widget_show_all ((GtkWidget*) _tmp68_);
		}
		_tmp69_ = backward_button;
		if (_tmp69_ != NULL) {
			GtkBox* _tmp70_;
			GtkButton* _tmp71_;
			GtkButton* _tmp72_;
			_tmp70_ = self->priv->m_vbox;
			_tmp71_ = backward_button;
			gtk_container_add ((GtkContainer*) _tmp70_, (GtkWidget*) _tmp71_);
			_tmp72_ = backward_button;
			gtk_widget_show_all ((GtkWidget*) _tmp72_);
		}
		ibus_emojier_show_arrow_buttons (self);
	}
	_g_object_unref0 (grid);
	_g_object_unref0 (backward_button);
}

static void
ibus_emojier_show_description (IBusEmojier* self)
{
	guint cursor = 0U;
	IBusLookupTable* _tmp0_;
	gchar* text = NULL;
	IBusLookupTable* _tmp1_;
	IBusText* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	IBusEmojiData* data = NULL;
	GHashTable* _tmp5_;
	const gchar* _tmp6_;
	gconstpointer _tmp7_;
	IBusEmojiData* _tmp8_;
	const gchar* _tmp11_;
	IBusEmojierEPaddedLabelBox* widget = NULL;
	gchar* _tmp18_;
	gchar* _tmp19_;
	IBusEmojierEPaddedLabelBox* _tmp20_;
	IBusEmojierEPaddedLabelBox* _tmp21_;
	GtkBox* _tmp22_;
	IBusEmojierEPaddedLabelBox* _tmp23_;
	IBusEmojierEPaddedLabelBox* _tmp24_;
	const gchar* _tmp25_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_lookup_table;
	cursor = ibus_lookup_table_get_cursor_pos (_tmp0_);
	_tmp1_ = self->priv->m_lookup_table;
	_tmp2_ = ibus_lookup_table_get_candidate (_tmp1_, cursor);
	_tmp3_ = _tmp2_->text;
	_tmp4_ = g_strdup (_tmp3_);
	text = _tmp4_;
	_tmp5_ = ibus_emojier_m_emoji_to_data_dict;
	_tmp6_ = text;
	_tmp7_ = g_hash_table_lookup (_tmp5_, _tmp6_);
	data = (IBusEmojiData*) _tmp7_;
	_tmp8_ = data;
	if (_tmp8_ != NULL) {
		IBusEmojiData* _tmp9_;
		const gchar* _tmp10_;
		_tmp9_ = data;
		_tmp10_ = text;
		ibus_emojier_show_emoji_description (self, _tmp9_, _tmp10_);
		_g_free0 (text);
		return;
	}
	_tmp11_ = text;
	if (g_utf8_strlen (_tmp11_, (gssize) -1) <= 1) {
		gunichar code = 0U;
		const gchar* _tmp12_;
		IBusUnicodeData* udata = NULL;
		GHashTable* _tmp13_;
		gconstpointer _tmp14_;
		IBusUnicodeData* _tmp15_;
		_tmp12_ = text;
		code = string_get_char (_tmp12_, (glong) 0);
		_tmp13_ = ibus_emojier_m_unicode_to_data_dict;
		_tmp14_ = g_hash_table_lookup (_tmp13_, (gpointer) ((gintptr) code));
		udata = (IBusUnicodeData*) _tmp14_;
		_tmp15_ = udata;
		if (_tmp15_ != NULL) {
			IBusUnicodeData* _tmp16_;
			const gchar* _tmp17_;
			_tmp16_ = udata;
			_tmp17_ = text;
			ibus_emojier_show_unicode_description (self, _tmp16_, _tmp17_);
			_g_free0 (text);
			return;
		}
	}
	_tmp18_ = g_strdup_printf (_ ("Description: %s"), _ ("None"));
	_tmp19_ = _tmp18_;
	_tmp20_ = ibus_emojier_epadded_label_box_new (_tmp19_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, NULL);
	g_object_ref_sink (_tmp20_);
	_tmp21_ = _tmp20_;
	_g_free0 (_tmp19_);
	widget = _tmp21_;
	_tmp22_ = self->priv->m_vbox;
	_tmp23_ = widget;
	gtk_container_add ((GtkContainer*) _tmp22_, (GtkWidget*) _tmp23_);
	_tmp24_ = widget;
	gtk_widget_show_all ((GtkWidget*) _tmp24_);
	_tmp25_ = text;
	ibus_emojier_show_code_point_description (self, _tmp25_);
	_g_object_unref0 (widget);
	_g_free0 (text);
}

static void
ibus_emojier_show_emoji_description (IBusEmojier* self,
                                     IBusEmojiData* data,
                                     const gchar* text)
{
	const gchar* description = NULL;
	const gchar* _tmp0_;
	GSList* annotations = NULL;
	GSList* _tmp9_;
	GSList* _tmp10_;
	GString* buff = NULL;
	GString* _tmp11_;
	gint i = 0;
	GSList* _tmp12_;
	GString* _tmp27_;
	const gchar* _tmp28_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (data != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = ibus_emoji_data_get_description (data);
	description = _tmp0_;
	{
		IBusEmojierEPaddedLabelBox* widget = NULL;
		const gchar* _tmp1_;
		gchar* _tmp2_;
		gchar* _tmp3_;
		IBusEmojierEPaddedLabelBox* _tmp4_;
		IBusEmojierEPaddedLabelBox* _tmp5_;
		GtkBox* _tmp6_;
		IBusEmojierEPaddedLabelBox* _tmp7_;
		IBusEmojierEPaddedLabelBox* _tmp8_;
		_tmp1_ = description;
		_tmp2_ = g_strdup_printf (_ ("Description: %s"), _tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = ibus_emojier_epadded_label_box_new (_tmp3_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, NULL);
		g_object_ref_sink (_tmp4_);
		_tmp5_ = _tmp4_;
		_g_free0 (_tmp3_);
		widget = _tmp5_;
		_tmp6_ = self->priv->m_vbox;
		_tmp7_ = widget;
		gtk_container_add ((GtkContainer*) _tmp6_, (GtkWidget*) _tmp7_);
		_tmp8_ = widget;
		gtk_widget_show_all ((GtkWidget*) _tmp8_);
		_g_object_unref0 (widget);
	}
	_tmp9_ = ibus_emoji_data_get_annotations (data);
	_tmp10_ = g_slist_copy_deep (_tmp9_, _g_strdup_gcopy_func, NULL);
	annotations = _tmp10_;
	_tmp11_ = g_string_new ("");
	buff = _tmp11_;
	i = 0;
	_tmp12_ = annotations;
	{
		GSList* annotation_collection = NULL;
		GSList* annotation_it = NULL;
		annotation_collection = _tmp12_;
		for (annotation_it = annotation_collection; annotation_it != NULL; annotation_it = annotation_it->next) {
			const gchar* annotation = NULL;
			annotation = (const gchar*) annotation_it->data;
			{
				gint _tmp13_;
				GString* _tmp18_;
				const gchar* _tmp19_;
				_tmp13_ = i;
				i = _tmp13_ + 1;
				if (_tmp13_ == 0) {
					GString* _tmp14_;
					const gchar* _tmp15_;
					_tmp14_ = buff;
					_tmp15_ = annotation;
					g_string_append_printf (_tmp14_, _ ("Annotations: %s"), _tmp15_);
				} else {
					GString* _tmp16_;
					const gchar* _tmp17_;
					_tmp16_ = buff;
					_tmp17_ = annotation;
					g_string_append_printf (_tmp16_, " | %s", _tmp17_);
				}
				_tmp18_ = buff;
				_tmp19_ = _tmp18_->str;
				if (g_utf8_strlen (_tmp19_, (gssize) -1) > 30) {
					IBusEmojierEPaddedLabelBox* widget = NULL;
					GString* _tmp20_;
					const gchar* _tmp21_;
					IBusEmojierEPaddedLabelBox* _tmp22_;
					GtkBox* _tmp23_;
					IBusEmojierEPaddedLabelBox* _tmp24_;
					IBusEmojierEPaddedLabelBox* _tmp25_;
					GString* _tmp26_;
					_tmp20_ = buff;
					_tmp21_ = _tmp20_->str;
					_tmp22_ = ibus_emojier_epadded_label_box_new (_tmp21_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, NULL);
					g_object_ref_sink (_tmp22_);
					widget = _tmp22_;
					_tmp23_ = self->priv->m_vbox;
					_tmp24_ = widget;
					gtk_container_add ((GtkContainer*) _tmp23_, (GtkWidget*) _tmp24_);
					_tmp25_ = widget;
					gtk_widget_show_all ((GtkWidget*) _tmp25_);
					_tmp26_ = buff;
					g_string_erase (_tmp26_, (gssize) 0, (gssize) -1);
					_g_object_unref0 (widget);
				}
			}
		}
	}
	_tmp27_ = buff;
	_tmp28_ = _tmp27_->str;
	if (g_strcmp0 (_tmp28_, "") != 0) {
		IBusEmojierEPaddedLabelBox* widget = NULL;
		GString* _tmp29_;
		const gchar* _tmp30_;
		IBusEmojierEPaddedLabelBox* _tmp31_;
		GtkBox* _tmp32_;
		IBusEmojierEPaddedLabelBox* _tmp33_;
		IBusEmojierEPaddedLabelBox* _tmp34_;
		_tmp29_ = buff;
		_tmp30_ = _tmp29_->str;
		_tmp31_ = ibus_emojier_epadded_label_box_new (_tmp30_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, NULL);
		g_object_ref_sink (_tmp31_);
		widget = _tmp31_;
		_tmp32_ = self->priv->m_vbox;
		_tmp33_ = widget;
		gtk_container_add ((GtkContainer*) _tmp32_, (GtkWidget*) _tmp33_);
		_tmp34_ = widget;
		gtk_widget_show_all ((GtkWidget*) _tmp34_);
		_g_object_unref0 (widget);
	}
	ibus_emojier_show_code_point_description (self, text);
	_g_string_free0 (buff);
	(annotations == NULL) ? NULL : (annotations = (_g_slist_free__g_free0_ (annotations), NULL));
}

static void
ibus_emojier_show_unicode_description (IBusEmojier* self,
                                       IBusUnicodeData* data,
                                       const gchar* text)
{
	const gchar* name = NULL;
	const gchar* _tmp0_;
	const gchar* alias = NULL;
	const gchar* _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (data != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = ibus_unicode_data_get_name (data);
	name = _tmp0_;
	{
		IBusEmojierEPaddedLabelBox* widget = NULL;
		gchar* _tmp1_;
		gchar* _tmp2_;
		IBusEmojierEPaddedLabelBox* _tmp3_;
		IBusEmojierEPaddedLabelBox* _tmp4_;
		GtkBox* _tmp5_;
		_tmp1_ = g_strdup_printf (_ ("Name: %s"), name);
		_tmp2_ = _tmp1_;
		_tmp3_ = ibus_emojier_epadded_label_box_new (_tmp2_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, NULL);
		g_object_ref_sink (_tmp3_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		widget = _tmp4_;
		_tmp5_ = self->priv->m_vbox;
		gtk_container_add ((GtkContainer*) _tmp5_, (GtkWidget*) widget);
		gtk_widget_show_all ((GtkWidget*) widget);
		_g_object_unref0 (widget);
	}
	_tmp6_ = ibus_unicode_data_get_alias (data);
	alias = _tmp6_;
	{
		IBusEmojierEPaddedLabelBox* widget = NULL;
		gchar* _tmp7_;
		gchar* _tmp8_;
		IBusEmojierEPaddedLabelBox* _tmp9_;
		IBusEmojierEPaddedLabelBox* _tmp10_;
		GtkBox* _tmp11_;
		_tmp7_ = g_strdup_printf (_ ("Alias: %s"), alias);
		_tmp8_ = _tmp7_;
		_tmp9_ = ibus_emojier_epadded_label_box_new (_tmp8_, GTK_ALIGN_START, IBUS_EMOJIER_TRAVEL_DIRECTION_NONE, NULL);
		g_object_ref_sink (_tmp9_);
		_tmp10_ = _tmp9_;
		_g_free0 (_tmp8_);
		widget = _tmp10_;
		_tmp11_ = self->priv->m_vbox;
		gtk_container_add ((GtkContainer*) _tmp11_, (GtkWidget*) widget);
		gtk_widget_show_all ((GtkWidget*) widget);
		_g_object_unref0 (widget);
	}
	ibus_emojier_show_code_point_description (self, text);
}

static void
ibus_emojier_hide_candidate_panel (IBusEmojier* self)
{
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	gtk_widget_hide ((GtkWidget*) self);
	self->priv->m_enter_notify_enable = TRUE;
	_tmp0_ = g_strdup ("");
	_g_free0 (self->priv->m_annotation);
	self->priv->m_annotation = _tmp0_;
	ibus_emojier_remove_all_children (self);
	if (ibus_emojier_m_show_unicode) {
		ibus_emojier_update_unicode_blocks (self);
	} else {
		ibus_emojier_update_category_list (self);
	}
}

static gboolean
__lambda29_ (IBusEmojier* self)
{
	gboolean result = FALSE;
	self->priv->m_enter_notify_enable = TRUE;
	result = FALSE;
	return result;
}

static gboolean
___lambda29__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda29_ ((IBusEmojier*) self);
	return result;
}

static void
ibus_emojier_enter_notify_disable_with_timer (IBusEmojier* self)
{
	g_return_if_fail (self != NULL);
	self->priv->m_enter_notify_enable = FALSE;
	if (self->priv->m_entry_notify_disable_id > ((guint) 0)) {
		g_source_remove (self->priv->m_entry_notify_disable_id);
	}
	self->priv->m_entry_notify_show_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 100, ___lambda29__gsource_func, g_object_ref (self), g_object_unref);
}

static void
ibus_emojier_candidate_panel_cursor_down (IBusEmojier* self)
{
	guint ncandidates = 0U;
	IBusLookupTable* _tmp0_;
	guint cursor = 0U;
	IBusLookupTable* _tmp1_;
	g_return_if_fail (self != NULL);
	ibus_emojier_enter_notify_disable_with_timer (self);
	_tmp0_ = self->priv->m_lookup_table;
	ncandidates = ibus_lookup_table_get_number_of_candidates (_tmp0_);
	_tmp1_ = self->priv->m_lookup_table;
	cursor = ibus_lookup_table_get_cursor_pos (_tmp1_);
	if ((cursor + IBUS_EMOJIER_EMOJI_GRID_PAGE) < ncandidates) {
		IBusLookupTable* _tmp2_;
		_tmp2_ = self->priv->m_lookup_table;
		ibus_lookup_table_set_cursor_pos (_tmp2_, cursor + IBUS_EMOJIER_EMOJI_GRID_PAGE);
	} else {
		if ((cursor % IBUS_EMOJIER_EMOJI_GRID_PAGE) < ncandidates) {
			IBusLookupTable* _tmp3_;
			_tmp3_ = self->priv->m_lookup_table;
			ibus_lookup_table_set_cursor_pos (_tmp3_, cursor % IBUS_EMOJIER_EMOJI_GRID_PAGE);
		} else {
			IBusLookupTable* _tmp4_;
			_tmp4_ = self->priv->m_lookup_table;
			ibus_lookup_table_set_cursor_pos (_tmp4_, (guint) 0);
		}
	}
}

static void
ibus_emojier_candidate_panel_cursor_up (IBusEmojier* self)
{
	gint ncandidates = 0;
	IBusLookupTable* _tmp0_;
	gint cursor = 0;
	IBusLookupTable* _tmp1_;
	gint highest_pos = 0;
	g_return_if_fail (self != NULL);
	ibus_emojier_enter_notify_disable_with_timer (self);
	_tmp0_ = self->priv->m_lookup_table;
	ncandidates = (gint) ibus_lookup_table_get_number_of_candidates (_tmp0_);
	_tmp1_ = self->priv->m_lookup_table;
	cursor = (gint) ibus_lookup_table_get_cursor_pos (_tmp1_);
	highest_pos = (((ncandidates - 1) / ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE)) * ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE)) + (cursor % ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE));
	if ((cursor - ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE)) >= 0) {
		IBusLookupTable* _tmp2_;
		_tmp2_ = self->priv->m_lookup_table;
		ibus_lookup_table_set_cursor_pos (_tmp2_, (guint) (cursor - ((gint) IBUS_EMOJIER_EMOJI_GRID_PAGE)));
	} else {
		if (highest_pos < ncandidates) {
			IBusLookupTable* _tmp3_;
			_tmp3_ = self->priv->m_lookup_table;
			ibus_lookup_table_set_cursor_pos (_tmp3_, (guint) highest_pos);
		} else {
			IBusLookupTable* _tmp4_;
			_tmp4_ = self->priv->m_lookup_table;
			ibus_lookup_table_set_cursor_pos (_tmp4_, (guint) 0);
		}
	}
}

static gint
ibus_emojier_get_page_num (IBusEmojier* self)
{
	GtkListBoxRow* row = NULL;
	IBusEmojierEListBox* _tmp0_;
	GtkListBoxRow* _tmp1_;
	GtkListBoxRow* _tmp2_;
	GtkAllocation alloc = {0};
	GtkAllocation _tmp3_ = {0};
	GtkListBoxRow* _tmp4_;
	GtkAllocation _tmp5_ = {0};
	GtkAdjustment* adjustment = NULL;
	IBusEmojierEScrolledWindow* _tmp6_;
	GtkAdjustment* _tmp7_;
	GtkAdjustment* _tmp8_;
	gint page_size = 0;
	GtkAdjustment* _tmp9_;
	gint page_num = 0;
	GtkAllocation _tmp10_;
	gint _tmp11_ = 0;
	GtkAllocation _tmp12_;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	if (self->priv->m_category_active_index < 0) {
		self->priv->m_category_active_index = 0;
	}
	_tmp0_ = self->priv->m_list_box;
	_tmp1_ = gtk_list_box_get_row_at_index ((GtkListBox*) _tmp0_, self->priv->m_category_active_index);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	row = _tmp2_;
	_tmp3_.x = 0;
	_tmp3_.y = 0;
	_tmp3_.width = 0;
	_tmp3_.height = 0;
	alloc = _tmp3_;
	_tmp4_ = row;
	gtk_widget_get_allocation ((GtkWidget*) _tmp4_, &_tmp5_);
	alloc = _tmp5_;
	_tmp6_ = self->priv->m_scrolled_window;
	_tmp7_ = gtk_scrolled_window_get_vadjustment ((GtkScrolledWindow*) _tmp6_);
	_tmp8_ = _g_object_ref0 (_tmp7_);
	adjustment = _tmp8_;
	_tmp9_ = adjustment;
	page_size = (gint) gtk_adjustment_get_page_size (_tmp9_);
	_tmp10_ = alloc;
	page_num = page_size / _tmp10_.height;
	_tmp12_ = alloc;
	if ((page_size % _tmp12_.height) > 0) {
		_tmp11_ = 1;
	} else {
		_tmp11_ = 0;
	}
	page_num += _tmp11_;
	result = page_num;
	_g_object_unref0 (adjustment);
	_g_object_unref0 (row);
	return result;
}

static gboolean
ibus_emojier_category_list_cursor_move (IBusEmojier* self,
                                        guint keyval)
{
	IBusEmojierEListBox* _tmp0_;
	GList* list = NULL;
	IBusEmojierEListBox* _tmp1_;
	GList* _tmp2_;
	gint length = 0;
	GList* _tmp3_;
	GtkListBoxRow* row = NULL;
	IBusEmojierEListBox* _tmp7_;
	GtkListBoxRow* _tmp8_;
	GtkListBoxRow* _tmp9_;
	GtkListBoxRow* _tmp10_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->m_list_box;
	g_return_val_if_fail (_tmp0_ != NULL, FALSE);
	_tmp1_ = self->priv->m_list_box;
	_tmp2_ = gtk_container_get_children ((GtkContainer*) _tmp1_);
	list = _tmp2_;
	_tmp3_ = list;
	length = (gint) g_list_length (_tmp3_);
	if (length == 0) {
		result = FALSE;
		(list == NULL) ? NULL : (list = (g_list_free (list), NULL));
		return result;
	}
	switch (keyval) {
		case GDK_KEY_Down:
		{
			gint _tmp4_;
			gint _tmp5_;
			self->priv->m_category_active_index = self->priv->m_category_active_index + 1;
			_tmp4_ = self->priv->m_category_active_index;
			_tmp5_ = length;
			if (_tmp4_ == _tmp5_) {
				self->priv->m_category_active_index = 0;
			}
			break;
		}
		case GDK_KEY_Up:
		{
			gint _tmp6_;
			self->priv->m_category_active_index = self->priv->m_category_active_index - 1;
			_tmp6_ = self->priv->m_category_active_index;
			if (_tmp6_ < 0) {
				self->priv->m_category_active_index = length - 1;
			}
			break;
		}
		case GDK_KEY_Home:
		{
			self->priv->m_category_active_index = 0;
			break;
		}
		case GDK_KEY_End:
		{
			self->priv->m_category_active_index = length - 1;
			break;
		}
		case GDK_KEY_Page_Down:
		{
			gint page_num = 0;
			page_num = ibus_emojier_get_page_num (self);
			if ((self->priv->m_category_active_index + 1) == length) {
				self->priv->m_category_active_index = 0;
			} else {
				if ((self->priv->m_category_active_index + page_num) >= length) {
					self->priv->m_category_active_index = length - 1;
				} else {
					self->priv->m_category_active_index = self->priv->m_category_active_index + page_num;
				}
			}
			break;
		}
		case GDK_KEY_Page_Up:
		{
			gint page_num = 0;
			page_num = ibus_emojier_get_page_num (self);
			if (self->priv->m_category_active_index == 0) {
				self->priv->m_category_active_index = length - 1;
			} else {
				if ((self->priv->m_category_active_index - page_num) < 0) {
					self->priv->m_category_active_index = 0;
				} else {
					self->priv->m_category_active_index = self->priv->m_category_active_index - page_num;
				}
			}
			break;
		}
		default:
		break;
	}
	_tmp7_ = self->priv->m_list_box;
	_tmp8_ = gtk_list_box_get_selected_row ((GtkListBox*) _tmp7_);
	_tmp9_ = _g_object_ref0 (_tmp8_);
	row = _tmp9_;
	_tmp10_ = row;
	if (_tmp10_ != NULL) {
		IBusEmojierEListBox* _tmp11_;
		GtkListBoxRow* _tmp12_;
		_tmp11_ = self->priv->m_list_box;
		_tmp12_ = row;
		gtk_list_box_unselect_row ((GtkListBox*) _tmp11_, _tmp12_);
	}
	ibus_emojier_clamp_page (self);
	result = TRUE;
	_g_object_unref0 (row);
	(list == NULL) ? NULL : (list = (g_list_free (list), NULL));
	return result;
}

gboolean
ibus_emojier_has_variants (IBusEmojier* self,
                           guint index,
                           gboolean need_commit_signal)
{
	IBusLookupTable* _tmp0_;
	gchar* text = NULL;
	IBusLookupTable* _tmp1_;
	IBusText* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	GSList* emojis = NULL;
	GHashTable* _tmp5_;
	const gchar* _tmp6_;
	gconstpointer _tmp7_;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->m_lookup_table;
	if (index >= ibus_lookup_table_get_number_of_candidates (_tmp0_)) {
		result = FALSE;
		return result;
	}
	_tmp1_ = self->priv->m_lookup_table;
	_tmp2_ = ibus_lookup_table_get_candidate (_tmp1_, index);
	_tmp3_ = _tmp2_->text;
	_tmp4_ = g_strdup (_tmp3_);
	text = _tmp4_;
	_tmp5_ = ibus_emojier_m_emoji_to_emoji_variants_dict;
	_tmp6_ = text;
	_tmp7_ = g_hash_table_lookup (_tmp5_, _tmp6_);
	emojis = (GSList*) _tmp7_;
	if (ibus_emojier_m_show_emoji_variant) {
		GSList* _tmp10_;
		_tmp10_ = emojis;
		_tmp9_ = _tmp10_ != NULL;
	} else {
		_tmp9_ = FALSE;
	}
	if (_tmp9_) {
		_tmp8_ = self->priv->m_backward_index < 0;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		GSList* _tmp11_;
		_tmp11_ = emojis;
		ibus_emojier_show_emoji_variants (self, _tmp11_);
		result = TRUE;
		_g_free0 (text);
		return result;
	}
	_tmp12_ = text;
	_tmp13_ = g_strdup (_tmp12_);
	_g_free0 (self->priv->m_result);
	self->priv->m_result = _tmp13_;
	if (need_commit_signal) {
		const gchar* _tmp14_;
		_tmp14_ = text;
		g_signal_emit (self, ibus_emojier_signals[IBUS_EMOJIER_COMMIT_TEXT_SIGNAL], 0, _tmp14_);
	}
	result = FALSE;
	_g_free0 (text);
	return result;
}

gboolean
ibus_emojier_key_press_cursor_horizontal (IBusEmojier* self,
                                          guint keyval,
                                          guint modifiers)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (keyval == GDK_KEY_Left) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = keyval == GDK_KEY_Right;
	}
	_vala_assert (_tmp0_, "keyval == Gdk.Key.Left || keyval == Gdk.Key.Right");
	if (self->priv->m_candidate_panel_mode) {
		IBusLookupTable* _tmp2_;
		_tmp2_ = self->priv->m_lookup_table;
		_tmp1_ = ibus_lookup_table_get_number_of_candidates (_tmp2_) > ((guint) 0);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		ibus_emojier_enter_notify_disable_with_timer (self);
		if (keyval == GDK_KEY_Left) {
			IBusLookupTable* _tmp3_;
			_tmp3_ = self->priv->m_lookup_table;
			ibus_lookup_table_cursor_up (_tmp3_);
		} else {
			if (keyval == GDK_KEY_Right) {
				IBusLookupTable* _tmp4_;
				_tmp4_ = self->priv->m_lookup_table;
				ibus_lookup_table_cursor_down (_tmp4_);
			}
		}
	} else {
		if (keyval == GDK_KEY_Left) {
			keyval = GDK_KEY_Up;
		} else {
			if (keyval == GDK_KEY_Right) {
				keyval = GDK_KEY_Down;
			}
		}
		result = ibus_emojier_category_list_cursor_move (self, keyval);
		return result;
	}
	result = TRUE;
	return result;
}

gboolean
ibus_emojier_key_press_cursor_vertical (IBusEmojier* self,
                                        guint keyval,
                                        guint modifiers)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (keyval == GDK_KEY_Down) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = keyval == GDK_KEY_Up;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = keyval == GDK_KEY_Page_Down;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = keyval == GDK_KEY_Page_Up;
	}
	_vala_assert (_tmp0_, "keyval == Gdk.Key.Down || keyval == Gdk.Key.Up ||                 keyval == Gdk.Key.Page_Down || keyval == Gdk.Key.Page_Up");
	if ((modifiers & GDK_SHIFT_MASK) != ((guint) 0)) {
		if (keyval == GDK_KEY_Down) {
			keyval = GDK_KEY_Page_Down;
		} else {
			if (keyval == GDK_KEY_Up) {
				keyval = GDK_KEY_Page_Up;
			}
		}
	}
	if (self->priv->m_candidate_panel_is_visible) {
		_tmp4_ = TRUE;
	} else {
		const gchar* _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		_tmp5_ = self->priv->m_annotation;
		_tmp6_ = strlen (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp4_ = _tmp7_ > 0;
	}
	if (_tmp4_) {
		IBusLookupTable* _tmp8_;
		_tmp8_ = self->priv->m_lookup_table;
		_tmp3_ = ibus_lookup_table_get_number_of_candidates (_tmp8_) > ((guint) 0);
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		switch (keyval) {
			case GDK_KEY_Down:
			{
				ibus_emojier_candidate_panel_cursor_down (self);
				break;
			}
			case GDK_KEY_Up:
			{
				ibus_emojier_candidate_panel_cursor_up (self);
				break;
			}
			case GDK_KEY_Page_Down:
			{
				IBusLookupTable* _tmp9_;
				ibus_emojier_enter_notify_disable_with_timer (self);
				_tmp9_ = self->priv->m_lookup_table;
				ibus_lookup_table_page_down (_tmp9_);
				break;
			}
			case GDK_KEY_Page_Up:
			{
				IBusLookupTable* _tmp10_;
				ibus_emojier_enter_notify_disable_with_timer (self);
				_tmp10_ = self->priv->m_lookup_table;
				ibus_lookup_table_page_up (_tmp10_);
				break;
			}
			default:
			break;
		}
	} else {
		result = ibus_emojier_category_list_cursor_move (self, keyval);
		return result;
	}
	result = TRUE;
	return result;
}

gboolean
ibus_emojier_key_press_cursor_home_end (IBusEmojier* self,
                                        guint keyval,
                                        guint modifiers)
{
	gboolean _tmp0_ = FALSE;
	guint ncandidates = 0U;
	IBusLookupTable* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (keyval == GDK_KEY_Home) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = keyval == GDK_KEY_End;
	}
	_vala_assert (_tmp0_, "keyval == Gdk.Key.Home || keyval == Gdk.Key.End");
	_tmp1_ = self->priv->m_lookup_table;
	ncandidates = ibus_lookup_table_get_number_of_candidates (_tmp1_);
	if (self->priv->m_candidate_panel_mode) {
		_tmp2_ = ncandidates > ((guint) 0);
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		ibus_emojier_enter_notify_disable_with_timer (self);
		if (keyval == GDK_KEY_Home) {
			IBusLookupTable* _tmp3_;
			_tmp3_ = self->priv->m_lookup_table;
			ibus_lookup_table_set_cursor_pos (_tmp3_, (guint) 0);
		} else {
			if (keyval == GDK_KEY_End) {
				IBusLookupTable* _tmp4_;
				_tmp4_ = self->priv->m_lookup_table;
				ibus_lookup_table_set_cursor_pos (_tmp4_, ncandidates - 1);
			}
		}
		result = TRUE;
		return result;
	}
	result = ibus_emojier_category_list_cursor_move (self, keyval);
	return result;
}

gboolean
ibus_emojier_key_press_escape (IBusEmojier* self)
{
	gboolean _tmp5_ = FALSE;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (ibus_emojier_m_show_unicode) {
		if (!self->priv->m_candidate_panel_is_visible) {
			ibus_emojier_m_show_unicode = FALSE;
			self->priv->m_category_active_index = -1;
		}
		ibus_emojier_hide_candidate_panel (self);
		result = TRUE;
		return result;
	} else {
		gboolean _tmp0_ = FALSE;
		if (self->priv->m_backward_index >= 0) {
			const gchar* _tmp1_;
			_tmp1_ = self->priv->m_backward;
			_tmp0_ = _tmp1_ != NULL;
		} else {
			_tmp0_ = FALSE;
		}
		if (_tmp0_) {
			const gchar* _tmp2_;
			_tmp2_ = self->priv->m_backward;
			ibus_emojier_show_emoji_for_category (self, _tmp2_);
			result = TRUE;
			return result;
		} else {
			gboolean _tmp3_ = FALSE;
			if (self->priv->m_candidate_panel_is_visible) {
				const gchar* _tmp4_;
				_tmp4_ = self->priv->m_backward;
				_tmp3_ = _tmp4_ != NULL;
			} else {
				_tmp3_ = FALSE;
			}
			if (_tmp3_) {
				ibus_emojier_hide_candidate_panel (self);
				result = TRUE;
				return result;
			}
		}
	}
	gtk_widget_hide ((GtkWidget*) self);
	if (self->priv->m_candidate_panel_mode) {
		IBusLookupTable* _tmp6_;
		_tmp6_ = self->priv->m_lookup_table;
		_tmp5_ = ibus_lookup_table_get_number_of_candidates (_tmp6_) > ((guint) 0);
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		ibus_emojier_remove_all_children (self);
	}
	g_signal_emit (self, ibus_emojier_signals[IBUS_EMOJIER_CANCEL_SIGNAL], 0);
	result = FALSE;
	return result;
}

gboolean
ibus_emojier_key_press_enter (IBusEmojier* self,
                              gboolean need_commit_signal)
{
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->priv->m_candidate_panel_is_visible) {
		guint index = 0U;
		IBusLookupTable* _tmp0_;
		_tmp0_ = self->priv->m_lookup_table;
		index = ibus_lookup_table_get_cursor_pos (_tmp0_);
		result = ibus_emojier_has_variants (self, index, need_commit_signal);
		return result;
	} else {
		if (self->priv->m_category_active_index >= 0) {
			GtkListBoxRow* gtkrow = NULL;
			IBusEmojierEListBox* _tmp1_;
			GtkListBoxRow* _tmp2_;
			GtkListBoxRow* _tmp3_;
			IBusEmojierEBoxRow* row = NULL;
			GtkListBoxRow* _tmp4_;
			IBusEmojierEBoxRow* _tmp5_;
			_tmp1_ = self->priv->m_list_box;
			_tmp2_ = gtk_list_box_get_selected_row ((GtkListBox*) _tmp1_);
			_tmp3_ = _g_object_ref0 (_tmp2_);
			gtkrow = _tmp3_;
			_tmp4_ = gtkrow;
			_tmp5_ = _g_object_ref0 (IBUS_EMOJIER_IS_EBOX_ROW (_tmp4_) ? ((IBusEmojierEBoxRow*) _tmp4_) : NULL);
			row = _tmp5_;
			if (ibus_emojier_m_show_unicode) {
				IBusEmojierEBoxRow* _tmp6_;
				const gchar* _tmp7_;
				const gchar* _tmp8_;
				_tmp6_ = row;
				_tmp7_ = ibus_emojier_ebox_row_get_text (_tmp6_);
				_tmp8_ = _tmp7_;
				ibus_emojier_show_unicode_for_block (self, _tmp8_);
			} else {
				IBusEmojierEBoxRow* _tmp9_;
				const gchar* _tmp10_;
				const gchar* _tmp11_;
				_tmp9_ = row;
				_tmp10_ = ibus_emojier_ebox_row_get_text (_tmp9_);
				_tmp11_ = _tmp10_;
				ibus_emojier_show_emoji_for_category (self, _tmp11_);
			}
			_g_object_unref0 (row);
			_g_object_unref0 (gtkrow);
		}
	}
	result = TRUE;
	return result;
}

static void
ibus_emojier_get_monitor_geometry (IBusEmojier* self,
                                   GdkRectangle* result)
{
	GdkRectangle monitor_area = {0};
	GdkRectangle _tmp0_ = {0};
	GdkMonitor* monitor = NULL;
	GdkDisplay* _tmp1_;
	GdkRectangle _tmp2_;
	GdkRectangle _tmp3_;
	GdkMonitor* _tmp4_;
	GdkMonitor* _tmp5_;
	GdkRectangle _tmp6_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_.x = 0;
	monitor_area = _tmp0_;
	_tmp1_ = gdk_display_get_default ();
	_tmp2_ = self->priv->m_cursor_location;
	_tmp3_ = self->priv->m_cursor_location;
	_tmp4_ = gdk_display_get_monitor_at_point (_tmp1_, _tmp2_.x, _tmp3_.y);
	_tmp5_ = _g_object_ref0 (_tmp4_);
	monitor = _tmp5_;
	gdk_monitor_get_geometry (monitor, &_tmp6_);
	monitor_area = _tmp6_;
	*result = monitor_area;
	_g_object_unref0 (monitor);
	return;
}

static gboolean
___lambda14_ (IBusEmojier* self)
{
	gboolean result = FALSE;
	self->priv->m_redraw_window_id = (guint) 0;
	gtk_widget_show_all ((GtkWidget*) self);
	result = FALSE;
	return result;
}

static gboolean
____lambda14__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda14_ ((IBusEmojier*) self);
	return result;
}

static void
ibus_emojier_adjust_window_position (IBusEmojier* self)
{
	GdkPoint cursor_right_bottom = {0};
	GdkRectangle _tmp0_;
	GdkRectangle _tmp1_;
	GdkRectangle _tmp2_;
	GdkRectangle _tmp3_;
	GdkPoint _tmp4_ = {0};
	GtkAllocation allocation = {0};
	GtkAllocation _tmp5_ = {0};
	GdkPoint window_right_bottom = {0};
	GdkPoint _tmp6_;
	GtkAllocation _tmp7_;
	GdkPoint _tmp8_;
	GtkAllocation _tmp9_;
	GdkPoint _tmp10_ = {0};
	GdkRectangle monitor_area = {0};
	GdkRectangle _tmp11_ = {0};
	gint monitor_right = 0;
	GdkRectangle _tmp12_;
	GdkRectangle _tmp13_;
	gint monitor_bottom = 0;
	GdkRectangle _tmp14_;
	GdkRectangle _tmp15_;
	gint x = 0;
	gint y = 0;
	GdkPoint _tmp16_;
	gboolean changed = FALSE;
	IBusLookupTable* _tmp19_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_cursor_location;
	_tmp1_ = self->priv->m_cursor_location;
	_tmp2_ = self->priv->m_cursor_location;
	_tmp3_ = self->priv->m_cursor_location;
	_tmp4_.x = _tmp0_.x + _tmp1_.width;
	_tmp4_.y = _tmp2_.y + _tmp3_.height;
	cursor_right_bottom = _tmp4_;
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp5_);
	allocation = _tmp5_;
	_tmp6_ = cursor_right_bottom;
	_tmp7_ = allocation;
	_tmp8_ = cursor_right_bottom;
	_tmp9_ = allocation;
	_tmp10_.x = _tmp6_.x + _tmp7_.width;
	_tmp10_.y = _tmp8_.y + _tmp9_.height;
	window_right_bottom = _tmp10_;
	ibus_emojier_get_monitor_geometry (self, &_tmp11_);
	monitor_area = _tmp11_;
	_tmp12_ = monitor_area;
	_tmp13_ = monitor_area;
	monitor_right = _tmp12_.x + _tmp13_.width;
	_tmp14_ = monitor_area;
	_tmp15_ = monitor_area;
	monitor_bottom = _tmp14_.y + _tmp15_.height;
	_tmp16_ = window_right_bottom;
	if (_tmp16_.x > monitor_right) {
		GtkAllocation _tmp17_;
		_tmp17_ = allocation;
		x = monitor_right - _tmp17_.width;
	} else {
		GdkPoint _tmp18_;
		_tmp18_ = cursor_right_bottom;
		x = _tmp18_.x;
	}
	if (x < 0) {
		x = 0;
	}
	changed = FALSE;
	_tmp19_ = self->priv->m_lookup_table;
	if (ibus_lookup_table_get_cursor_pos (_tmp19_) != ((guint) 1)) {
		if (self->priv->m_is_up_side_down) {
			GdkRectangle _tmp20_;
			GtkAllocation _tmp21_;
			_tmp20_ = self->priv->m_cursor_location;
			_tmp21_ = allocation;
			y = _tmp20_.y - _tmp21_.height;
		} else {
			GdkPoint _tmp22_;
			_tmp22_ = cursor_right_bottom;
			y = _tmp22_.y;
		}
	} else {
		GdkPoint _tmp23_;
		_tmp23_ = window_right_bottom;
		if (_tmp23_.y > monitor_bottom) {
			GdkRectangle _tmp24_;
			GtkAllocation _tmp25_;
			const gchar* _tmp26_;
			_tmp24_ = self->priv->m_cursor_location;
			_tmp25_ = allocation;
			y = _tmp24_.y - _tmp25_.height;
			_tmp26_ = self->priv->m_input_context_path;
			if (g_strcmp0 (_tmp26_, "") == 0) {
				changed = self->priv->m_is_up_side_down == FALSE;
				self->priv->m_is_up_side_down = TRUE;
			} else {
				changed = self->priv->m_is_up_side_down == TRUE;
				self->priv->m_is_up_side_down = FALSE;
			}
		} else {
			GdkPoint _tmp27_;
			_tmp27_ = cursor_right_bottom;
			y = _tmp27_.y;
			changed = self->priv->m_is_up_side_down == TRUE;
			self->priv->m_is_up_side_down = FALSE;
		}
	}
	if (y < 0) {
		y = 0;
	}
	gtk_window_move ((GtkWindow*) self, x, y);
	if (changed) {
		if (self->priv->m_redraw_window_id > ((guint) 0)) {
			g_source_remove (self->priv->m_redraw_window_id);
		}
		self->priv->m_redraw_window_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 100, ____lambda14__gsource_func, g_object_ref (self), g_object_unref);
	}
}

static void
ibus_emojier_check_action_variant_cb (IBusEmojier* self,
                                      GSimpleAction* action,
                                      GVariant* parameter)
{
	GVariant* _tmp0_;
	GVariant* _tmp1_;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	_tmp0_ = g_action_get_state ((GAction*) action);
	_tmp1_ = _tmp0_;
	ibus_emojier_m_show_emoji_variant = !g_variant_get_boolean (_tmp1_);
	_g_variant_unref0 (_tmp1_);
	_tmp2_ = g_variant_new_boolean (ibus_emojier_m_show_emoji_variant);
	g_variant_ref_sink (_tmp2_);
	_tmp3_ = _tmp2_;
	g_simple_action_set_state (action, _tmp3_);
	_g_variant_unref0 (_tmp3_);
	if (self->priv->m_candidate_panel_is_visible) {
		gtk_widget_queue_draw ((GtkWidget*) self);
	}
}

static void
ibus_emojier_action_close_cb (IBusEmojier* self,
                              GSimpleAction* action,
                              GVariant* parameter)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	g_signal_emit (self, ibus_emojier_signals[IBUS_EMOJIER_CANDIDATE_CLICKED_SIGNAL], 0, (guint) 0, IBUS_EMOJIER_BUTTON_CLOSE_BUTTON, (guint) 0);
}

void
ibus_emojier_update_favorite_emoji_dict (void)
{
	gboolean _tmp0_ = FALSE;
	GHashTable* _tmp1_;
	_tmp1_ = ibus_emojier_m_emoji_to_data_dict;
	if (_tmp1_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		GHashTable* _tmp2_;
		_tmp2_ = ibus_emojier_m_annotation_to_emojis_dict;
		_tmp0_ = _tmp2_ == NULL;
	}
	if (_tmp0_) {
		return;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gchar** _tmp5_;
				gint _tmp5__length1;
				gchar* favorite = NULL;
				gchar** _tmp6_;
				gint _tmp6__length1;
				const gchar* _tmp7_;
				gchar* _tmp8_;
				gchar* annotation = NULL;
				gchar* _tmp9_;
				gchar** _tmp10_;
				gint _tmp10__length1;
				const gchar* _tmp14_;
				IBusEmojiData* data = NULL;
				GHashTable* _tmp15_;
				const gchar* _tmp16_;
				gconstpointer _tmp17_;
				IBusEmojiData* _tmp18_;
				GSList* emojis = NULL;
				GHashTable* _tmp49_;
				const gchar* _tmp50_;
				gconstpointer _tmp51_;
				GSList* _tmp52_;
				const gchar* _tmp53_;
				GCompareFunc _tmp54_;
				GSList* _tmp55_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = ibus_emojier_m_favorites;
				_tmp5__length1 = ibus_emojier_m_favorites_length1;
				if (!(i < _tmp5__length1)) {
					break;
				}
				_tmp6_ = ibus_emojier_m_favorites;
				_tmp6__length1 = ibus_emojier_m_favorites_length1;
				_tmp7_ = _tmp6_[i];
				_tmp8_ = g_strdup (_tmp7_);
				favorite = _tmp8_;
				_tmp9_ = g_strdup ("");
				annotation = _tmp9_;
				_tmp10_ = ibus_emojier_m_favorite_annotations;
				_tmp10__length1 = ibus_emojier_m_favorite_annotations_length1;
				if (i < _tmp10__length1) {
					gchar** _tmp11_;
					gint _tmp11__length1;
					const gchar* _tmp12_;
					gchar* _tmp13_;
					_tmp11_ = ibus_emojier_m_favorite_annotations;
					_tmp11__length1 = ibus_emojier_m_favorite_annotations_length1;
					_tmp12_ = _tmp11_[i];
					_tmp13_ = g_strdup (_tmp12_);
					_g_free0 (annotation);
					annotation = _tmp13_;
				}
				_tmp14_ = annotation;
				if (g_strcmp0 (_tmp14_, "") == 0) {
					_g_free0 (annotation);
					_g_free0 (favorite);
					continue;
				}
				_tmp15_ = ibus_emojier_m_emoji_to_data_dict;
				_tmp16_ = favorite;
				_tmp17_ = g_hash_table_lookup (_tmp15_, _tmp16_);
				data = (IBusEmojiData*) _tmp17_;
				_tmp18_ = data;
				if (_tmp18_ == NULL) {
					GSList* new_annotations = NULL;
					const gchar* _tmp19_;
					gchar* _tmp20_;
					IBusEmojiData* new_data = NULL;
					const gchar* _tmp21_;
					gchar* _tmp22_;
					gchar* _tmp23_;
					GSList* _tmp24_;
					const gchar* _tmp25_;
					gchar* _tmp26_;
					gchar* _tmp27_;
					GObject* _tmp28_;
					GObject* _tmp29_;
					IBusEmojiData* _tmp30_;
					IBusEmojiData* _tmp31_;
					GHashTable* _tmp32_;
					const gchar* _tmp33_;
					gchar* _tmp34_;
					IBusEmojiData* _tmp35_;
					IBusEmojiData* _tmp36_;
					new_annotations = NULL;
					_tmp19_ = annotation;
					_tmp20_ = g_strdup (_tmp19_);
					new_annotations = g_slist_append (new_annotations, _tmp20_);
					_tmp21_ = favorite;
					_tmp22_ = g_strdup (_tmp21_);
					_tmp23_ = _tmp22_;
					_tmp24_ = new_annotations;
					_tmp25_ = annotation;
					_tmp26_ = g_strdup (_tmp25_);
					_tmp27_ = _tmp26_;
					_tmp28_ = g_object_new (ibus_emoji_data_get_type (), "emoji", _tmp23_, "annotations", _tmp24_, "description", _tmp27_, NULL);
					_tmp29_ = G_IS_INITIALLY_UNOWNED (_tmp28_) ? g_object_ref_sink (_tmp28_) : _tmp28_;
					_tmp30_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp29_, ibus_emoji_data_get_type ()) ? ((IBusEmojiData*) _tmp29_) : NULL;
					if (_tmp30_ == NULL) {
						_g_object_unref0 (_tmp29_);
					}
					_tmp31_ = _tmp30_;
					_g_free0 (_tmp27_);
					_g_free0 (_tmp23_);
					new_data = _tmp31_;
					_tmp32_ = ibus_emojier_m_emoji_to_data_dict;
					_tmp33_ = favorite;
					_tmp34_ = g_strdup (_tmp33_);
					_tmp35_ = new_data;
					_tmp36_ = _g_object_ref0 (_tmp35_);
					g_hash_table_insert (_tmp32_, _tmp34_, _tmp36_);
					_g_object_unref0 (new_data);
					(new_annotations == NULL) ? NULL : (new_annotations = (_g_slist_free__g_free0_ (new_annotations), NULL));
				} else {
					GSList* annotations = NULL;
					IBusEmojiData* _tmp37_;
					GSList* _tmp38_;
					GSList* _tmp39_;
					GSList* _tmp40_;
					const gchar* _tmp41_;
					GCompareFunc _tmp42_;
					GSList* _tmp43_;
					_tmp37_ = data;
					_tmp38_ = ibus_emoji_data_get_annotations (_tmp37_);
					_tmp39_ = g_slist_copy_deep (_tmp38_, _g_strdup_gcopy_func, NULL);
					annotations = _tmp39_;
					_tmp40_ = annotations;
					_tmp41_ = annotation;
					_tmp42_ = ((GCompareFunc) g_strcmp0);
					_tmp43_ = g_slist_find_custom (_tmp40_, _tmp41_, _tmp42_);
					if (_tmp43_ == NULL) {
						const gchar* _tmp44_;
						gchar* _tmp45_;
						IBusEmojiData* _tmp46_;
						GSList* _tmp47_;
						GSList* _tmp48_;
						_tmp44_ = annotation;
						_tmp45_ = g_strdup (_tmp44_);
						annotations = g_slist_append (annotations, _tmp45_);
						_tmp46_ = data;
						_tmp47_ = annotations;
						_tmp48_ = g_slist_copy_deep (_tmp47_, _g_strdup_gcopy_func, NULL);
						ibus_emoji_data_set_annotations (_tmp46_, _tmp48_);
					}
					(annotations == NULL) ? NULL : (annotations = (_g_slist_free__g_free0_ (annotations), NULL));
				}
				_tmp49_ = ibus_emojier_m_annotation_to_emojis_dict;
				_tmp50_ = annotation;
				_tmp51_ = g_hash_table_lookup (_tmp49_, _tmp50_);
				emojis = (GSList*) _tmp51_;
				_tmp52_ = emojis;
				_tmp53_ = favorite;
				_tmp54_ = ((GCompareFunc) g_strcmp0);
				_tmp55_ = g_slist_find_custom (_tmp52_, _tmp53_, _tmp54_);
				if (_tmp55_ == NULL) {
					const gchar* _tmp56_;
					gchar* _tmp57_;
					GHashTable* _tmp58_;
					const gchar* _tmp59_;
					gchar* _tmp60_;
					GSList* _tmp61_;
					GSList* _tmp62_;
					_tmp56_ = favorite;
					_tmp57_ = g_strdup (_tmp56_);
					emojis = g_slist_append (emojis, _tmp57_);
					_tmp58_ = ibus_emojier_m_annotation_to_emojis_dict;
					_tmp59_ = annotation;
					_tmp60_ = g_strdup (_tmp59_);
					_tmp61_ = emojis;
					_tmp62_ = g_slist_copy_deep (_tmp61_, _g_strdup_gcopy_func, NULL);
					g_hash_table_replace (_tmp58_, _tmp60_, _tmp62_);
				}
				_g_free0 (annotation);
				_g_free0 (favorite);
			}
		}
	}
}

void
ibus_emojier_set_annotation (IBusEmojier* self,
                             const gchar* annotation)
{
	gchar* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (annotation != NULL);
	_tmp0_ = g_strdup (annotation);
	_g_free0 (self->priv->m_annotation);
	self->priv->m_annotation = _tmp0_;
	ibus_emojier_remove_all_children (self);
	_tmp1_ = strlen (annotation);
	_tmp2_ = _tmp1_;
	if (_tmp2_ > 0) {
		ibus_emojier_update_candidate_window (self);
	} else {
		if (ibus_emojier_m_show_unicode) {
			ibus_emojier_update_unicode_blocks (self);
		} else {
			ibus_emojier_update_category_list (self);
		}
	}
}

IBusLookupTable*
ibus_emojier_get_one_dimension_lookup_table (IBusEmojier* self)
{
	IBusLookupTable* lookup_table = NULL;
	IBusLookupTable* _tmp0_;
	guint i = 0U;
	IBusLookupTable* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = ibus_lookup_table_new (IBUS_EMOJIER_EMOJI_GRID_PAGE, (guint) 0, TRUE, TRUE);
	g_object_ref_sink (_tmp0_);
	lookup_table = _tmp0_;
	i = (guint) 0;
	{
		gboolean _tmp1_ = FALSE;
		_tmp1_ = TRUE;
		while (TRUE) {
			IBusLookupTable* _tmp3_;
			IBusText* text = NULL;
			IBusText* _tmp4_;
			IBusText* _tmp5_;
			IBusLookupTable* _tmp6_;
			IBusText* _tmp7_;
			IBusLookupTable* _tmp8_;
			IBusText* _tmp9_;
			if (!_tmp1_) {
				guint _tmp2_;
				_tmp2_ = i;
				i = _tmp2_ + 1;
			}
			_tmp1_ = FALSE;
			_tmp3_ = self->priv->m_lookup_table;
			if (!(i < ibus_lookup_table_get_number_of_candidates (_tmp3_))) {
				break;
			}
			_tmp4_ = ibus_text_new_from_string ("");
			g_object_ref_sink (_tmp4_);
			text = _tmp4_;
			_tmp5_ = text;
			_tmp6_ = self->priv->m_lookup_table;
			_tmp7_ = ibus_lookup_table_get_candidate (_tmp6_, i);
			G_TYPE_INSTANCE_GET_CLASS ((IBusSerializable*) _tmp5_, ibus_serializable_get_type (), IBusSerializableClass)->copy ((IBusSerializable*) _tmp5_, (IBusSerializable*) _tmp7_);
			_tmp8_ = lookup_table;
			_tmp9_ = text;
			ibus_lookup_table_append_candidate (_tmp8_, _tmp9_);
			_g_object_unref0 (text);
		}
	}
	if (i > ((guint) 0)) {
		IBusLookupTable* _tmp10_;
		IBusLookupTable* _tmp11_;
		_tmp10_ = lookup_table;
		_tmp11_ = self->priv->m_lookup_table;
		ibus_lookup_table_set_cursor_pos (_tmp10_, ibus_lookup_table_get_cursor_pos (_tmp11_));
	}
	result = lookup_table;
	return result;
}

guint
ibus_emojier_get_number_of_candidates (IBusEmojier* self)
{
	IBusLookupTable* _tmp0_;
	guint result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->m_lookup_table;
	result = ibus_lookup_table_get_number_of_candidates (_tmp0_);
	return result;
}

guint
ibus_emojier_get_cursor_pos (IBusEmojier* self)
{
	IBusLookupTable* _tmp0_;
	guint result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->m_lookup_table;
	result = ibus_lookup_table_get_cursor_pos (_tmp0_);
	return result;
}

void
ibus_emojier_set_cursor_pos (IBusEmojier* self,
                             guint cursor_pos)
{
	IBusLookupTable* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_lookup_table;
	ibus_lookup_table_set_cursor_pos (_tmp0_, cursor_pos);
}

gchar*
ibus_emojier_get_current_candidate (IBusEmojier* self)
{
	guint cursor = 0U;
	IBusLookupTable* _tmp1_;
	IBusLookupTable* _tmp2_;
	IBusText* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (!self->priv->m_candidate_panel_mode) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("");
		result = _tmp0_;
		return result;
	}
	_tmp1_ = self->priv->m_lookup_table;
	cursor = ibus_lookup_table_get_cursor_pos (_tmp1_);
	_tmp2_ = self->priv->m_lookup_table;
	_tmp3_ = ibus_lookup_table_get_candidate (_tmp2_, cursor);
	_tmp4_ = _tmp3_->text;
	_tmp5_ = g_strdup (_tmp4_);
	result = _tmp5_;
	return result;
}

IBusText*
ibus_emojier_get_title_text (IBusEmojier* self)
{
	gchar* language = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	guint ncandidates = 0U;
	gchar* main_title = NULL;
	gchar* _tmp5_;
	IBusText* text = NULL;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	IBusText* _tmp11_;
	IBusText* _tmp12_;
	gint char_count = 0;
	IBusText* _tmp13_;
	const gchar* _tmp14_;
	gint start_index = 0;
	const gchar* title = NULL;
	IBusText* _tmp15_;
	const gchar* _tmp16_;
	IBusText* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = ibus_emojier_m_current_lang_id;
	_tmp1_ = ibus_get_language_name (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup (_ (_tmp2_));
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	language = _tmp4_;
	ncandidates = ibus_emojier_get_number_of_candidates (self);
	_tmp5_ = g_strdup (_ ("Emoji Choice"));
	main_title = _tmp5_;
	if (ibus_emojier_m_show_unicode) {
		gchar* _tmp6_;
		_tmp6_ = g_strdup (_ ("Unicode Choice"));
		_g_free0 (main_title);
		main_title = _tmp6_;
	}
	_tmp7_ = main_title;
	_tmp8_ = language;
	_tmp9_ = g_strdup_printf ("%s (%s) (%u / %u)", _tmp7_, _tmp8_, ibus_emojier_get_cursor_pos (self) + 1, ncandidates);
	_tmp10_ = _tmp9_;
	_tmp11_ = ibus_text_new_from_string (_tmp10_);
	g_object_ref_sink (_tmp11_);
	_tmp12_ = _tmp11_;
	_g_free0 (_tmp10_);
	text = _tmp12_;
	_tmp13_ = text;
	_tmp14_ = _tmp13_->text;
	char_count = g_utf8_strlen (_tmp14_, (gssize) -1);
	start_index = -1;
	_tmp15_ = text;
	_tmp16_ = _tmp15_->text;
	title = _tmp16_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp17_ = FALSE;
			_tmp17_ = TRUE;
			while (TRUE) {
				const gchar* _tmp19_;
				const gchar* _tmp20_;
				const gchar* _tmp21_;
				const gchar* _tmp22_;
				if (!_tmp17_) {
					gint _tmp18_;
					_tmp18_ = i;
					i = _tmp18_ + 1;
				}
				_tmp17_ = FALSE;
				if (!(i < char_count)) {
					break;
				}
				_tmp19_ = title;
				_tmp20_ = language;
				if (g_str_has_prefix (_tmp19_, _tmp20_)) {
					start_index = i;
					break;
				}
				_tmp21_ = title;
				_tmp22_ = g_utf8_next_char (_tmp21_);
				title = _tmp22_;
			}
		}
	}
	if (start_index >= 0) {
		IBusAttribute* attr = NULL;
		const gchar* _tmp23_;
		IBusAttribute* _tmp24_;
		IBusAttrList* attrs = NULL;
		IBusAttrList* _tmp25_;
		IBusAttrList* _tmp26_;
		IBusAttribute* _tmp27_;
		IBusText* _tmp28_;
		IBusAttrList* _tmp29_;
		_tmp23_ = language;
		_tmp24_ = ibus_attribute_new ((guint) IBUS_ATTR_TYPE_FOREGROUND, (guint) 0x808080, (guint) start_index, (guint) (start_index + g_utf8_strlen (_tmp23_, (gssize) -1)));
		g_object_ref_sink (_tmp24_);
		attr = _tmp24_;
		_tmp25_ = ibus_attr_list_new ();
		g_object_ref_sink (_tmp25_);
		attrs = _tmp25_;
		_tmp26_ = attrs;
		_tmp27_ = attr;
		ibus_attr_list_append (_tmp26_, _tmp27_);
		_tmp28_ = text;
		_tmp29_ = attrs;
		ibus_text_set_attributes (_tmp28_, _tmp29_);
		_g_object_unref0 (attrs);
		_g_object_unref0 (attr);
	}
	result = text;
	_g_free0 (main_title);
	_g_free0 (language);
	return result;
}

static void
ibus_emojier_real_show_all (GtkWidget* base)
{
	IBusEmojier * self;
	self = (IBusEmojier*) base;
	GTK_WIDGET_CLASS (ibus_emojier_parent_class)->show_all ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_window_get_type (), GtkApplicationWindow));
	if (self->priv->m_candidate_panel_mode) {
		ibus_emojier_show_candidate_panel (self);
	} else {
		if (ibus_emojier_m_show_unicode) {
			ibus_emojier_show_unicode_blocks (self);
		} else {
			ibus_emojier_show_category_list (self);
		}
	}
}

static void
ibus_emojier_real_hide (GtkWidget* base)
{
	IBusEmojier * self;
	self = (IBusEmojier*) base;
	GTK_WIDGET_CLASS (ibus_emojier_parent_class)->hide ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_application_window_get_type (), GtkApplicationWindow));
	self->priv->m_candidate_panel_is_visible = FALSE;
	if (self->priv->m_redraw_window_id > ((guint) 0)) {
		g_source_remove (self->priv->m_redraw_window_id);
		self->priv->m_redraw_window_id = (guint) 0;
	}
	if (self->priv->m_unicode_progress_id > ((guint) 0)) {
		g_source_remove (self->priv->m_unicode_progress_id);
		self->priv->m_unicode_progress_id = (guint) 0;
	}
}

static gboolean
ibus_emojier_real_key_press_event (GtkWidget* base,
                                   GdkEventKey* event)
{
	IBusEmojier * self;
	guint keyval = 0U;
	guint modifiers = 0U;
	GdkModifierType _tmp0_;
	gboolean result = FALSE;
	self = (IBusEmojier*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	keyval = event->keyval;
	_tmp0_ = event->state;
	modifiers = (guint) _tmp0_;
	switch (keyval) {
		case GDK_KEY_Escape:
		{
			if (ibus_emojier_key_press_escape (self)) {
				gtk_widget_show_all ((GtkWidget*) self);
			}
			result = TRUE;
			return result;
		}
		case GDK_KEY_Return:
		case GDK_KEY_KP_Enter:
		{
			if (ibus_emojier_key_press_enter (self, TRUE)) {
				gtk_widget_show_all ((GtkWidget*) self);
			} else {
				gtk_widget_hide ((GtkWidget*) self);
			}
			result = TRUE;
			return result;
		}
		case GDK_KEY_space:
		case GDK_KEY_KP_Space:
		{
			if (self->priv->m_candidate_panel_is_visible) {
				IBusLookupTable* _tmp1_;
				ibus_emojier_enter_notify_disable_with_timer (self);
				_tmp1_ = self->priv->m_lookup_table;
				ibus_lookup_table_cursor_down (_tmp1_);
				ibus_emojier_show_candidate_panel (self);
			} else {
				ibus_emojier_category_list_cursor_move (self, GDK_KEY_Down);
				gtk_widget_show_all ((GtkWidget*) self);
			}
			result = TRUE;
			return result;
		}
		case GDK_KEY_Right:
		case GDK_KEY_KP_Right:
		{
			ibus_emojier_key_press_cursor_horizontal (self, GDK_KEY_Right, modifiers);
			gtk_widget_show_all ((GtkWidget*) self);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Left:
		case GDK_KEY_KP_Left:
		{
			ibus_emojier_key_press_cursor_horizontal (self, GDK_KEY_Left, modifiers);
			gtk_widget_show_all ((GtkWidget*) self);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Down:
		case GDK_KEY_KP_Down:
		{
			ibus_emojier_key_press_cursor_vertical (self, GDK_KEY_Down, modifiers);
			gtk_widget_show_all ((GtkWidget*) self);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Up:
		case GDK_KEY_KP_Up:
		{
			ibus_emojier_key_press_cursor_vertical (self, GDK_KEY_Up, modifiers);
			gtk_widget_show_all ((GtkWidget*) self);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Page_Down:
		case GDK_KEY_KP_Page_Down:
		{
			ibus_emojier_key_press_cursor_vertical (self, GDK_KEY_Page_Down, modifiers);
			gtk_widget_show_all ((GtkWidget*) self);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Page_Up:
		case GDK_KEY_KP_Page_Up:
		{
			ibus_emojier_key_press_cursor_vertical (self, GDK_KEY_Page_Up, modifiers);
			gtk_widget_show_all ((GtkWidget*) self);
			result = TRUE;
			return result;
		}
		case GDK_KEY_Home:
		case GDK_KEY_KP_Home:
		{
			ibus_emojier_key_press_cursor_home_end (self, GDK_KEY_Home, modifiers);
			gtk_widget_show_all ((GtkWidget*) self);
			result = TRUE;
			return result;
		}
		case GDK_KEY_End:
		case GDK_KEY_KP_End:
		{
			ibus_emojier_key_press_cursor_home_end (self, GDK_KEY_End, modifiers);
			gtk_widget_show_all ((GtkWidget*) self);
			result = TRUE;
			return result;
		}
		default:
		break;
	}
	if ((modifiers & GDK_CONTROL_MASK) != ((guint) 0)) {
		switch (keyval) {
			case GDK_KEY_f:
			{
				ibus_emojier_key_press_cursor_horizontal (self, GDK_KEY_Right, modifiers);
				gtk_widget_show_all ((GtkWidget*) self);
				result = TRUE;
				return result;
			}
			case GDK_KEY_b:
			{
				ibus_emojier_key_press_cursor_horizontal (self, GDK_KEY_Left, modifiers);
				gtk_widget_show_all ((GtkWidget*) self);
				result = TRUE;
				return result;
			}
			case GDK_KEY_n:
			case GDK_KEY_N:
			{
				ibus_emojier_key_press_cursor_vertical (self, GDK_KEY_Down, modifiers);
				gtk_widget_show_all ((GtkWidget*) self);
				result = TRUE;
				return result;
			}
			case GDK_KEY_p:
			case GDK_KEY_P:
			{
				ibus_emojier_key_press_cursor_vertical (self, GDK_KEY_Up, modifiers);
				gtk_widget_show_all ((GtkWidget*) self);
				result = TRUE;
				return result;
			}
			case GDK_KEY_h:
			{
				ibus_emojier_key_press_cursor_home_end (self, GDK_KEY_Home, modifiers);
				gtk_widget_show_all ((GtkWidget*) self);
				result = TRUE;
				return result;
			}
			case GDK_KEY_e:
			{
				ibus_emojier_key_press_cursor_home_end (self, GDK_KEY_End, modifiers);
				gtk_widget_show_all ((GtkWidget*) self);
				result = TRUE;
				return result;
			}
			case GDK_KEY_C:
			case GDK_KEY_c:
			{
				if ((modifiers & GDK_SHIFT_MASK) != ((guint) 0)) {
					if (self->priv->m_candidate_panel_is_visible) {
						guint index = 0U;
						IBusLookupTable* _tmp2_;
						gchar* text = NULL;
						IBusLookupTable* _tmp3_;
						IBusText* _tmp4_;
						const gchar* _tmp5_;
						gchar* _tmp6_;
						GtkClipboard* clipboard = NULL;
						GtkClipboard* _tmp7_;
						GtkClipboard* _tmp8_;
						GtkClipboard* _tmp9_;
						const gchar* _tmp10_;
						GtkClipboard* _tmp11_;
						_tmp2_ = self->priv->m_lookup_table;
						index = ibus_lookup_table_get_cursor_pos (_tmp2_);
						_tmp3_ = self->priv->m_lookup_table;
						_tmp4_ = ibus_lookup_table_get_candidate (_tmp3_, index);
						_tmp5_ = _tmp4_->text;
						_tmp6_ = g_strdup (_tmp5_);
						text = _tmp6_;
						_tmp7_ = gtk_clipboard_get (GDK_SELECTION_CLIPBOARD);
						_tmp8_ = _g_object_ref0 (_tmp7_);
						clipboard = _tmp8_;
						_tmp9_ = clipboard;
						_tmp10_ = text;
						gtk_clipboard_set_text (_tmp9_, _tmp10_, -1);
						_tmp11_ = clipboard;
						gtk_clipboard_store (_tmp11_);
						result = TRUE;
						_g_object_unref0 (clipboard);
						_g_free0 (text);
						return result;
					}
				}
				break;
			}
			default:
			break;
		}
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}

gboolean
ibus_emojier_is_running (IBusEmojier* self)
{
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->m_is_running;
	return result;
}

gchar*
ibus_emojier_get_input_context_path (IBusEmojier* self)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->m_input_context_path;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}

void
ibus_emojier_set_input_context_path (IBusEmojier* self,
                                     const gchar* input_context_path)
{
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (input_context_path != NULL);
	_tmp0_ = g_strdup (input_context_path);
	_g_free0 (self->priv->m_input_context_path);
	self->priv->m_input_context_path = _tmp0_;
	if (g_strcmp0 (input_context_path, "") == 0) {
		gchar* _tmp1_;
		_tmp1_ = g_strdup (_ ("" "Failed to get the current text application. " "Please re-focus your application. E.g. Press Esc key " "several times to release the emoji typing mode, " "click your desktop and click your text application again."));
		_g_free0 (ibus_emojier_m_warning_message);
		ibus_emojier_m_warning_message = _tmp1_;
	} else {
		gchar* _tmp2_;
		_tmp2_ = g_strdup ("");
		_g_free0 (ibus_emojier_m_warning_message);
		ibus_emojier_m_warning_message = _tmp2_;
	}
}

gchar*
ibus_emojier_get_selected_string (IBusEmojier* self)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->m_result;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}

static void
ibus_emojier_reset_window_mode (IBusEmojier* self)
{
	g_return_if_fail (self != NULL);
	self->priv->m_backward_index = -1;
	_g_free0 (self->priv->m_backward);
	self->priv->m_backward = NULL;
	self->priv->m_candidate_panel_is_visible = FALSE;
	self->priv->m_candidate_panel_mode = FALSE;
}

void
ibus_emojier_reset (IBusEmojier* self)
{
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	ibus_emojier_reset_window_mode (self);
	_tmp0_ = g_strdup ("");
	_g_free0 (self->priv->m_input_context_path);
	self->priv->m_input_context_path = _tmp0_;
	_g_free0 (self->priv->m_result);
	self->priv->m_result = NULL;
	self->priv->m_category_active_index = -1;
	ibus_emojier_m_show_unicode = FALSE;
}

void
ibus_emojier_present_centralize (IBusEmojier* self,
                                 GdkEvent* event)
{
	GtkAllocation allocation = {0};
	GtkAllocation _tmp0_ = {0};
	GdkRectangle monitor_area = {0};
	GdkRectangle work_area = {0};
	GdkDisplay* display = NULL;
	GdkDisplay* _tmp1_;
	GdkDisplay* _tmp2_;
	GdkMonitor* monitor = NULL;
	GdkDisplay* _tmp3_;
	GdkWindow* _tmp4_;
	GdkMonitor* _tmp5_;
	GdkMonitor* _tmp6_;
	GdkMonitor* _tmp7_;
	GdkRectangle _tmp8_ = {0};
	GdkMonitor* _tmp9_;
	GdkRectangle _tmp10_ = {0};
	gint x = 0;
	GdkRectangle _tmp11_;
	GdkRectangle _tmp12_;
	GtkAllocation _tmp13_;
	gint y = 0;
	GdkRectangle _tmp14_;
	GdkRectangle _tmp15_;
	GtkAllocation _tmp16_;
	GdkRectangle _tmp17_;
	guint32 timestamp = 0U;
	g_return_if_fail (self != NULL);
	g_return_if_fail (event != NULL);
	gtk_widget_get_allocation ((GtkWidget*) self, &_tmp0_);
	allocation = _tmp0_;
	_tmp1_ = gdk_display_get_default ();
	_tmp2_ = _g_object_ref0 (_tmp1_);
	display = _tmp2_;
	_tmp3_ = display;
	_tmp4_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp5_ = gdk_display_get_monitor_at_window (_tmp3_, _tmp4_);
	_tmp6_ = _g_object_ref0 (_tmp5_);
	monitor = _tmp6_;
	_tmp7_ = monitor;
	gdk_monitor_get_geometry (_tmp7_, &_tmp8_);
	monitor_area = _tmp8_;
	_tmp9_ = monitor;
	gdk_monitor_get_workarea (_tmp9_, &_tmp10_);
	work_area = _tmp10_;
	_tmp11_ = monitor_area;
	_tmp12_ = monitor_area;
	_tmp13_ = allocation;
	x = ((_tmp11_.x + _tmp12_.width) - _tmp13_.width) / 2;
	_tmp14_ = monitor_area;
	_tmp15_ = monitor_area;
	_tmp16_ = allocation;
	y = ((_tmp14_.y + _tmp15_.height) - _tmp16_.height) / 2;
	_tmp17_ = work_area;
	if (_tmp17_.y < y) {
		GdkRectangle _tmp18_;
		_tmp18_ = work_area;
		y = _tmp18_.y;
	}
	gtk_window_move ((GtkWindow*) self, x, y);
	timestamp = gdk_event_get_time (event);
	gtk_window_present_with_time ((GtkWindow*) self, timestamp);
	_g_object_unref0 (monitor);
	_g_object_unref0 (display);
}

static gboolean
_cairo_rectangle_int_equal (const cairo_rectangle_int_t * s1,
                            const cairo_rectangle_int_t * s2)
{
	if (s1 == s2) {
		return TRUE;
	}
	if (s1 == NULL) {
		return FALSE;
	}
	if (s2 == NULL) {
		return FALSE;
	}
	if (s1->x != s2->x) {
		return FALSE;
	}
	if (s1->y != s2->y) {
		return FALSE;
	}
	if (s1->width != s2->width) {
		return FALSE;
	}
	if (s1->height != s2->height) {
		return FALSE;
	}
	return TRUE;
}

void
ibus_emojier_set_cursor_location (IBusEmojier* self,
                                  gint x,
                                  gint y,
                                  gint width,
                                  gint height)
{
	GdkRectangle location = {0};
	GdkRectangle _tmp0_ = {0};
	GdkRectangle _tmp1_;
	GdkRectangle _tmp2_;
	GdkRectangle _tmp3_;
	g_return_if_fail (self != NULL);
	memset (&_tmp0_, 0, sizeof (GdkRectangle));
	_tmp0_.x = x;
	_tmp0_.y = y;
	_tmp0_.width = width;
	_tmp0_.height = height;
	location = _tmp0_;
	_tmp1_ = self->priv->m_cursor_location;
	_tmp2_ = location;
	if (_cairo_rectangle_int_equal (&_tmp1_, &_tmp2_) == TRUE) {
		return;
	}
	_tmp3_ = location;
	self->priv->m_cursor_location = _tmp3_;
}

gboolean
ibus_emojier_is_candidate_panel_mode (IBusEmojier* self)
{
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->m_candidate_panel_mode;
	return result;
}

gboolean
ibus_emojier_has_loaded_emoji_dict (void)
{
	GHashTable* _tmp0_;
	GList* keys = NULL;
	GHashTable* _tmp1_;
	GList* _tmp2_;
	GList* _tmp3_;
	gboolean result = FALSE;
	_tmp0_ = ibus_emojier_m_emoji_to_data_dict;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = ibus_emojier_m_emoji_to_data_dict;
	_tmp2_ = g_hash_table_get_keys (_tmp1_);
	keys = _tmp2_;
	_tmp3_ = keys;
	if (g_list_length (_tmp3_) == ((guint) 0)) {
		result = FALSE;
		(keys == NULL) ? NULL : (keys = (g_list_free (keys), NULL));
		return result;
	}
	result = TRUE;
	(keys == NULL) ? NULL : (keys = (g_list_free (keys), NULL));
	return result;
}

void
ibus_emojier_set_annotation_lang (const gchar* lang)
{
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	if (lang == NULL) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (lang, "") == 0;
	}
	if (_tmp0_) {
		lang = "en";
	}
	_tmp1_ = ibus_emojier_m_current_lang_id;
	if (g_strcmp0 (_tmp1_, lang) == 0) {
		return;
	}
	_tmp2_ = g_strdup (lang);
	_g_free0 (ibus_emojier_m_current_lang_id);
	ibus_emojier_m_current_lang_id = _tmp2_;
	ibus_emojier_reload_emoji_dict ();
}

gchar*
ibus_emojier_get_annotation_lang (void)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* result = NULL;
	_tmp0_ = ibus_emojier_m_current_lang_id;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}

static void
_vala_PangoFontDescription_free (PangoFontDescription* self)
{
	g_boxed_free (pango_font_description_get_type (), self);
}

void
ibus_emojier_set_emoji_font (const gchar* emoji_font)
{
	gboolean _tmp0_ = FALSE;
	PangoFontDescription* font_desc = NULL;
	PangoFontDescription* _tmp1_;
	gchar* font_family = NULL;
	PangoFontDescription* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_;
	gint font_size = 0;
	PangoFontDescription* _tmp8_;
	if (emoji_font != NULL) {
		_tmp0_ = g_strcmp0 (emoji_font, "") != 0;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_if_fail (_tmp0_);
	_tmp1_ = pango_font_description_from_string (emoji_font);
	font_desc = _tmp1_;
	_tmp2_ = font_desc;
	_tmp3_ = pango_font_description_get_family (_tmp2_);
	_tmp4_ = g_strdup (_tmp3_);
	font_family = _tmp4_;
	_tmp5_ = font_family;
	if (_tmp5_ != NULL) {
		const gchar* _tmp6_;
		gchar* _tmp7_;
		_tmp6_ = font_family;
		_tmp7_ = g_strdup (_tmp6_);
		_g_free0 (ibus_emojier_m_emoji_font_family);
		ibus_emojier_m_emoji_font_family = _tmp7_;
		ibus_emojier_m_emoji_font_changed = TRUE;
	}
	_tmp8_ = font_desc;
	font_size = pango_font_description_get_size (_tmp8_) / PANGO_SCALE;
	if (font_size != 0) {
		ibus_emojier_m_emoji_font_size = font_size;
		ibus_emojier_m_emoji_font_changed = TRUE;
	}
	_g_free0 (font_family);
	__vala_PangoFontDescription_free0 (font_desc);
}

void
ibus_emojier_set_partial_match (gboolean has_partial_match)
{
	ibus_emojier_m_has_partial_match = has_partial_match;
}

void
ibus_emojier_set_partial_match_length (gint length)
{
	if (length < 1) {
		return;
	}
	ibus_emojier_m_partial_match_length = (guint) length;
}

void
ibus_emojier_set_partial_match_condition (gint condition)
{
	if (condition < 0) {
		return;
	}
	ibus_emojier_m_partial_match_condition = (guint) condition;
}

static void
_vala_array_add9 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static void
_vala_array_add10 (gchar** * array,
                   gint* length,
                   gint* size,
                   gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

void
ibus_emojier_set_favorites (gchar** unowned_favorites,
                            gint unowned_favorites_length1,
                            gchar** unowned_favorite_annotations,
                            gint unowned_favorite_annotations_length1)
{
	gchar** _tmp0_;
	gchar** _tmp1_;
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	ibus_emojier_m_favorites = (_vala_array_free (ibus_emojier_m_favorites, ibus_emojier_m_favorites_length1, (GDestroyNotify) g_free), NULL);
	ibus_emojier_m_favorites = _tmp0_;
	ibus_emojier_m_favorites_length1 = 0;
	_ibus_emojier_m_favorites_size_ = ibus_emojier_m_favorites_length1;
	_tmp1_ = g_new0 (gchar*, 0 + 1);
	ibus_emojier_m_favorite_annotations = (_vala_array_free (ibus_emojier_m_favorite_annotations, ibus_emojier_m_favorite_annotations_length1, (GDestroyNotify) g_free), NULL);
	ibus_emojier_m_favorite_annotations = _tmp1_;
	ibus_emojier_m_favorite_annotations_length1 = 0;
	_ibus_emojier_m_favorite_annotations_size_ = ibus_emojier_m_favorite_annotations_length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gchar* favorite = NULL;
				const gchar* _tmp4_;
				gchar* _tmp5_;
				const gchar* _tmp6_;
				const gchar* _tmp7_;
				gchar* _tmp8_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				if (!(i < unowned_favorites_length1)) {
					break;
				}
				_tmp4_ = unowned_favorites[i];
				_tmp5_ = g_strdup (_tmp4_);
				favorite = _tmp5_;
				_tmp6_ = favorite;
				g_return_if_fail (_tmp6_ != NULL);
				_tmp7_ = favorite;
				_tmp8_ = g_strdup (_tmp7_);
				_vala_array_add9 (&ibus_emojier_m_favorites, &ibus_emojier_m_favorites_length1, &_ibus_emojier_m_favorites_size_, _tmp8_);
				_g_free0 (favorite);
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp9_ = FALSE;
			_tmp9_ = TRUE;
			while (TRUE) {
				gchar* favorite_annotation = NULL;
				const gchar* _tmp11_;
				gchar* _tmp12_;
				const gchar* _tmp13_;
				const gchar* _tmp14_;
				gchar* _tmp15_;
				if (!_tmp9_) {
					gint _tmp10_;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				if (!(i < unowned_favorite_annotations_length1)) {
					break;
				}
				_tmp11_ = unowned_favorite_annotations[i];
				_tmp12_ = g_strdup (_tmp11_);
				favorite_annotation = _tmp12_;
				_tmp13_ = favorite_annotation;
				g_return_if_fail (_tmp13_ != NULL);
				_tmp14_ = favorite_annotation;
				_tmp15_ = g_strdup (_tmp14_);
				_vala_array_add10 (&ibus_emojier_m_favorite_annotations, &ibus_emojier_m_favorite_annotations_length1, &_ibus_emojier_m_favorite_annotations_size_, _tmp15_);
				_g_free0 (favorite_annotation);
			}
		}
	}
	ibus_emojier_update_favorite_emoji_dict ();
}

static GObject*
ibus_emojier_get_load_progress_object (void)
{
	IBusEmojierLoadProgressObject* _tmp0_;
	IBusEmojierLoadProgressObject* _tmp2_;
	GObject* _tmp3_;
	GObject* result = NULL;
	_tmp0_ = ibus_emojier_m_unicode_progress_object;
	if (_tmp0_ == NULL) {
		IBusEmojierLoadProgressObject* _tmp1_;
		_tmp1_ = ibus_emojier_load_progress_object_new ();
		_g_object_unref0 (ibus_emojier_m_unicode_progress_object);
		ibus_emojier_m_unicode_progress_object = _tmp1_;
	}
	_tmp2_ = ibus_emojier_m_unicode_progress_object;
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, G_TYPE_OBJECT) ? ((GObject*) _tmp2_) : NULL);
	result = _tmp3_;
	return result;
}

void
ibus_emojier_load_unicode_dict (void)
{
	GSList* _tmp0_;
	GHashTable* _tmp1_;
	_tmp0_ = ibus_emojier_m_unicode_block_list;
	if (g_slist_length (_tmp0_) == ((guint) 0)) {
		ibus_emojier_make_unicode_block_dict ();
	}
	_tmp1_ = ibus_emojier_m_name_to_unicodes_dict;
	if (g_hash_table_size (_tmp1_) == ((guint) 0)) {
		GObject* _tmp2_;
		GObject* _tmp3_;
		_tmp2_ = ibus_emojier_get_load_progress_object ();
		_tmp3_ = _tmp2_;
		ibus_emojier_make_unicode_name_dict (_tmp3_);
		_g_object_unref0 (_tmp3_);
	}
}

static void
g_cclosure_user_marshal_VOID__UINT_UINT_UINT (GClosure * closure,
                                              GValue * return_value,
                                              guint n_param_values,
                                              const GValue * param_values,
                                              gpointer invocation_hint,
                                              gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__UINT_UINT_UINT) (gpointer data1, guint arg_1, guint arg_2, guint arg_3, gpointer data2);
	register GMarshalFunc_VOID__UINT_UINT_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UINT_UINT_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uint (param_values + 1), g_value_get_uint (param_values + 2), g_value_get_uint (param_values + 3), data2);
}

static gboolean
__lambda10_ (IBusEmojierEListBox* self,
             GdkEventMotion* e)
{
	GdkEventMotion* pe = NULL;
	GdkEventMotion* _tmp0_;
	gboolean _tmp1_ = FALSE;
	GdkEventMotion* _tmp2_;
	GdkEventMotion* _tmp4_;
	GdkEventMotion* _tmp5_;
	GtkListBoxRow* row = NULL;
	GtkListBoxRow* _tmp6_;
	GtkListBoxRow* _tmp7_;
	GtkListBoxRow* _tmp8_;
	gboolean result = FALSE;
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = __vala_GdkEventMotion_copy0 (e);
	pe = _tmp0_;
	_tmp2_ = pe;
	if (ibus_emojier_m_mouse_x == _tmp2_->x_root) {
		GdkEventMotion* _tmp3_;
		_tmp3_ = pe;
		_tmp1_ = ibus_emojier_m_mouse_y == _tmp3_->y_root;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		result = FALSE;
		__vala_GdkEventMotion_free0 (pe);
		return result;
	}
	_tmp4_ = pe;
	ibus_emojier_m_mouse_x = _tmp4_->x_root;
	_tmp5_ = pe;
	ibus_emojier_m_mouse_y = _tmp5_->y_root;
	_tmp6_ = gtk_list_box_get_row_at_y ((GtkListBox*) self, (gint) e->y);
	_tmp7_ = _g_object_ref0 (_tmp6_);
	row = _tmp7_;
	_tmp8_ = row;
	if (_tmp8_ != NULL) {
		GtkListBoxRow* _tmp9_;
		_tmp9_ = row;
		gtk_list_box_select_row ((GtkListBox*) self, _tmp9_);
	}
	result = FALSE;
	_g_object_unref0 (row);
	__vala_GdkEventMotion_free0 (pe);
	return result;
}

static gboolean
___lambda10__gtk_widget_motion_notify_event (GtkWidget* _sender,
                                             GdkEventMotion* event,
                                             gpointer self)
{
	gboolean result;
	result = __lambda10_ ((IBusEmojierEListBox*) self, event);
	return result;
}

static gboolean
__lambda11_ (IBusEmojierEListBox* self,
             GdkEventCrossing* e)
{
	gboolean result = FALSE;
	g_return_val_if_fail (e != NULL, FALSE);
	result = TRUE;
	return result;
}

static gboolean
___lambda11__gtk_widget_enter_notify_event (GtkWidget* _sender,
                                            GdkEventCrossing* event,
                                            gpointer self)
{
	gboolean result;
	result = __lambda11_ ((IBusEmojierEListBox*) self, event);
	return result;
}

static IBusEmojierEListBox*
ibus_emojier_elist_box_construct (GType object_type)
{
	IBusEmojierEListBox * self = NULL;
	self = (IBusEmojierEListBox*) g_object_new (object_type, "vexpand", TRUE, "halign", GTK_ALIGN_FILL, "valign", GTK_ALIGN_FILL, NULL);
	g_signal_connect_object ((GtkWidget*) self, "motion-notify-event", (GCallback) ___lambda10__gtk_widget_motion_notify_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "enter-notify-event", (GCallback) ___lambda11__gtk_widget_enter_notify_event, self, 0);
	return self;
}

static IBusEmojierEListBox*
ibus_emojier_elist_box_new (void)
{
	return ibus_emojier_elist_box_construct (IBUS_EMOJIER_TYPE_ELIST_BOX);
}

static void
ibus_emojier_elist_box_class_init (IBusEmojierEListBoxClass * klass,
                                   gpointer klass_data)
{
	ibus_emojier_elist_box_parent_class = g_type_class_peek_parent (klass);
}

static void
ibus_emojier_elist_box_instance_init (IBusEmojierEListBox * self,
                                      gpointer klass)
{
}

static GType
ibus_emojier_elist_box_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEListBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_elist_box_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEListBox), 0, (GInstanceInitFunc) ibus_emojier_elist_box_instance_init, NULL };
	GType ibus_emojier_elist_box_type_id;
	ibus_emojier_elist_box_type_id = g_type_register_static (gtk_list_box_get_type (), "IBusEmojierEListBox", &g_define_type_info, 0);
	return ibus_emojier_elist_box_type_id;
}

static GType
ibus_emojier_elist_box_get_type (void)
{
	static volatile gsize ibus_emojier_elist_box_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_elist_box_type_id__volatile)) {
		GType ibus_emojier_elist_box_type_id;
		ibus_emojier_elist_box_type_id = ibus_emojier_elist_box_get_type_once ();
		g_once_init_leave (&ibus_emojier_elist_box_type_id__volatile, ibus_emojier_elist_box_type_id);
	}
	return ibus_emojier_elist_box_type_id__volatile;
}

static inline gpointer
ibus_emojier_ebox_row_get_instance_private (IBusEmojierEBoxRow* self)
{
	return G_STRUCT_MEMBER_P (self, IBusEmojierEBoxRow_private_offset);
}

static IBusEmojierEBoxRow*
ibus_emojier_ebox_row_construct (GType object_type,
                                 const gchar* text)
{
	IBusEmojierEBoxRow * self = NULL;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierEBoxRow*) g_object_new (object_type, NULL);
	ibus_emojier_ebox_row_set_text (self, text);
	return self;
}

static IBusEmojierEBoxRow*
ibus_emojier_ebox_row_new (const gchar* text)
{
	return ibus_emojier_ebox_row_construct (IBUS_EMOJIER_TYPE_EBOX_ROW, text);
}

static const gchar*
ibus_emojier_ebox_row_get_text (IBusEmojierEBoxRow* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_text;
	result = _tmp0_;
	return result;
}

static void
ibus_emojier_ebox_row_set_text (IBusEmojierEBoxRow* self,
                                const gchar* value)
{
	gchar* old_value;
	g_return_if_fail (self != NULL);
	old_value = ibus_emojier_ebox_row_get_text (self);
	if (g_strcmp0 (value, old_value) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_text);
		self->priv->_text = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, ibus_emojier_ebox_row_properties[IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY]);
	}
}

static void
ibus_emojier_ebox_row_class_init (IBusEmojierEBoxRowClass * klass,
                                  gpointer klass_data)
{
	ibus_emojier_ebox_row_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &IBusEmojierEBoxRow_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_ibus_emojier_ebox_row_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_ibus_emojier_ebox_row_set_property;
	G_OBJECT_CLASS (klass)->finalize = ibus_emojier_ebox_row_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY, ibus_emojier_ebox_row_properties[IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY] = g_param_spec_string ("text", "text", "text", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
}

static void
ibus_emojier_ebox_row_instance_init (IBusEmojierEBoxRow * self,
                                     gpointer klass)
{
	self->priv = ibus_emojier_ebox_row_get_instance_private (self);
}

static void
ibus_emojier_ebox_row_finalize (GObject * obj)
{
	IBusEmojierEBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRow);
	_g_free0 (self->priv->_text);
	G_OBJECT_CLASS (ibus_emojier_ebox_row_parent_class)->finalize (obj);
}

static GType
ibus_emojier_ebox_row_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEBoxRowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_ebox_row_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEBoxRow), 0, (GInstanceInitFunc) ibus_emojier_ebox_row_instance_init, NULL };
	GType ibus_emojier_ebox_row_type_id;
	ibus_emojier_ebox_row_type_id = g_type_register_static (gtk_list_box_row_get_type (), "IBusEmojierEBoxRow", &g_define_type_info, 0);
	IBusEmojierEBoxRow_private_offset = g_type_add_instance_private (ibus_emojier_ebox_row_type_id, sizeof (IBusEmojierEBoxRowPrivate));
	return ibus_emojier_ebox_row_type_id;
}

static GType
ibus_emojier_ebox_row_get_type (void)
{
	static volatile gsize ibus_emojier_ebox_row_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_ebox_row_type_id__volatile)) {
		GType ibus_emojier_ebox_row_type_id;
		ibus_emojier_ebox_row_type_id = ibus_emojier_ebox_row_get_type_once ();
		g_once_init_leave (&ibus_emojier_ebox_row_type_id__volatile, ibus_emojier_ebox_row_type_id);
	}
	return ibus_emojier_ebox_row_type_id__volatile;
}

static void
_vala_ibus_emojier_ebox_row_get_property (GObject * object,
                                          guint property_id,
                                          GValue * value,
                                          GParamSpec * pspec)
{
	IBusEmojierEBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRow);
	switch (property_id) {
		case IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY:
		g_value_set_string (value, ibus_emojier_ebox_row_get_text (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_ibus_emojier_ebox_row_set_property (GObject * object,
                                          guint property_id,
                                          const GValue * value,
                                          GParamSpec * pspec)
{
	IBusEmojierEBoxRow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, IBUS_EMOJIER_TYPE_EBOX_ROW, IBusEmojierEBoxRow);
	switch (property_id) {
		case IBUS_EMOJIER_EBOX_ROW_TEXT_PROPERTY:
		ibus_emojier_ebox_row_set_text (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static IBusEmojierEScrolledWindow*
ibus_emojier_escrolled_window_construct (GType object_type,
                                         GtkAdjustment* hadjustment,
                                         GtkAdjustment* vadjustment)
{
	IBusEmojierEScrolledWindow * self = NULL;
	self = (IBusEmojierEScrolledWindow*) g_object_new (object_type, "hscrollbar-policy", GTK_POLICY_NEVER, "vscrollbar-policy", GTK_POLICY_NEVER, "shadow-type", GTK_SHADOW_IN, "margin-start", 6, "margin-end", 6, "margin-top", 6, "margin-bottom", 6, NULL);
	if (hadjustment != NULL) {
		gtk_scrolled_window_set_hadjustment ((GtkScrolledWindow*) self, hadjustment);
	}
	if (vadjustment != NULL) {
		gtk_scrolled_window_set_hadjustment ((GtkScrolledWindow*) self, vadjustment);
	}
	return self;
}

static IBusEmojierEScrolledWindow*
ibus_emojier_escrolled_window_new (GtkAdjustment* hadjustment,
                                   GtkAdjustment* vadjustment)
{
	return ibus_emojier_escrolled_window_construct (IBUS_EMOJIER_TYPE_ESCROLLED_WINDOW, hadjustment, vadjustment);
}

static void
ibus_emojier_escrolled_window_class_init (IBusEmojierEScrolledWindowClass * klass,
                                          gpointer klass_data)
{
	ibus_emojier_escrolled_window_parent_class = g_type_class_peek_parent (klass);
}

static void
ibus_emojier_escrolled_window_instance_init (IBusEmojierEScrolledWindow * self,
                                             gpointer klass)
{
}

static GType
ibus_emojier_escrolled_window_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEScrolledWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_escrolled_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEScrolledWindow), 0, (GInstanceInitFunc) ibus_emojier_escrolled_window_instance_init, NULL };
	GType ibus_emojier_escrolled_window_type_id;
	ibus_emojier_escrolled_window_type_id = g_type_register_static (gtk_scrolled_window_get_type (), "IBusEmojierEScrolledWindow", &g_define_type_info, 0);
	return ibus_emojier_escrolled_window_type_id;
}

static GType
ibus_emojier_escrolled_window_get_type (void)
{
	static volatile gsize ibus_emojier_escrolled_window_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_escrolled_window_type_id__volatile)) {
		GType ibus_emojier_escrolled_window_type_id;
		ibus_emojier_escrolled_window_type_id = ibus_emojier_escrolled_window_get_type_once ();
		g_once_init_leave (&ibus_emojier_escrolled_window_type_id__volatile, ibus_emojier_escrolled_window_type_id);
	}
	return ibus_emojier_escrolled_window_type_id__volatile;
}

static IBusEmojierEGrid*
ibus_emojier_egrid_construct (GType object_type)
{
	IBusEmojierEGrid * self = NULL;
	self = (IBusEmojierEGrid*) g_object_new (object_type, "row-homogeneous", FALSE, "vexpand", TRUE, "halign", GTK_ALIGN_FILL, "valign", GTK_ALIGN_FILL, "row-spacing", 5, "column-spacing", 5, "border-width", 2, NULL);
	return self;
}

static IBusEmojierEGrid*
ibus_emojier_egrid_new (void)
{
	return ibus_emojier_egrid_construct (IBUS_EMOJIER_TYPE_EGRID);
}

static void
ibus_emojier_egrid_class_init (IBusEmojierEGridClass * klass,
                               gpointer klass_data)
{
	ibus_emojier_egrid_parent_class = g_type_class_peek_parent (klass);
}

static void
ibus_emojier_egrid_instance_init (IBusEmojierEGrid * self,
                                  gpointer klass)
{
}

static GType
ibus_emojier_egrid_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEGridClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_egrid_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEGrid), 0, (GInstanceInitFunc) ibus_emojier_egrid_instance_init, NULL };
	GType ibus_emojier_egrid_type_id;
	ibus_emojier_egrid_type_id = g_type_register_static (gtk_grid_get_type (), "IBusEmojierEGrid", &g_define_type_info, 0);
	return ibus_emojier_egrid_type_id;
}

static GType
ibus_emojier_egrid_get_type (void)
{
	static volatile gsize ibus_emojier_egrid_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_egrid_type_id__volatile)) {
		GType ibus_emojier_egrid_type_id;
		ibus_emojier_egrid_type_id = ibus_emojier_egrid_get_type_once ();
		g_once_init_leave (&ibus_emojier_egrid_type_id__volatile, ibus_emojier_egrid_type_id);
	}
	return ibus_emojier_egrid_type_id__volatile;
}

static inline gpointer
ibus_emojier_ewhite_label_get_instance_private (IBusEmojierEWhiteLabel* self)
{
	return G_STRUCT_MEMBER_P (self, IBusEmojierEWhiteLabel_private_offset);
}

static IBusEmojierEWhiteLabel*
ibus_emojier_ewhite_label_construct (GType object_type,
                                     const gchar* text)
{
	IBusEmojierEWhiteLabel * self = NULL;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierEWhiteLabel*) g_object_new (object_type, "name", "IBusEmojierWhiteLabel", NULL);
	gtk_label_set_label ((GtkLabel*) self, text);
	return self;
}

static IBusEmojierEWhiteLabel*
ibus_emojier_ewhite_label_new (const gchar* text)
{
	return ibus_emojier_ewhite_label_construct (IBUS_EMOJIER_TYPE_EWHITE_LABEL, text);
}

static void
ibus_emojier_ewhite_label_real_get_preferred_width (GtkWidget* base,
                                                    gint* minimum_width,
                                                    gint* natural_width)
{
	IBusEmojierEWhiteLabel * self;
	gint _vala_minimum_width = 0;
	gint _vala_natural_width = 0;
	gboolean _tmp0_ = FALSE;
	gchar* text = NULL;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gunichar ch = 0U;
	const gchar* _tmp5_;
	gboolean _tmp6_ = FALSE;
	const gchar* _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	gint _tmp10_ = 0;
	gint _tmp11_ = 0;
	gboolean _tmp12_ = FALSE;
	const gchar* _tmp13_;
	gint _tmp14_;
	gint _tmp15_;
	self = (IBusEmojierEWhiteLabel*) base;
	if (self->priv->m_minimum_height == 0) {
		_tmp0_ = self->priv->m_natural_height == 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint _tmp1_ = 0;
		gint _tmp2_ = 0;
		GTK_WIDGET_CLASS (ibus_emojier_ewhite_label_parent_class)->get_preferred_height ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_label_get_type (), GtkLabel), &_tmp1_, &_tmp2_);
		self->priv->m_minimum_height = _tmp1_;
		self->priv->m_natural_height = _tmp2_;
	}
	_tmp3_ = gtk_label_get_label ((GtkLabel*) self);
	_tmp4_ = g_strdup (_tmp3_);
	text = _tmp4_;
	_tmp5_ = text;
	ch = string_get_char (_tmp5_, (glong) 0);
	_tmp7_ = text;
	_tmp8_ = strlen (_tmp7_);
	_tmp9_ = _tmp8_;
	if (_tmp9_ == 1) {
		_tmp6_ = ch == ((gunichar) '\t');
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		_vala_minimum_width = self->priv->m_minimum_height;
		self->priv->m_minimum_width = _vala_minimum_width;
		_vala_natural_width = self->priv->m_natural_height;
		self->priv->m_natural_width = _vala_natural_width;
		_g_free0 (text);
		if (minimum_width) {
			*minimum_width = _vala_minimum_width;
		}
		if (natural_width) {
			*natural_width = _vala_natural_width;
		}
		return;
	}
	GTK_WIDGET_CLASS (ibus_emojier_ewhite_label_parent_class)->get_preferred_width ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_label_get_type (), GtkLabel), &_tmp10_, &_tmp11_);
	_vala_minimum_width = _tmp10_;
	_vala_natural_width = _tmp11_;
	_tmp13_ = text;
	_tmp14_ = strlen (_tmp13_);
	_tmp15_ = _tmp14_;
	if (_tmp15_ == 1) {
		gboolean _tmp16_ = FALSE;
		if (ch == ((gunichar) '\n')) {
			_tmp16_ = TRUE;
		} else {
			_tmp16_ = ch == ((gunichar) '\r');
		}
		_tmp12_ = _tmp16_;
	} else {
		_tmp12_ = FALSE;
	}
	if (_tmp12_) {
		_vala_minimum_width = _vala_minimum_width / 2;
		_vala_natural_width = _vala_natural_width / 2;
		self->priv->m_minimum_width = _vala_minimum_width;
		self->priv->m_natural_width = _vala_natural_width;
		_g_free0 (text);
		if (minimum_width) {
			*minimum_width = _vala_minimum_width;
		}
		if (natural_width) {
			*natural_width = _vala_natural_width;
		}
		return;
	}
	if (_vala_minimum_width < self->priv->m_minimum_height) {
		_vala_minimum_width = self->priv->m_minimum_height;
	}
	if (_vala_natural_width < self->priv->m_natural_height) {
		_vala_natural_width = self->priv->m_natural_height;
	}
	self->priv->m_minimum_width = _vala_minimum_width;
	self->priv->m_natural_width = _vala_natural_width;
	_g_free0 (text);
	if (minimum_width) {
		*minimum_width = _vala_minimum_width;
	}
	if (natural_width) {
		*natural_width = _vala_natural_width;
	}
}

static void
ibus_emojier_ewhite_label_real_get_preferred_height (GtkWidget* base,
                                                     gint* minimum_height,
                                                     gint* natural_height)
{
	IBusEmojierEWhiteLabel * self;
	gint _vala_minimum_height = 0;
	gint _vala_natural_height = 0;
	gboolean _tmp0_ = FALSE;
	gchar* text = NULL;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gunichar ch = 0U;
	const gchar* _tmp5_;
	gboolean _tmp6_ = FALSE;
	const gchar* _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	gint _tmp10_ = 0;
	gint _tmp11_ = 0;
	gboolean _tmp12_ = FALSE;
	const gchar* _tmp13_;
	gint _tmp14_;
	gint _tmp15_;
	self = (IBusEmojierEWhiteLabel*) base;
	if (self->priv->m_minimum_width == 0) {
		_tmp0_ = self->priv->m_natural_width == 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint _tmp1_ = 0;
		gint _tmp2_ = 0;
		GTK_WIDGET_CLASS (ibus_emojier_ewhite_label_parent_class)->get_preferred_width ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_label_get_type (), GtkLabel), &_tmp1_, &_tmp2_);
		self->priv->m_minimum_width = _tmp1_;
		self->priv->m_natural_width = _tmp2_;
	}
	_tmp3_ = gtk_label_get_label ((GtkLabel*) self);
	_tmp4_ = g_strdup (_tmp3_);
	text = _tmp4_;
	_tmp5_ = text;
	ch = string_get_char (_tmp5_, (glong) 0);
	_tmp7_ = text;
	_tmp8_ = strlen (_tmp7_);
	_tmp9_ = _tmp8_;
	if (_tmp9_ == 1) {
		_tmp6_ = ch == ((gunichar) '\v');
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		_vala_minimum_height = self->priv->m_minimum_width;
		self->priv->m_minimum_height = _vala_minimum_height;
		_vala_natural_height = self->priv->m_natural_width;
		self->priv->m_natural_height = _vala_natural_height;
		_g_free0 (text);
		if (minimum_height) {
			*minimum_height = _vala_minimum_height;
		}
		if (natural_height) {
			*natural_height = _vala_natural_height;
		}
		return;
	}
	GTK_WIDGET_CLASS (ibus_emojier_ewhite_label_parent_class)->get_preferred_height ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_label_get_type (), GtkLabel), &_tmp10_, &_tmp11_);
	_vala_minimum_height = _tmp10_;
	_vala_natural_height = _tmp11_;
	_tmp13_ = text;
	_tmp14_ = strlen (_tmp13_);
	_tmp15_ = _tmp14_;
	if (_tmp15_ == 1) {
		gboolean _tmp16_ = FALSE;
		if (ch == ((gunichar) '\n')) {
			_tmp16_ = TRUE;
		} else {
			_tmp16_ = ch == ((gunichar) '\r');
		}
		_tmp12_ = _tmp16_;
	} else {
		_tmp12_ = FALSE;
	}
	if (_tmp12_) {
		_vala_minimum_height = _vala_minimum_height / 2;
		_vala_natural_height = _vala_natural_height / 2;
		self->priv->m_minimum_height = _vala_minimum_height;
		self->priv->m_natural_height = _vala_natural_height;
		_g_free0 (text);
		if (minimum_height) {
			*minimum_height = _vala_minimum_height;
		}
		if (natural_height) {
			*natural_height = _vala_natural_height;
		}
		return;
	}
	self->priv->m_minimum_height = _vala_minimum_height;
	self->priv->m_natural_height = _vala_natural_height;
	_g_free0 (text);
	if (minimum_height) {
		*minimum_height = _vala_minimum_height;
	}
	if (natural_height) {
		*natural_height = _vala_natural_height;
	}
}

static void
ibus_emojier_ewhite_label_class_init (IBusEmojierEWhiteLabelClass * klass,
                                      gpointer klass_data)
{
	ibus_emojier_ewhite_label_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &IBusEmojierEWhiteLabel_private_offset);
	((GtkWidgetClass *) klass)->get_preferred_width = (void (*) (GtkWidget*, gint*, gint*)) ibus_emojier_ewhite_label_real_get_preferred_width;
	((GtkWidgetClass *) klass)->get_preferred_height = (void (*) (GtkWidget*, gint*, gint*)) ibus_emojier_ewhite_label_real_get_preferred_height;
	G_OBJECT_CLASS (klass)->finalize = ibus_emojier_ewhite_label_finalize;
}

static void
ibus_emojier_ewhite_label_instance_init (IBusEmojierEWhiteLabel * self,
                                         gpointer klass)
{
	self->priv = ibus_emojier_ewhite_label_get_instance_private (self);
	self->priv->m_minimum_width = 0;
	self->priv->m_natural_width = 0;
	self->priv->m_minimum_height = 0;
	self->priv->m_natural_height = 0;
}

static void
ibus_emojier_ewhite_label_finalize (GObject * obj)
{
	IBusEmojierEWhiteLabel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, IBUS_EMOJIER_TYPE_EWHITE_LABEL, IBusEmojierEWhiteLabel);
	G_OBJECT_CLASS (ibus_emojier_ewhite_label_parent_class)->finalize (obj);
}

static GType
ibus_emojier_ewhite_label_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEWhiteLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_ewhite_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEWhiteLabel), 0, (GInstanceInitFunc) ibus_emojier_ewhite_label_instance_init, NULL };
	GType ibus_emojier_ewhite_label_type_id;
	ibus_emojier_ewhite_label_type_id = g_type_register_static (gtk_label_get_type (), "IBusEmojierEWhiteLabel", &g_define_type_info, 0);
	IBusEmojierEWhiteLabel_private_offset = g_type_add_instance_private (ibus_emojier_ewhite_label_type_id, sizeof (IBusEmojierEWhiteLabelPrivate));
	return ibus_emojier_ewhite_label_type_id;
}

static GType
ibus_emojier_ewhite_label_get_type (void)
{
	static volatile gsize ibus_emojier_ewhite_label_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_ewhite_label_type_id__volatile)) {
		GType ibus_emojier_ewhite_label_type_id;
		ibus_emojier_ewhite_label_type_id = ibus_emojier_ewhite_label_get_type_once ();
		g_once_init_leave (&ibus_emojier_ewhite_label_type_id__volatile, ibus_emojier_ewhite_label_type_id);
	}
	return ibus_emojier_ewhite_label_type_id__volatile;
}

static IBusEmojierESelectedLabel*
ibus_emojier_eselected_label_construct (GType object_type,
                                        const gchar* text)
{
	IBusEmojierESelectedLabel * self = NULL;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierESelectedLabel*) g_object_new (object_type, "name", "IBusEmojierSelectedLabel", NULL);
	if (g_strcmp0 (text, "") != 0) {
		gtk_label_set_label ((GtkLabel*) self, text);
	}
	return self;
}

static IBusEmojierESelectedLabel*
ibus_emojier_eselected_label_new (const gchar* text)
{
	return ibus_emojier_eselected_label_construct (IBUS_EMOJIER_TYPE_ESELECTED_LABEL, text);
}

static void
ibus_emojier_eselected_label_class_init (IBusEmojierESelectedLabelClass * klass,
                                         gpointer klass_data)
{
	ibus_emojier_eselected_label_parent_class = g_type_class_peek_parent (klass);
}

static void
ibus_emojier_eselected_label_instance_init (IBusEmojierESelectedLabel * self,
                                            gpointer klass)
{
}

static GType
ibus_emojier_eselected_label_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierESelectedLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_eselected_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierESelectedLabel), 0, (GInstanceInitFunc) ibus_emojier_eselected_label_instance_init, NULL };
	GType ibus_emojier_eselected_label_type_id;
	ibus_emojier_eselected_label_type_id = g_type_register_static (IBUS_EMOJIER_TYPE_EWHITE_LABEL, "IBusEmojierESelectedLabel", &g_define_type_info, 0);
	return ibus_emojier_eselected_label_type_id;
}

static GType
ibus_emojier_eselected_label_get_type (void)
{
	static volatile gsize ibus_emojier_eselected_label_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_eselected_label_type_id__volatile)) {
		GType ibus_emojier_eselected_label_type_id;
		ibus_emojier_eselected_label_type_id = ibus_emojier_eselected_label_get_type_once ();
		g_once_init_leave (&ibus_emojier_eselected_label_type_id__volatile, ibus_emojier_eselected_label_type_id);
	}
	return ibus_emojier_eselected_label_type_id__volatile;
}

static IBusEmojierEGoldLabel*
ibus_emojier_egold_label_construct (GType object_type,
                                    const gchar* text)
{
	IBusEmojierEGoldLabel * self = NULL;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierEGoldLabel*) g_object_new (object_type, "name", "IBusEmojierGoldLabel", NULL);
	if (g_strcmp0 (text, "") != 0) {
		gtk_label_set_label ((GtkLabel*) self, text);
	}
	return self;
}

static IBusEmojierEGoldLabel*
ibus_emojier_egold_label_new (const gchar* text)
{
	return ibus_emojier_egold_label_construct (IBUS_EMOJIER_TYPE_EGOLD_LABEL, text);
}

static void
ibus_emojier_egold_label_class_init (IBusEmojierEGoldLabelClass * klass,
                                     gpointer klass_data)
{
	ibus_emojier_egold_label_parent_class = g_type_class_peek_parent (klass);
}

static void
ibus_emojier_egold_label_instance_init (IBusEmojierEGoldLabel * self,
                                        gpointer klass)
{
}

static GType
ibus_emojier_egold_label_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEGoldLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_egold_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEGoldLabel), 0, (GInstanceInitFunc) ibus_emojier_egold_label_instance_init, NULL };
	GType ibus_emojier_egold_label_type_id;
	ibus_emojier_egold_label_type_id = g_type_register_static (IBUS_EMOJIER_TYPE_EWHITE_LABEL, "IBusEmojierEGoldLabel", &g_define_type_info, 0);
	return ibus_emojier_egold_label_type_id;
}

static GType
ibus_emojier_egold_label_get_type (void)
{
	static volatile gsize ibus_emojier_egold_label_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_egold_label_type_id__volatile)) {
		GType ibus_emojier_egold_label_type_id;
		ibus_emojier_egold_label_type_id = ibus_emojier_egold_label_get_type_once ();
		g_once_init_leave (&ibus_emojier_egold_label_type_id__volatile, ibus_emojier_egold_label_type_id);
	}
	return ibus_emojier_egold_label_type_id__volatile;
}

static IBusEmojierEPaddedLabel*
ibus_emojier_epadded_label_construct (GType object_type,
                                      const gchar* text,
                                      GtkAlign align)
{
	IBusEmojierEPaddedLabel * self = NULL;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierEPaddedLabel*) g_object_new (object_type, "name", "IBusEmojierPaddedLabel", "halign", align, "valign", GTK_ALIGN_CENTER, "margin-start", 20, "margin-end", 20, "margin-top", 6, "margin-bottom", 6, NULL);
	gtk_label_set_text ((GtkLabel*) self, text);
	return self;
}

static IBusEmojierEPaddedLabel*
ibus_emojier_epadded_label_new (const gchar* text,
                                GtkAlign align)
{
	return ibus_emojier_epadded_label_construct (IBUS_EMOJIER_TYPE_EPADDED_LABEL, text, align);
}

static void
ibus_emojier_epadded_label_class_init (IBusEmojierEPaddedLabelClass * klass,
                                       gpointer klass_data)
{
	ibus_emojier_epadded_label_parent_class = g_type_class_peek_parent (klass);
}

static void
ibus_emojier_epadded_label_instance_init (IBusEmojierEPaddedLabel * self,
                                          gpointer klass)
{
}

static GType
ibus_emojier_epadded_label_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEPaddedLabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_epadded_label_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEPaddedLabel), 0, (GInstanceInitFunc) ibus_emojier_epadded_label_instance_init, NULL };
	GType ibus_emojier_epadded_label_type_id;
	ibus_emojier_epadded_label_type_id = g_type_register_static (gtk_label_get_type (), "IBusEmojierEPaddedLabel", &g_define_type_info, 0);
	return ibus_emojier_epadded_label_type_id;
}

static GType
ibus_emojier_epadded_label_get_type (void)
{
	static volatile gsize ibus_emojier_epadded_label_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_epadded_label_type_id__volatile)) {
		GType ibus_emojier_epadded_label_type_id;
		ibus_emojier_epadded_label_type_id = ibus_emojier_epadded_label_get_type_once ();
		g_once_init_leave (&ibus_emojier_epadded_label_type_id__volatile, ibus_emojier_epadded_label_type_id);
	}
	return ibus_emojier_epadded_label_type_id__volatile;
}

static IBusEmojierEPaddedLabelBox*
ibus_emojier_epadded_label_box_construct (GType object_type,
                                          const gchar* text,
                                          GtkAlign align,
                                          IBusEmojierTravelDirection direction,
                                          const gchar* caption)
{
	IBusEmojierEPaddedLabelBox * self = NULL;
	IBusEmojierEPaddedLabel* label = NULL;
	IBusEmojierEPaddedLabel* _tmp3_;
	IBusEmojierEPaddedLabel* _tmp4_;
	g_return_val_if_fail (text != NULL, NULL);
	self = (IBusEmojierEPaddedLabelBox*) g_object_new (object_type, "name", "IBusEmojierPaddedLabelBox", "orientation", GTK_ORIENTATION_HORIZONTAL, "spacing", 0, NULL);
	if (direction == IBUS_EMOJIER_TRAVEL_DIRECTION_BACKWARD) {
		IconWidget* icon = NULL;
		IconWidget* _tmp2_;
		if (gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL) {
			IconWidget* _tmp0_;
			_tmp0_ = icon_widget_new ("go-previous-rtl-symbolic", GTK_ICON_SIZE_MENU);
			g_object_ref_sink (_tmp0_);
			_g_object_unref0 (icon);
			icon = _tmp0_;
		} else {
			IconWidget* _tmp1_;
			_tmp1_ = icon_widget_new ("go-previous-symbolic", GTK_ICON_SIZE_MENU);
			g_object_ref_sink (_tmp1_);
			_g_object_unref0 (icon);
			icon = _tmp1_;
		}
		_tmp2_ = icon;
		gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp2_, FALSE, TRUE, (guint) 0);
		_g_object_unref0 (icon);
	}
	_tmp3_ = ibus_emojier_epadded_label_new (text, align);
	g_object_ref_sink (_tmp3_);
	label = _tmp3_;
	_tmp4_ = label;
	gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp4_, TRUE, TRUE, (guint) 0);
	if (caption != NULL) {
		IBusEmojierEPaddedLabel* label_r = NULL;
		IBusEmojierEPaddedLabel* _tmp5_;
		IBusEmojierEPaddedLabel* _tmp6_;
		_tmp5_ = ibus_emojier_epadded_label_new (caption, GTK_ALIGN_END);
		g_object_ref_sink (_tmp5_);
		label_r = _tmp5_;
		_tmp6_ = label_r;
		gtk_box_pack_end ((GtkBox*) self, (GtkWidget*) _tmp6_, TRUE, TRUE, (guint) 0);
		_g_object_unref0 (label_r);
	}
	_g_object_unref0 (label);
	return self;
}

static IBusEmojierEPaddedLabelBox*
ibus_emojier_epadded_label_box_new (const gchar* text,
                                    GtkAlign align,
                                    IBusEmojierTravelDirection direction,
                                    const gchar* caption)
{
	return ibus_emojier_epadded_label_box_construct (IBUS_EMOJIER_TYPE_EPADDED_LABEL_BOX, text, align, direction, caption);
}

static void
ibus_emojier_epadded_label_box_class_init (IBusEmojierEPaddedLabelBoxClass * klass,
                                           gpointer klass_data)
{
	ibus_emojier_epadded_label_box_parent_class = g_type_class_peek_parent (klass);
}

static void
ibus_emojier_epadded_label_box_instance_init (IBusEmojierEPaddedLabelBox * self,
                                              gpointer klass)
{
}

static GType
ibus_emojier_epadded_label_box_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierEPaddedLabelBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_epadded_label_box_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierEPaddedLabelBox), 0, (GInstanceInitFunc) ibus_emojier_epadded_label_box_instance_init, NULL };
	GType ibus_emojier_epadded_label_box_type_id;
	ibus_emojier_epadded_label_box_type_id = g_type_register_static (gtk_box_get_type (), "IBusEmojierEPaddedLabelBox", &g_define_type_info, 0);
	return ibus_emojier_epadded_label_box_type_id;
}

static GType
ibus_emojier_epadded_label_box_get_type (void)
{
	static volatile gsize ibus_emojier_epadded_label_box_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_epadded_label_box_type_id__volatile)) {
		GType ibus_emojier_epadded_label_box_type_id;
		ibus_emojier_epadded_label_box_type_id = ibus_emojier_epadded_label_box_get_type_once ();
		g_once_init_leave (&ibus_emojier_epadded_label_box_type_id__volatile, ibus_emojier_epadded_label_box_type_id);
	}
	return ibus_emojier_epadded_label_box_type_id__volatile;
}

static IBusEmojierLoadProgressObject*
ibus_emojier_load_progress_object_construct (GType object_type)
{
	IBusEmojierLoadProgressObject * self = NULL;
	self = (IBusEmojierLoadProgressObject*) g_object_new (object_type, NULL);
	return self;
}

static IBusEmojierLoadProgressObject*
ibus_emojier_load_progress_object_new (void)
{
	return ibus_emojier_load_progress_object_construct (IBUS_EMOJIER_TYPE_LOAD_PROGRESS_OBJECT);
}

static void
g_cclosure_user_marshal_VOID__UINT_UINT (GClosure * closure,
                                         GValue * return_value,
                                         guint n_param_values,
                                         const GValue * param_values,
                                         gpointer invocation_hint,
                                         gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__UINT_UINT) (gpointer data1, guint arg_1, guint arg_2, gpointer data2);
	register GMarshalFunc_VOID__UINT_UINT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__UINT_UINT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_uint (param_values + 1), g_value_get_uint (param_values + 2), data2);
}

static void
ibus_emojier_load_progress_object_class_init (IBusEmojierLoadProgressObjectClass * klass,
                                              gpointer klass_data)
{
	ibus_emojier_load_progress_object_parent_class = g_type_class_peek_parent (klass);
	ibus_emojier_load_progress_object_signals[IBUS_EMOJIER_LOAD_PROGRESS_OBJECT_DESERIALIZE_UNICODE_SIGNAL] = g_signal_new ("deserialize-unicode", IBUS_EMOJIER_TYPE_LOAD_PROGRESS_OBJECT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT_UINT, G_TYPE_NONE, 2, G_TYPE_UINT, G_TYPE_UINT);
}

static void
ibus_emojier_load_progress_object_instance_init (IBusEmojierLoadProgressObject * self,
                                                 gpointer klass)
{
}

static GType
ibus_emojier_load_progress_object_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierLoadProgressObjectClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_load_progress_object_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojierLoadProgressObject), 0, (GInstanceInitFunc) ibus_emojier_load_progress_object_instance_init, NULL };
	GType ibus_emojier_load_progress_object_type_id;
	ibus_emojier_load_progress_object_type_id = g_type_register_static (G_TYPE_OBJECT, "IBusEmojierLoadProgressObject", &g_define_type_info, 0);
	return ibus_emojier_load_progress_object_type_id;
}

static GType
ibus_emojier_load_progress_object_get_type (void)
{
	static volatile gsize ibus_emojier_load_progress_object_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_load_progress_object_type_id__volatile)) {
		GType ibus_emojier_load_progress_object_type_id;
		ibus_emojier_load_progress_object_type_id = ibus_emojier_load_progress_object_get_type_once ();
		g_once_init_leave (&ibus_emojier_load_progress_object_type_id__volatile, ibus_emojier_load_progress_object_type_id);
	}
	return ibus_emojier_load_progress_object_type_id__volatile;
}

static void
ibus_emojier_class_init (IBusEmojierClass * klass,
                         gpointer klass_data)
{
	gchar* _tmp0_;
	ibus_emojier_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &IBusEmojier_private_offset);
	((GtkWidgetClass *) klass)->show_all = (void (*) (GtkWidget*)) ibus_emojier_real_show_all;
	((GtkWidgetClass *) klass)->hide = (void (*) (GtkWidget*)) ibus_emojier_real_hide;
	((GtkWidgetClass *) klass)->key_press_event = (gboolean (*) (GtkWidget*, GdkEventKey*)) ibus_emojier_real_key_press_event;
	G_OBJECT_CLASS (klass)->finalize = ibus_emojier_finalize;
	ibus_emojier_signals[IBUS_EMOJIER_CANDIDATE_CLICKED_SIGNAL] = g_signal_new ("candidate-clicked", TYPE_IBUS_EMOJIER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__UINT_UINT_UINT, G_TYPE_NONE, 3, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_UINT);
	ibus_emojier_signals[IBUS_EMOJIER_COMMIT_TEXT_SIGNAL] = g_signal_new ("commit-text", TYPE_IBUS_EMOJIER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	ibus_emojier_signals[IBUS_EMOJIER_CANCEL_SIGNAL] = g_signal_new ("cancel", TYPE_IBUS_EMOJIER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	_tmp0_ = g_strdup ("");
	ibus_emojier_m_warning_message = _tmp0_;
}

static void
ibus_emojier_instance_init (IBusEmojier * self,
                            gpointer klass)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	self->priv = ibus_emojier_get_instance_private (self);
	_tmp0_ = g_strdup ("");
	self->priv->m_annotation = _tmp0_;
	self->priv->m_backward_index = -1;
	self->priv->m_scrolled_window = NULL;
	self->priv->m_is_running = FALSE;
	_tmp1_ = g_strdup ("");
	self->priv->m_input_context_path = _tmp1_;
	self->priv->m_category_active_index = -1;
	self->priv->m_enter_notify_enable = TRUE;
	self->priv->m_is_up_side_down = FALSE;
}

static void
ibus_emojier_finalize (GObject * obj)
{
	IBusEmojier * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_IBUS_EMOJIER, IBusEmojier);
	_themed_rgba_unref0 (self->priv->m_rgba);
	_g_object_unref0 (self->priv->m_vbox);
	_g_free0 (self->priv->m_annotation);
	_g_free0 (self->priv->m_backward);
	_g_object_unref0 (self->priv->m_scrolled_window);
	_g_object_unref0 (self->priv->m_list_box);
	_g_free0 (self->priv->m_input_context_path);
	_g_main_loop_unref0 (self->priv->m_loop);
	_g_free0 (self->priv->m_result);
	_g_object_unref0 (self->priv->m_lookup_table);
	self->priv->m_candidates = (_vala_array_free (self->priv->m_candidates, self->priv->m_candidates_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (self->priv->m_unicode_progress_bar);
	_g_object_unref0 (self->priv->m_unicode_percent_label);
	G_OBJECT_CLASS (ibus_emojier_parent_class)->finalize (obj);
}

static GType
ibus_emojier_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IBusEmojierClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ibus_emojier_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IBusEmojier), 0, (GInstanceInitFunc) ibus_emojier_instance_init, NULL };
	GType ibus_emojier_type_id;
	ibus_emojier_type_id = g_type_register_static (gtk_application_window_get_type (), "IBusEmojier", &g_define_type_info, 0);
	IBusEmojier_private_offset = g_type_add_instance_private (ibus_emojier_type_id, sizeof (IBusEmojierPrivate));
	return ibus_emojier_type_id;
}

GType
ibus_emojier_get_type (void)
{
	static volatile gsize ibus_emojier_type_id__volatile = 0;
	if (g_once_init_enter (&ibus_emojier_type_id__volatile)) {
		GType ibus_emojier_type_id;
		ibus_emojier_type_id = ibus_emojier_get_type_once ();
		g_once_init_leave (&ibus_emojier_type_id__volatile, ibus_emojier_type_id);
	}
	return ibus_emojier_type_id__volatile;
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gint
_vala_array_length (gpointer array)
{
	gint length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

