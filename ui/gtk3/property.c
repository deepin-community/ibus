/* property.c generated by valac 0.52.4, the Vala compiler
 * generated from property.vala, do not modify */

/* vim:set et sts=4 sw=4:
 *
 * ibus - The Input Bus
 *
 * Copyright(c) 2011-2015 Peng Huang <shawn.p.huang@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 * USA
 */

#include <glib-object.h>
#include <ibus.h>
#include <glib.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>

#define TYPE_PROPERTY_MANAGER (property_manager_get_type ())
#define PROPERTY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROPERTY_MANAGER, PropertyManager))
#define PROPERTY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROPERTY_MANAGER, PropertyManagerClass))
#define IS_PROPERTY_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROPERTY_MANAGER))
#define IS_PROPERTY_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROPERTY_MANAGER))
#define PROPERTY_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROPERTY_MANAGER, PropertyManagerClass))

typedef struct _PropertyManager PropertyManager;
typedef struct _PropertyManagerClass PropertyManagerClass;
typedef struct _PropertyManagerPrivate PropertyManagerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_PROP_RADIO_MENU_ITEM (prop_radio_menu_item_get_type ())
#define PROP_RADIO_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROP_RADIO_MENU_ITEM, PropRadioMenuItem))
#define PROP_RADIO_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROP_RADIO_MENU_ITEM, PropRadioMenuItemClass))
#define IS_PROP_RADIO_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROP_RADIO_MENU_ITEM))
#define IS_PROP_RADIO_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROP_RADIO_MENU_ITEM))
#define PROP_RADIO_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROP_RADIO_MENU_ITEM, PropRadioMenuItemClass))

typedef struct _PropRadioMenuItem PropRadioMenuItem;
typedef struct _PropRadioMenuItemClass PropRadioMenuItemClass;

#define TYPE_IPROP_ITEM (iprop_item_get_type ())
#define IPROP_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_IPROP_ITEM, IPropItem))
#define IS_IPROP_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_IPROP_ITEM))
#define IPROP_ITEM_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_IPROP_ITEM, IPropItemIface))

typedef struct _IPropItem IPropItem;
typedef struct _IPropItemIface IPropItemIface;

#define TYPE_PROP_IMAGE_MENU_ITEM (prop_image_menu_item_get_type ())
#define PROP_IMAGE_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROP_IMAGE_MENU_ITEM, PropImageMenuItem))
#define PROP_IMAGE_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROP_IMAGE_MENU_ITEM, PropImageMenuItemClass))
#define IS_PROP_IMAGE_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROP_IMAGE_MENU_ITEM))
#define IS_PROP_IMAGE_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROP_IMAGE_MENU_ITEM))
#define PROP_IMAGE_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROP_IMAGE_MENU_ITEM, PropImageMenuItemClass))

typedef struct _PropImageMenuItem PropImageMenuItem;
typedef struct _PropImageMenuItemClass PropImageMenuItemClass;

#define TYPE_PROP_CHECK_MENU_ITEM (prop_check_menu_item_get_type ())
#define PROP_CHECK_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROP_CHECK_MENU_ITEM, PropCheckMenuItem))
#define PROP_CHECK_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROP_CHECK_MENU_ITEM, PropCheckMenuItemClass))
#define IS_PROP_CHECK_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROP_CHECK_MENU_ITEM))
#define IS_PROP_CHECK_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROP_CHECK_MENU_ITEM))
#define PROP_CHECK_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROP_CHECK_MENU_ITEM, PropCheckMenuItemClass))

typedef struct _PropCheckMenuItem PropCheckMenuItem;
typedef struct _PropCheckMenuItemClass PropCheckMenuItemClass;

#define TYPE_PROP_SEPARATOR_MENU_ITEM (prop_separator_menu_item_get_type ())
#define PROP_SEPARATOR_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROP_SEPARATOR_MENU_ITEM, PropSeparatorMenuItem))
#define PROP_SEPARATOR_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROP_SEPARATOR_MENU_ITEM, PropSeparatorMenuItemClass))
#define IS_PROP_SEPARATOR_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROP_SEPARATOR_MENU_ITEM))
#define IS_PROP_SEPARATOR_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROP_SEPARATOR_MENU_ITEM))
#define PROP_SEPARATOR_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROP_SEPARATOR_MENU_ITEM, PropSeparatorMenuItemClass))

typedef struct _PropSeparatorMenuItem PropSeparatorMenuItem;
typedef struct _PropSeparatorMenuItemClass PropSeparatorMenuItemClass;
typedef struct _ParamSpecPropertyManager ParamSpecPropertyManager;
enum  {
	PROPERTY_MANAGER_PROPERTY_ACTIVATE_SIGNAL,
	PROPERTY_MANAGER_NUM_SIGNALS
};
static guint property_manager_signals[PROPERTY_MANAGER_NUM_SIGNALS] = {0};
enum  {
	IPROP_ITEM_PROPERTY_ACTIVATE_SIGNAL,
	IPROP_ITEM_NUM_SIGNALS
};
static guint iprop_item_signals[IPROP_ITEM_NUM_SIGNALS] = {0};
typedef struct _PropImageMenuItemPrivate PropImageMenuItemPrivate;
enum  {
	PROP_IMAGE_MENU_ITEM_0_PROPERTY,
	PROP_IMAGE_MENU_ITEM_NUM_PROPERTIES
};
static GParamSpec* prop_image_menu_item_properties[PROP_IMAGE_MENU_ITEM_NUM_PROPERTIES];
typedef struct _PropCheckMenuItemPrivate PropCheckMenuItemPrivate;
enum  {
	PROP_CHECK_MENU_ITEM_0_PROPERTY,
	PROP_CHECK_MENU_ITEM_NUM_PROPERTIES
};
static GParamSpec* prop_check_menu_item_properties[PROP_CHECK_MENU_ITEM_NUM_PROPERTIES];
typedef struct _PropRadioMenuItemPrivate PropRadioMenuItemPrivate;
enum  {
	PROP_RADIO_MENU_ITEM_0_PROPERTY,
	PROP_RADIO_MENU_ITEM_NUM_PROPERTIES
};
static GParamSpec* prop_radio_menu_item_properties[PROP_RADIO_MENU_ITEM_NUM_PROPERTIES];
typedef struct _PropSeparatorMenuItemPrivate PropSeparatorMenuItemPrivate;
enum  {
	PROP_SEPARATOR_MENU_ITEM_0_PROPERTY,
	PROP_SEPARATOR_MENU_ITEM_NUM_PROPERTIES
};
static GParamSpec* prop_separator_menu_item_properties[PROP_SEPARATOR_MENU_ITEM_NUM_PROPERTIES];
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _PropertyManager {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PropertyManagerPrivate * priv;
};

struct _PropertyManagerClass {
	GTypeClass parent_class;
	void (*finalize) (PropertyManager *self);
};

struct _PropertyManagerPrivate {
	IBusPropList* m_props;
};

struct _IPropItemIface {
	GTypeInterface parent_iface;
	void (*update_property) (IPropItem* self, IBusProperty* prop);
};

struct _ParamSpecPropertyManager {
	GParamSpec parent_instance;
};

struct _PropImageMenuItem {
	GtkMenuItem parent_instance;
	PropImageMenuItemPrivate * priv;
};

struct _PropImageMenuItemClass {
	GtkMenuItemClass parent_class;
};

struct _PropImageMenuItemPrivate {
	IBusProperty* m_property;
};

struct _PropCheckMenuItem {
	GtkCheckMenuItem parent_instance;
	PropCheckMenuItemPrivate * priv;
};

struct _PropCheckMenuItemClass {
	GtkCheckMenuItemClass parent_class;
};

struct _PropCheckMenuItemPrivate {
	IBusProperty* m_property;
};

struct _PropRadioMenuItem {
	GtkRadioMenuItem parent_instance;
	PropRadioMenuItemPrivate * priv;
};

struct _PropRadioMenuItemClass {
	GtkRadioMenuItemClass parent_class;
};

struct _PropRadioMenuItemPrivate {
	IBusProperty* m_property;
};

struct _PropSeparatorMenuItem {
	GtkSeparatorMenuItem parent_instance;
	PropSeparatorMenuItemPrivate * priv;
};

struct _PropSeparatorMenuItemClass {
	GtkSeparatorMenuItemClass parent_class;
};

struct _PropSeparatorMenuItemPrivate {
	IBusProperty* m_property;
};

static gint PropertyManager_private_offset;
static gpointer property_manager_parent_class = NULL;
static gint PropImageMenuItem_private_offset;
static gpointer prop_image_menu_item_parent_class = NULL;
static IPropItemIface * prop_image_menu_item_iprop_item_parent_iface = NULL;
static gint PropCheckMenuItem_private_offset;
static gpointer prop_check_menu_item_parent_class = NULL;
static IPropItemIface * prop_check_menu_item_iprop_item_parent_iface = NULL;
static gint PropRadioMenuItem_private_offset;
static gpointer prop_radio_menu_item_parent_class = NULL;
static IPropItemIface * prop_radio_menu_item_iprop_item_parent_iface = NULL;
static gint PropSeparatorMenuItem_private_offset;
static gpointer prop_separator_menu_item_parent_class = NULL;
static IPropItemIface * prop_separator_menu_item_iprop_item_parent_iface = NULL;

gpointer property_manager_ref (gpointer instance);
void property_manager_unref (gpointer instance);
GParamSpec* param_spec_property_manager (const gchar* name,
                                         const gchar* nick,
                                         const gchar* blurb,
                                         GType object_type,
                                         GParamFlags flags);
void value_set_property_manager (GValue* value,
                                 gpointer v_object);
void value_take_property_manager (GValue* value,
                                  gpointer v_object);
gpointer value_get_property_manager (const GValue* value);
GType property_manager_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PropertyManager, property_manager_unref)
void property_manager_ProperyManager (PropertyManager* self);
void property_manager_set_properties (PropertyManager* self,
                                      IBusPropList* props);
gint property_manager_create_menu_items (PropertyManager* self,
                                         GtkMenu* menu);
static gint property_manager_create_menu_items_internal (PropertyManager* self,
                                                  IBusPropList* props,
                                                  GtkMenu* menu);
GType prop_radio_menu_item_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PropRadioMenuItem, g_object_unref)
GType iprop_item_get_type (void) G_GNUC_CONST ;
PropImageMenuItem* prop_image_menu_item_new (IBusProperty* property);
PropImageMenuItem* prop_image_menu_item_construct (GType object_type,
                                                   IBusProperty* property);
GType prop_image_menu_item_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PropImageMenuItem, g_object_unref)
PropCheckMenuItem* prop_check_menu_item_new (IBusProperty* property);
PropCheckMenuItem* prop_check_menu_item_construct (GType object_type,
                                                   IBusProperty* property);
GType prop_check_menu_item_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PropCheckMenuItem, g_object_unref)
PropRadioMenuItem* prop_radio_menu_item_new (IBusProperty* property,
                                             PropRadioMenuItem* group_source);
PropRadioMenuItem* prop_radio_menu_item_construct (GType object_type,
                                                   IBusProperty* property,
                                                   PropRadioMenuItem* group_source);
PropSeparatorMenuItem* prop_separator_menu_item_new (IBusProperty* property);
PropSeparatorMenuItem* prop_separator_menu_item_construct (GType object_type,
                                                           IBusProperty* property);
GType prop_separator_menu_item_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PropSeparatorMenuItem, g_object_unref)
static void ____lambda24_ (PropertyManager* self,
                    const gchar* k,
                    gint s);
static void _____lambda24__iprop_item_property_activate (IPropItem* _sender,
                                                  const gchar* key,
                                                  gint state,
                                                  gpointer self);
void property_manager_update_property (PropertyManager* self,
                                       IBusProperty* prop);
PropertyManager* property_manager_new (void);
PropertyManager* property_manager_construct (GType object_type);
static void g_cclosure_user_marshal_VOID__STRING_INT (GClosure * closure,
                                               GValue * return_value,
                                               guint n_param_values,
                                               const GValue * param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data);
static void property_manager_finalize (PropertyManager * obj);
static GType property_manager_get_type_once (void);
void iprop_item_update_property (IPropItem* self,
                                 IBusProperty* prop);
static GType iprop_item_get_type_once (void);
static void prop_image_menu_item_sync (PropImageMenuItem* self);
static void prop_image_menu_item_real_update_property (IPropItem* base,
                                                IBusProperty* property);
static void prop_image_menu_item_real_activate (GtkMenuItem* base);
static void prop_image_menu_item_finalize (GObject * obj);
static GType prop_image_menu_item_get_type_once (void);
static void prop_check_menu_item_sync (PropCheckMenuItem* self);
static void prop_check_menu_item_real_update_property (IPropItem* base,
                                                IBusProperty* property);
static void prop_check_menu_item_real_toggled (GtkCheckMenuItem* base);
static void prop_check_menu_item_finalize (GObject * obj);
static GType prop_check_menu_item_get_type_once (void);
static void prop_radio_menu_item_sync (PropRadioMenuItem* self);
static void prop_radio_menu_item_real_update_property (IPropItem* base,
                                                IBusProperty* property);
static void prop_radio_menu_item_real_toggled (GtkCheckMenuItem* base);
static void prop_radio_menu_item_finalize (GObject * obj);
static GType prop_radio_menu_item_get_type_once (void);
static void prop_separator_menu_item_real_update_property (IPropItem* base,
                                                    IBusProperty* property);
static void prop_separator_menu_item_finalize (GObject * obj);
static GType prop_separator_menu_item_get_type_once (void);

static inline gpointer
property_manager_get_instance_private (PropertyManager* self)
{
	return G_STRUCT_MEMBER_P (self, PropertyManager_private_offset);
}

void
property_manager_ProperyManager (PropertyManager* self)
{
	g_return_if_fail (self != NULL);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

void
property_manager_set_properties (PropertyManager* self,
                                 IBusPropList* props)
{
	IBusPropList* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (props != NULL);
	_tmp0_ = _g_object_ref0 (props);
	_g_object_unref0 (self->priv->m_props);
	self->priv->m_props = _tmp0_;
}

gint
property_manager_create_menu_items (PropertyManager* self,
                                    GtkMenu* menu)
{
	IBusPropList* _tmp0_;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (menu != NULL, 0);
	_tmp0_ = self->priv->m_props;
	result = property_manager_create_menu_items_internal (self, _tmp0_, menu);
	return result;
}

static void
____lambda24_ (PropertyManager* self,
               const gchar* k,
               gint s)
{
	g_return_if_fail (k != NULL);
	g_signal_emit (self, property_manager_signals[PROPERTY_MANAGER_PROPERTY_ACTIVATE_SIGNAL], 0, k, s);
}

static void
_____lambda24__iprop_item_property_activate (IPropItem* _sender,
                                             const gchar* key,
                                             gint state,
                                             gpointer self)
{
	____lambda24_ ((PropertyManager*) self, key, state);
}

static gint
property_manager_create_menu_items_internal (PropertyManager* self,
                                             IBusPropList* props,
                                             GtkMenu* menu)
{
	gint i = 0;
	PropRadioMenuItem* last_radio = NULL;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (props != NULL, 0);
	g_return_val_if_fail (menu != NULL, 0);
	i = 0;
	last_radio = NULL;
	while (TRUE) {
		IBusProperty* prop = NULL;
		IBusProperty* _tmp0_;
		IBusProperty* _tmp1_;
		IBusProperty* _tmp2_;
		IBusProperty* _tmp3_;
		const gchar* _tmp4_;
		gint _tmp5_;
		IPropItem* item = NULL;
		IBusProperty* _tmp6_;
		IBusProperty* _tmp31_;
		IPropItem* _tmp32_;
		_tmp0_ = ibus_prop_list_get (props, (guint) i);
		_tmp1_ = _g_object_ref0 (_tmp0_);
		prop = _tmp1_;
		_tmp2_ = prop;
		if (_tmp2_ == NULL) {
			_g_object_unref0 (prop);
			break;
		}
		_tmp3_ = prop;
		_tmp4_ = ibus_property_get_key (_tmp3_);
		g_debug ("property.vala:44: ins prop = %s", _tmp4_);
		_tmp5_ = i;
		i = _tmp5_ + 1;
		item = NULL;
		_tmp6_ = prop;
		switch (ibus_property_get_prop_type (_tmp6_)) {
			case PROP_TYPE_NORMAL:
			{
				IBusProperty* _tmp7_;
				PropImageMenuItem* _tmp8_;
				_tmp7_ = prop;
				_tmp8_ = prop_image_menu_item_new (_tmp7_);
				g_object_ref_sink (_tmp8_);
				_g_object_unref0 (item);
				item = (IPropItem*) _tmp8_;
				break;
			}
			case PROP_TYPE_TOGGLE:
			{
				IBusProperty* _tmp9_;
				PropCheckMenuItem* _tmp10_;
				_tmp9_ = prop;
				_tmp10_ = prop_check_menu_item_new (_tmp9_);
				g_object_ref_sink (_tmp10_);
				_g_object_unref0 (item);
				item = (IPropItem*) _tmp10_;
				break;
			}
			case PROP_TYPE_RADIO:
			{
				{
					PropRadioMenuItem* radio = NULL;
					IBusProperty* _tmp11_;
					PropRadioMenuItem* _tmp12_;
					PropRadioMenuItem* _tmp13_;
					PropRadioMenuItem* _tmp14_;
					IPropItem* _tmp15_;
					PropRadioMenuItem* _tmp16_;
					PropRadioMenuItem* _tmp17_;
					_tmp11_ = prop;
					_tmp12_ = last_radio;
					_tmp13_ = prop_radio_menu_item_new (_tmp11_, _tmp12_);
					g_object_ref_sink (_tmp13_);
					radio = _tmp13_;
					_tmp14_ = radio;
					_tmp15_ = _g_object_ref0 ((IPropItem*) _tmp14_);
					_g_object_unref0 (item);
					item = _tmp15_;
					_tmp16_ = radio;
					_tmp17_ = _g_object_ref0 (_tmp16_);
					_g_object_unref0 (last_radio);
					last_radio = _tmp17_;
					_g_object_unref0 (radio);
				}
				break;
			}
			case PROP_TYPE_MENU:
			{
				{
					PropImageMenuItem* menuitem = NULL;
					IBusProperty* _tmp18_;
					PropImageMenuItem* _tmp19_;
					PropImageMenuItem* _tmp20_;
					IPropItem* _tmp21_;
					GtkMenu* submenu = NULL;
					GtkMenu* _tmp22_;
					IBusProperty* _tmp23_;
					IBusPropList* _tmp24_;
					GtkMenu* _tmp25_;
					_tmp18_ = prop;
					_tmp19_ = prop_image_menu_item_new (_tmp18_);
					g_object_ref_sink (_tmp19_);
					menuitem = _tmp19_;
					_tmp20_ = menuitem;
					_tmp21_ = _g_object_ref0 ((IPropItem*) _tmp20_);
					_g_object_unref0 (item);
					item = _tmp21_;
					_tmp22_ = (GtkMenu*) gtk_menu_new ();
					g_object_ref_sink (_tmp22_);
					submenu = _tmp22_;
					_tmp23_ = prop;
					_tmp24_ = ibus_property_get_sub_props (_tmp23_);
					_tmp25_ = submenu;
					if (property_manager_create_menu_items_internal (self, _tmp24_, _tmp25_) > 0) {
						PropImageMenuItem* _tmp26_;
						GtkMenu* _tmp27_;
						_tmp26_ = menuitem;
						_tmp27_ = submenu;
						gtk_menu_item_set_submenu ((GtkMenuItem*) _tmp26_, _tmp27_);
					}
					_g_object_unref0 (submenu);
					_g_object_unref0 (menuitem);
				}
				break;
			}
			case PROP_TYPE_SEPARATOR:
			{
				IBusProperty* _tmp28_;
				PropSeparatorMenuItem* _tmp29_;
				_tmp28_ = prop;
				_tmp29_ = prop_separator_menu_item_new (_tmp28_);
				g_object_ref_sink (_tmp29_);
				_g_object_unref0 (item);
				item = (IPropItem*) _tmp29_;
				break;
			}
			default:
			{
				IBusProperty* _tmp30_;
				_tmp30_ = prop;
				g_warning ("property.vala:76: unknown property type %d", (gint) ibus_property_get_prop_type (_tmp30_));
				break;
			}
		}
		_tmp31_ = prop;
		if (ibus_property_get_prop_type (_tmp31_) != PROP_TYPE_RADIO) {
			_g_object_unref0 (last_radio);
			last_radio = NULL;
		}
		_tmp32_ = item;
		if (_tmp32_ != NULL) {
			IPropItem* _tmp33_;
			IPropItem* _tmp34_;
			_tmp33_ = item;
			gtk_menu_shell_append ((GtkMenuShell*) menu, G_TYPE_CHECK_INSTANCE_TYPE (_tmp33_, gtk_menu_item_get_type ()) ? ((GtkMenuItem*) _tmp33_) : NULL);
			_tmp34_ = item;
			g_signal_connect (_tmp34_, "property-activate", (GCallback) _____lambda24__iprop_item_property_activate, self);
		}
		_g_object_unref0 (item);
		_g_object_unref0 (prop);
	}
	result = i;
	_g_object_unref0 (last_radio);
	return result;
}

void
property_manager_update_property (PropertyManager* self,
                                  IBusProperty* prop)
{
	IBusPropList* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prop != NULL);
	_vala_assert (prop != NULL, "prop != null");
	_tmp0_ = self->priv->m_props;
	if (_tmp0_ != NULL) {
		IBusPropList* _tmp1_;
		_tmp1_ = self->priv->m_props;
		ibus_prop_list_update_property (_tmp1_, prop);
	}
}

PropertyManager*
property_manager_construct (GType object_type)
{
	PropertyManager* self = NULL;
	self = (PropertyManager*) g_type_create_instance (object_type);
	return self;
}

PropertyManager*
property_manager_new (void)
{
	return property_manager_construct (TYPE_PROPERTY_MANAGER);
}

static void
g_cclosure_user_marshal_VOID__STRING_INT (GClosure * closure,
                                          GValue * return_value,
                                          guint n_param_values,
                                          const GValue * param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_INT) (gpointer data1, const char* arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_int (param_values + 2), data2);
}

static void
value_property_manager_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_property_manager_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		property_manager_unref (value->data[0].v_pointer);
	}
}

static void
value_property_manager_copy_value (const GValue* src_value,
                                   GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = property_manager_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_property_manager_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_property_manager_collect_value (GValue* value,
                                      guint n_collect_values,
                                      GTypeCValue* collect_values,
                                      guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		PropertyManager * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = property_manager_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_property_manager_lcopy_value (const GValue* value,
                                    guint n_collect_values,
                                    GTypeCValue* collect_values,
                                    guint collect_flags)
{
	PropertyManager ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = property_manager_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_property_manager (const gchar* name,
                             const gchar* nick,
                             const gchar* blurb,
                             GType object_type,
                             GParamFlags flags)
{
	ParamSpecPropertyManager* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PROPERTY_MANAGER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_property_manager (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PROPERTY_MANAGER), NULL);
	return value->data[0].v_pointer;
}

void
value_set_property_manager (GValue* value,
                            gpointer v_object)
{
	PropertyManager * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PROPERTY_MANAGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PROPERTY_MANAGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		property_manager_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		property_manager_unref (old);
	}
}

void
value_take_property_manager (GValue* value,
                             gpointer v_object)
{
	PropertyManager * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PROPERTY_MANAGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PROPERTY_MANAGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		property_manager_unref (old);
	}
}

static void
property_manager_class_init (PropertyManagerClass * klass,
                             gpointer klass_data)
{
	property_manager_parent_class = g_type_class_peek_parent (klass);
	((PropertyManagerClass *) klass)->finalize = property_manager_finalize;
	g_type_class_adjust_private_offset (klass, &PropertyManager_private_offset);
	property_manager_signals[PROPERTY_MANAGER_PROPERTY_ACTIVATE_SIGNAL] = g_signal_new ("property-activate", TYPE_PROPERTY_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_INT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_INT);
}

static void
property_manager_instance_init (PropertyManager * self,
                                gpointer klass)
{
	self->priv = property_manager_get_instance_private (self);
	self->ref_count = 1;
}

static void
property_manager_finalize (PropertyManager * obj)
{
	PropertyManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROPERTY_MANAGER, PropertyManager);
	g_signal_handlers_destroy (self);
	_g_object_unref0 (self->priv->m_props);
}

static GType
property_manager_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_property_manager_init, value_property_manager_free_value, value_property_manager_copy_value, value_property_manager_peek_pointer, "p", value_property_manager_collect_value, "p", value_property_manager_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (PropertyManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) property_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropertyManager), 0, (GInstanceInitFunc) property_manager_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType property_manager_type_id;
	property_manager_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PropertyManager", &g_define_type_info, &g_define_type_fundamental_info, 0);
	PropertyManager_private_offset = g_type_add_instance_private (property_manager_type_id, sizeof (PropertyManagerPrivate));
	return property_manager_type_id;
}

GType
property_manager_get_type (void)
{
	static volatile gsize property_manager_type_id__volatile = 0;
	if (g_once_init_enter (&property_manager_type_id__volatile)) {
		GType property_manager_type_id;
		property_manager_type_id = property_manager_get_type_once ();
		g_once_init_leave (&property_manager_type_id__volatile, property_manager_type_id);
	}
	return property_manager_type_id__volatile;
}

gpointer
property_manager_ref (gpointer instance)
{
	PropertyManager * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
property_manager_unref (gpointer instance)
{
	PropertyManager * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PROPERTY_MANAGER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

void
iprop_item_update_property (IPropItem* self,
                            IBusProperty* prop)
{
	IPropItemIface* _iface_;
	g_return_if_fail (self != NULL);
	_iface_ = IPROP_ITEM_GET_INTERFACE (self);
	if (_iface_->update_property) {
		_iface_->update_property (self, prop);
	}
}

static void
iprop_item_default_init (IPropItemIface * iface,
                         gpointer iface_data)
{
	iprop_item_signals[IPROP_ITEM_PROPERTY_ACTIVATE_SIGNAL] = g_signal_new ("property-activate", TYPE_IPROP_ITEM, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_INT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_INT);
}

static GType
iprop_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (IPropItemIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) iprop_item_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType iprop_item_type_id;
	iprop_item_type_id = g_type_register_static (G_TYPE_INTERFACE, "IPropItem", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (iprop_item_type_id, G_TYPE_OBJECT);
	return iprop_item_type_id;
}

GType
iprop_item_get_type (void)
{
	static volatile gsize iprop_item_type_id__volatile = 0;
	if (g_once_init_enter (&iprop_item_type_id__volatile)) {
		GType iprop_item_type_id;
		iprop_item_type_id = iprop_item_get_type_once ();
		g_once_init_leave (&iprop_item_type_id__volatile, iprop_item_type_id);
	}
	return iprop_item_type_id__volatile;
}

static inline gpointer
prop_image_menu_item_get_instance_private (PropImageMenuItem* self)
{
	return G_STRUCT_MEMBER_P (self, PropImageMenuItem_private_offset);
}

PropImageMenuItem*
prop_image_menu_item_construct (GType object_type,
                                IBusProperty* property)
{
	PropImageMenuItem * self = NULL;
	IBusProperty* _tmp0_;
	g_return_val_if_fail (property != NULL, NULL);
	self = (PropImageMenuItem*) g_object_new (object_type, NULL);
	_vala_assert (property != NULL, "property != null");
	_tmp0_ = _g_object_ref0 (property);
	_g_object_unref0 (self->priv->m_property);
	self->priv->m_property = _tmp0_;
	gtk_widget_set_no_show_all ((GtkWidget*) self, TRUE);
	prop_image_menu_item_sync (self);
	return self;
}

PropImageMenuItem*
prop_image_menu_item_new (IBusProperty* property)
{
	return prop_image_menu_item_construct (TYPE_PROP_IMAGE_MENU_ITEM, property);
}

static void
prop_image_menu_item_real_update_property (IPropItem* base,
                                           IBusProperty* property)
{
	PropImageMenuItem * self;
	IBusProperty* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	IBusProperty* _tmp3_;
	IBusText* _tmp4_;
	IBusProperty* _tmp5_;
	IBusProperty* _tmp6_;
	IBusProperty* _tmp7_;
	IBusText* _tmp8_;
	IBusProperty* _tmp9_;
	self = (PropImageMenuItem*) base;
	g_return_if_fail (property != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_key (_tmp0_);
	_tmp2_ = ibus_property_get_key (property);
	if (g_strcmp0 (_tmp1_, _tmp2_) != 0) {
		return;
	}
	_tmp3_ = self->priv->m_property;
	_tmp4_ = ibus_property_get_label (property);
	ibus_property_set_label (_tmp3_, _tmp4_);
	_tmp5_ = self->priv->m_property;
	ibus_property_set_visible (_tmp5_, ibus_property_get_visible (property));
	_tmp6_ = self->priv->m_property;
	ibus_property_set_sensitive (_tmp6_, ibus_property_get_sensitive (property));
	_tmp7_ = self->priv->m_property;
	_tmp8_ = ibus_property_get_tooltip (property);
	ibus_property_set_tooltip (_tmp7_, _tmp8_);
	_tmp9_ = self->priv->m_property;
	ibus_property_set_state (_tmp9_, ibus_property_get_state (property));
	prop_image_menu_item_sync (self);
}

static void
prop_image_menu_item_sync (PropImageMenuItem* self)
{
	IBusProperty* _tmp0_;
	IBusText* _tmp1_;
	const gchar* _tmp2_;
	IBusProperty* _tmp3_;
	IBusProperty* _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_label (_tmp0_);
	_tmp2_ = ibus_text_get_text (_tmp1_);
	gtk_menu_item_set_label ((GtkMenuItem*) self, _tmp2_);
	_tmp3_ = self->priv->m_property;
	gtk_widget_set_visible ((GtkWidget*) self, ibus_property_get_visible (_tmp3_));
	_tmp4_ = self->priv->m_property;
	gtk_widget_set_sensitive ((GtkWidget*) self, ibus_property_get_sensitive (_tmp4_));
}

static void
prop_image_menu_item_real_activate (GtkMenuItem* base)
{
	PropImageMenuItem * self;
	IBusProperty* _tmp0_;
	const gchar* _tmp1_;
	IBusProperty* _tmp2_;
	self = (PropImageMenuItem*) base;
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_key (_tmp0_);
	_tmp2_ = self->priv->m_property;
	g_signal_emit ((IPropItem*) self, iprop_item_signals[IPROP_ITEM_PROPERTY_ACTIVATE_SIGNAL], 0, _tmp1_, (gint) ibus_property_get_state (_tmp2_));
}

static void
prop_image_menu_item_class_init (PropImageMenuItemClass * klass,
                                 gpointer klass_data)
{
	prop_image_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &PropImageMenuItem_private_offset);
	((GtkMenuItemClass *) klass)->activate = (void (*) (GtkMenuItem*)) prop_image_menu_item_real_activate;
	G_OBJECT_CLASS (klass)->finalize = prop_image_menu_item_finalize;
}

static void
prop_image_menu_item_iprop_item_interface_init (IPropItemIface * iface,
                                                gpointer iface_data)
{
	prop_image_menu_item_iprop_item_parent_iface = g_type_interface_peek_parent (iface);
	iface->update_property = (void (*) (IPropItem*, IBusProperty*)) prop_image_menu_item_real_update_property;
}

static void
prop_image_menu_item_instance_init (PropImageMenuItem * self,
                                    gpointer klass)
{
	self->priv = prop_image_menu_item_get_instance_private (self);
}

static void
prop_image_menu_item_finalize (GObject * obj)
{
	PropImageMenuItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROP_IMAGE_MENU_ITEM, PropImageMenuItem);
	_g_object_unref0 (self->priv->m_property);
	G_OBJECT_CLASS (prop_image_menu_item_parent_class)->finalize (obj);
}

static GType
prop_image_menu_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PropImageMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) prop_image_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropImageMenuItem), 0, (GInstanceInitFunc) prop_image_menu_item_instance_init, NULL };
	static const GInterfaceInfo iprop_item_info = { (GInterfaceInitFunc) prop_image_menu_item_iprop_item_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType prop_image_menu_item_type_id;
	prop_image_menu_item_type_id = g_type_register_static (gtk_menu_item_get_type (), "PropImageMenuItem", &g_define_type_info, 0);
	g_type_add_interface_static (prop_image_menu_item_type_id, TYPE_IPROP_ITEM, &iprop_item_info);
	PropImageMenuItem_private_offset = g_type_add_instance_private (prop_image_menu_item_type_id, sizeof (PropImageMenuItemPrivate));
	return prop_image_menu_item_type_id;
}

GType
prop_image_menu_item_get_type (void)
{
	static volatile gsize prop_image_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&prop_image_menu_item_type_id__volatile)) {
		GType prop_image_menu_item_type_id;
		prop_image_menu_item_type_id = prop_image_menu_item_get_type_once ();
		g_once_init_leave (&prop_image_menu_item_type_id__volatile, prop_image_menu_item_type_id);
	}
	return prop_image_menu_item_type_id__volatile;
}

static inline gpointer
prop_check_menu_item_get_instance_private (PropCheckMenuItem* self)
{
	return G_STRUCT_MEMBER_P (self, PropCheckMenuItem_private_offset);
}

PropCheckMenuItem*
prop_check_menu_item_construct (GType object_type,
                                IBusProperty* property)
{
	PropCheckMenuItem * self = NULL;
	IBusProperty* _tmp0_;
	g_return_val_if_fail (property != NULL, NULL);
	self = (PropCheckMenuItem*) g_object_new (object_type, NULL);
	_vala_assert (property != NULL, "property != null");
	_tmp0_ = _g_object_ref0 (property);
	_g_object_unref0 (self->priv->m_property);
	self->priv->m_property = _tmp0_;
	gtk_widget_set_no_show_all ((GtkWidget*) self, TRUE);
	prop_check_menu_item_sync (self);
	return self;
}

PropCheckMenuItem*
prop_check_menu_item_new (IBusProperty* property)
{
	return prop_check_menu_item_construct (TYPE_PROP_CHECK_MENU_ITEM, property);
}

static void
prop_check_menu_item_real_update_property (IPropItem* base,
                                           IBusProperty* property)
{
	PropCheckMenuItem * self;
	IBusProperty* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	IBusProperty* _tmp3_;
	IBusText* _tmp4_;
	IBusProperty* _tmp5_;
	const gchar* _tmp6_;
	IBusProperty* _tmp7_;
	IBusProperty* _tmp8_;
	IBusProperty* _tmp9_;
	IBusText* _tmp10_;
	IBusProperty* _tmp11_;
	self = (PropCheckMenuItem*) base;
	g_return_if_fail (property != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_key (_tmp0_);
	_tmp2_ = ibus_property_get_key (property);
	if (g_strcmp0 (_tmp1_, _tmp2_) != 0) {
		return;
	}
	_tmp3_ = self->priv->m_property;
	_tmp4_ = ibus_property_get_label (property);
	ibus_property_set_label (_tmp3_, _tmp4_);
	_tmp5_ = self->priv->m_property;
	_tmp6_ = ibus_property_get_icon (property);
	ibus_property_set_icon (_tmp5_, _tmp6_);
	_tmp7_ = self->priv->m_property;
	ibus_property_set_visible (_tmp7_, ibus_property_get_visible (property));
	_tmp8_ = self->priv->m_property;
	ibus_property_set_sensitive (_tmp8_, ibus_property_get_sensitive (property));
	_tmp9_ = self->priv->m_property;
	_tmp10_ = ibus_property_get_tooltip (property);
	ibus_property_set_tooltip (_tmp9_, _tmp10_);
	_tmp11_ = self->priv->m_property;
	ibus_property_set_state (_tmp11_, ibus_property_get_state (property));
	prop_check_menu_item_sync (self);
}

static void
prop_check_menu_item_sync (PropCheckMenuItem* self)
{
	IBusProperty* _tmp0_;
	IBusText* _tmp1_;
	const gchar* _tmp2_;
	IBusProperty* _tmp3_;
	IBusProperty* _tmp4_;
	IBusProperty* _tmp5_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_label (_tmp0_);
	_tmp2_ = ibus_text_get_text (_tmp1_);
	gtk_menu_item_set_label ((GtkMenuItem*) self, _tmp2_);
	_tmp3_ = self->priv->m_property;
	gtk_widget_set_visible ((GtkWidget*) self, ibus_property_get_visible (_tmp3_));
	_tmp4_ = self->priv->m_property;
	gtk_widget_set_sensitive ((GtkWidget*) self, ibus_property_get_sensitive (_tmp4_));
	_tmp5_ = self->priv->m_property;
	gtk_check_menu_item_set_active ((GtkCheckMenuItem*) self, ibus_property_get_state (_tmp5_) == PROP_STATE_CHECKED);
}

static void
prop_check_menu_item_real_toggled (GtkCheckMenuItem* base)
{
	PropCheckMenuItem * self;
	IBusPropState _tmp0_ = 0;
	IBusPropState new_state = 0;
	IBusProperty* _tmp1_;
	IBusPropState _tmp2_;
	self = (PropCheckMenuItem*) base;
	if (gtk_check_menu_item_get_active ((GtkCheckMenuItem*) self)) {
		_tmp0_ = PROP_STATE_CHECKED;
	} else {
		_tmp0_ = PROP_STATE_UNCHECKED;
	}
	new_state = _tmp0_;
	_tmp1_ = self->priv->m_property;
	_tmp2_ = new_state;
	if (ibus_property_get_state (_tmp1_) != _tmp2_) {
		IBusProperty* _tmp3_;
		IBusPropState _tmp4_;
		IBusProperty* _tmp5_;
		const gchar* _tmp6_;
		IBusProperty* _tmp7_;
		_tmp3_ = self->priv->m_property;
		_tmp4_ = new_state;
		ibus_property_set_state (_tmp3_, _tmp4_);
		_tmp5_ = self->priv->m_property;
		_tmp6_ = ibus_property_get_key (_tmp5_);
		_tmp7_ = self->priv->m_property;
		g_signal_emit ((IPropItem*) self, iprop_item_signals[IPROP_ITEM_PROPERTY_ACTIVATE_SIGNAL], 0, _tmp6_, (gint) ibus_property_get_state (_tmp7_));
	}
}

static void
prop_check_menu_item_class_init (PropCheckMenuItemClass * klass,
                                 gpointer klass_data)
{
	prop_check_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &PropCheckMenuItem_private_offset);
	((GtkCheckMenuItemClass *) klass)->toggled = (void (*) (GtkCheckMenuItem*)) prop_check_menu_item_real_toggled;
	G_OBJECT_CLASS (klass)->finalize = prop_check_menu_item_finalize;
}

static void
prop_check_menu_item_iprop_item_interface_init (IPropItemIface * iface,
                                                gpointer iface_data)
{
	prop_check_menu_item_iprop_item_parent_iface = g_type_interface_peek_parent (iface);
	iface->update_property = (void (*) (IPropItem*, IBusProperty*)) prop_check_menu_item_real_update_property;
}

static void
prop_check_menu_item_instance_init (PropCheckMenuItem * self,
                                    gpointer klass)
{
	self->priv = prop_check_menu_item_get_instance_private (self);
}

static void
prop_check_menu_item_finalize (GObject * obj)
{
	PropCheckMenuItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROP_CHECK_MENU_ITEM, PropCheckMenuItem);
	_g_object_unref0 (self->priv->m_property);
	G_OBJECT_CLASS (prop_check_menu_item_parent_class)->finalize (obj);
}

static GType
prop_check_menu_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PropCheckMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) prop_check_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropCheckMenuItem), 0, (GInstanceInitFunc) prop_check_menu_item_instance_init, NULL };
	static const GInterfaceInfo iprop_item_info = { (GInterfaceInitFunc) prop_check_menu_item_iprop_item_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType prop_check_menu_item_type_id;
	prop_check_menu_item_type_id = g_type_register_static (gtk_check_menu_item_get_type (), "PropCheckMenuItem", &g_define_type_info, 0);
	g_type_add_interface_static (prop_check_menu_item_type_id, TYPE_IPROP_ITEM, &iprop_item_info);
	PropCheckMenuItem_private_offset = g_type_add_instance_private (prop_check_menu_item_type_id, sizeof (PropCheckMenuItemPrivate));
	return prop_check_menu_item_type_id;
}

GType
prop_check_menu_item_get_type (void)
{
	static volatile gsize prop_check_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&prop_check_menu_item_type_id__volatile)) {
		GType prop_check_menu_item_type_id;
		prop_check_menu_item_type_id = prop_check_menu_item_get_type_once ();
		g_once_init_leave (&prop_check_menu_item_type_id__volatile, prop_check_menu_item_type_id);
	}
	return prop_check_menu_item_type_id__volatile;
}

static inline gpointer
prop_radio_menu_item_get_instance_private (PropRadioMenuItem* self)
{
	return G_STRUCT_MEMBER_P (self, PropRadioMenuItem_private_offset);
}

PropRadioMenuItem*
prop_radio_menu_item_construct (GType object_type,
                                IBusProperty* property,
                                PropRadioMenuItem* group_source)
{
	PropRadioMenuItem * self = NULL;
	IBusProperty* _tmp0_;
	g_return_val_if_fail (property != NULL, NULL);
	self = (PropRadioMenuItem*) g_object_new (object_type, NULL);
	_vala_assert (property != NULL, "property != null");
	_tmp0_ = _g_object_ref0 (property);
	_g_object_unref0 (self->priv->m_property);
	self->priv->m_property = _tmp0_;
	gtk_widget_set_no_show_all ((GtkWidget*) self, TRUE);
	if (group_source != NULL) {
		GSList* _tmp1_;
		_tmp1_ = gtk_radio_menu_item_get_group ((GtkRadioMenuItem*) group_source);
		gtk_radio_menu_item_set_group ((GtkRadioMenuItem*) self, _tmp1_);
	}
	prop_radio_menu_item_sync (self);
	return self;
}

PropRadioMenuItem*
prop_radio_menu_item_new (IBusProperty* property,
                          PropRadioMenuItem* group_source)
{
	return prop_radio_menu_item_construct (TYPE_PROP_RADIO_MENU_ITEM, property, group_source);
}

static void
prop_radio_menu_item_real_update_property (IPropItem* base,
                                           IBusProperty* property)
{
	PropRadioMenuItem * self;
	IBusProperty* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	IBusProperty* _tmp3_;
	IBusText* _tmp4_;
	IBusProperty* _tmp5_;
	const gchar* _tmp6_;
	IBusProperty* _tmp7_;
	IBusProperty* _tmp8_;
	IBusProperty* _tmp9_;
	IBusText* _tmp10_;
	IBusProperty* _tmp11_;
	self = (PropRadioMenuItem*) base;
	g_return_if_fail (property != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_key (_tmp0_);
	_tmp2_ = ibus_property_get_key (property);
	if (g_strcmp0 (_tmp1_, _tmp2_) != 0) {
		return;
	}
	_tmp3_ = self->priv->m_property;
	_tmp4_ = ibus_property_get_label (property);
	ibus_property_set_label (_tmp3_, _tmp4_);
	_tmp5_ = self->priv->m_property;
	_tmp6_ = ibus_property_get_icon (property);
	ibus_property_set_icon (_tmp5_, _tmp6_);
	_tmp7_ = self->priv->m_property;
	ibus_property_set_visible (_tmp7_, ibus_property_get_visible (property));
	_tmp8_ = self->priv->m_property;
	ibus_property_set_sensitive (_tmp8_, ibus_property_get_sensitive (property));
	_tmp9_ = self->priv->m_property;
	_tmp10_ = ibus_property_get_tooltip (property);
	ibus_property_set_tooltip (_tmp9_, _tmp10_);
	_tmp11_ = self->priv->m_property;
	ibus_property_set_state (_tmp11_, ibus_property_get_state (property));
	prop_radio_menu_item_sync (self);
}

static void
prop_radio_menu_item_sync (PropRadioMenuItem* self)
{
	IBusProperty* _tmp0_;
	IBusText* _tmp1_;
	const gchar* _tmp2_;
	IBusProperty* _tmp3_;
	IBusProperty* _tmp4_;
	IBusProperty* _tmp5_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->m_property;
	_tmp1_ = ibus_property_get_label (_tmp0_);
	_tmp2_ = ibus_text_get_text (_tmp1_);
	gtk_menu_item_set_label ((GtkMenuItem*) self, _tmp2_);
	_tmp3_ = self->priv->m_property;
	gtk_widget_set_visible ((GtkWidget*) self, ibus_property_get_visible (_tmp3_));
	_tmp4_ = self->priv->m_property;
	gtk_widget_set_sensitive ((GtkWidget*) self, ibus_property_get_sensitive (_tmp4_));
	_tmp5_ = self->priv->m_property;
	gtk_check_menu_item_set_active ((GtkCheckMenuItem*) self, ibus_property_get_state (_tmp5_) == PROP_STATE_CHECKED);
}

static void
prop_radio_menu_item_real_toggled (GtkCheckMenuItem* base)
{
	PropRadioMenuItem * self;
	IBusPropState _tmp0_ = 0;
	IBusPropState new_state = 0;
	IBusProperty* _tmp1_;
	IBusPropState _tmp2_;
	self = (PropRadioMenuItem*) base;
	if (gtk_check_menu_item_get_active ((GtkCheckMenuItem*) self)) {
		_tmp0_ = PROP_STATE_CHECKED;
	} else {
		_tmp0_ = PROP_STATE_UNCHECKED;
	}
	new_state = _tmp0_;
	_tmp1_ = self->priv->m_property;
	_tmp2_ = new_state;
	if (ibus_property_get_state (_tmp1_) != _tmp2_) {
		IBusProperty* _tmp3_;
		IBusPropState _tmp4_;
		IBusProperty* _tmp5_;
		const gchar* _tmp6_;
		IBusProperty* _tmp7_;
		_tmp3_ = self->priv->m_property;
		_tmp4_ = new_state;
		ibus_property_set_state (_tmp3_, _tmp4_);
		_tmp5_ = self->priv->m_property;
		_tmp6_ = ibus_property_get_key (_tmp5_);
		_tmp7_ = self->priv->m_property;
		g_signal_emit ((IPropItem*) self, iprop_item_signals[IPROP_ITEM_PROPERTY_ACTIVATE_SIGNAL], 0, _tmp6_, (gint) ibus_property_get_state (_tmp7_));
	}
}

static void
prop_radio_menu_item_class_init (PropRadioMenuItemClass * klass,
                                 gpointer klass_data)
{
	prop_radio_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &PropRadioMenuItem_private_offset);
	((GtkCheckMenuItemClass *) klass)->toggled = (void (*) (GtkCheckMenuItem*)) prop_radio_menu_item_real_toggled;
	G_OBJECT_CLASS (klass)->finalize = prop_radio_menu_item_finalize;
}

static void
prop_radio_menu_item_iprop_item_interface_init (IPropItemIface * iface,
                                                gpointer iface_data)
{
	prop_radio_menu_item_iprop_item_parent_iface = g_type_interface_peek_parent (iface);
	iface->update_property = (void (*) (IPropItem*, IBusProperty*)) prop_radio_menu_item_real_update_property;
}

static void
prop_radio_menu_item_instance_init (PropRadioMenuItem * self,
                                    gpointer klass)
{
	self->priv = prop_radio_menu_item_get_instance_private (self);
}

static void
prop_radio_menu_item_finalize (GObject * obj)
{
	PropRadioMenuItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROP_RADIO_MENU_ITEM, PropRadioMenuItem);
	_g_object_unref0 (self->priv->m_property);
	G_OBJECT_CLASS (prop_radio_menu_item_parent_class)->finalize (obj);
}

static GType
prop_radio_menu_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PropRadioMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) prop_radio_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropRadioMenuItem), 0, (GInstanceInitFunc) prop_radio_menu_item_instance_init, NULL };
	static const GInterfaceInfo iprop_item_info = { (GInterfaceInitFunc) prop_radio_menu_item_iprop_item_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType prop_radio_menu_item_type_id;
	prop_radio_menu_item_type_id = g_type_register_static (gtk_radio_menu_item_get_type (), "PropRadioMenuItem", &g_define_type_info, 0);
	g_type_add_interface_static (prop_radio_menu_item_type_id, TYPE_IPROP_ITEM, &iprop_item_info);
	PropRadioMenuItem_private_offset = g_type_add_instance_private (prop_radio_menu_item_type_id, sizeof (PropRadioMenuItemPrivate));
	return prop_radio_menu_item_type_id;
}

GType
prop_radio_menu_item_get_type (void)
{
	static volatile gsize prop_radio_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&prop_radio_menu_item_type_id__volatile)) {
		GType prop_radio_menu_item_type_id;
		prop_radio_menu_item_type_id = prop_radio_menu_item_get_type_once ();
		g_once_init_leave (&prop_radio_menu_item_type_id__volatile, prop_radio_menu_item_type_id);
	}
	return prop_radio_menu_item_type_id__volatile;
}

static inline gpointer
prop_separator_menu_item_get_instance_private (PropSeparatorMenuItem* self)
{
	return G_STRUCT_MEMBER_P (self, PropSeparatorMenuItem_private_offset);
}

PropSeparatorMenuItem*
prop_separator_menu_item_construct (GType object_type,
                                    IBusProperty* property)
{
	PropSeparatorMenuItem * self = NULL;
	IBusProperty* _tmp0_;
	g_return_val_if_fail (property != NULL, NULL);
	self = (PropSeparatorMenuItem*) g_object_new (object_type, NULL);
	_vala_assert (property != NULL, "property != null");
	_tmp0_ = _g_object_ref0 (property);
	_g_object_unref0 (self->priv->m_property);
	self->priv->m_property = _tmp0_;
	return self;
}

PropSeparatorMenuItem*
prop_separator_menu_item_new (IBusProperty* property)
{
	return prop_separator_menu_item_construct (TYPE_PROP_SEPARATOR_MENU_ITEM, property);
}

static void
prop_separator_menu_item_real_update_property (IPropItem* base,
                                               IBusProperty* property)
{
	PropSeparatorMenuItem * self;
	self = (PropSeparatorMenuItem*) base;
	g_return_if_fail (property != NULL);
}

static void
prop_separator_menu_item_class_init (PropSeparatorMenuItemClass * klass,
                                     gpointer klass_data)
{
	prop_separator_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &PropSeparatorMenuItem_private_offset);
	G_OBJECT_CLASS (klass)->finalize = prop_separator_menu_item_finalize;
}

static void
prop_separator_menu_item_iprop_item_interface_init (IPropItemIface * iface,
                                                    gpointer iface_data)
{
	prop_separator_menu_item_iprop_item_parent_iface = g_type_interface_peek_parent (iface);
	iface->update_property = (void (*) (IPropItem*, IBusProperty*)) prop_separator_menu_item_real_update_property;
}

static void
prop_separator_menu_item_instance_init (PropSeparatorMenuItem * self,
                                        gpointer klass)
{
	self->priv = prop_separator_menu_item_get_instance_private (self);
}

static void
prop_separator_menu_item_finalize (GObject * obj)
{
	PropSeparatorMenuItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PROP_SEPARATOR_MENU_ITEM, PropSeparatorMenuItem);
	_g_object_unref0 (self->priv->m_property);
	G_OBJECT_CLASS (prop_separator_menu_item_parent_class)->finalize (obj);
}

static GType
prop_separator_menu_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PropSeparatorMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) prop_separator_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PropSeparatorMenuItem), 0, (GInstanceInitFunc) prop_separator_menu_item_instance_init, NULL };
	static const GInterfaceInfo iprop_item_info = { (GInterfaceInitFunc) prop_separator_menu_item_iprop_item_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType prop_separator_menu_item_type_id;
	prop_separator_menu_item_type_id = g_type_register_static (gtk_separator_menu_item_get_type (), "PropSeparatorMenuItem", &g_define_type_info, 0);
	g_type_add_interface_static (prop_separator_menu_item_type_id, TYPE_IPROP_ITEM, &iprop_item_info);
	PropSeparatorMenuItem_private_offset = g_type_add_instance_private (prop_separator_menu_item_type_id, sizeof (PropSeparatorMenuItemPrivate));
	return prop_separator_menu_item_type_id;
}

GType
prop_separator_menu_item_get_type (void)
{
	static volatile gsize prop_separator_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&prop_separator_menu_item_type_id__volatile)) {
		GType prop_separator_menu_item_type_id;
		prop_separator_menu_item_type_id = prop_separator_menu_item_get_type_once ();
		g_once_init_leave (&prop_separator_menu_item_type_id__volatile, prop_separator_menu_item_type_id);
	}
	return prop_separator_menu_item_type_id__volatile;
}

